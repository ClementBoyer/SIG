warning: refname 'HEAD' is ambiguous.
warning: LF will be replaced by CRLF in README.md.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in RELEASE-NOTES.md.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in build.gradle.
The file will have its original line endings in your working directory.
diff --git a/.gitignore b/.gitignore
index 241265f..e956a5b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -17,8 +17,3 @@ target/
 
 
 *~
-
-# eclipse
-.classpath
-.project
-test262
diff --git a/.gitmodules b/.gitmodules
deleted file mode 100644
index c41542f..0000000
--- a/.gitmodules
+++ /dev/null
@@ -1,3 +0,0 @@
-[submodule "test262"]
-	path = test262
-	url = https://github.com/tc39/test262.git
diff --git a/README.md b/README.md
index 0acee8a..2db8ff2 100644
--- a/README.md
+++ b/README.md
@@ -13,8 +13,6 @@ Rhino is licensed under the [MPL 2.0](./LICENSE.txt).
 <table>
 <tr><td><a href="https://github.com/mozilla/rhino/releases/tag/Rhino1_7R5_RELEASE">Rhino 1.7R5</a></td><td>January 29, 2015</td></tr>
 <tr><td><a href="https://github.com/mozilla/rhino/releases/tag/Rhino1_7_6_RELEASE">Rhino 1.7.6</a></td><td>April 15, 2015</td></tr>
-<tr><td><a href="https://github.com/mozilla/rhino/releases/tag/Rhino1_7_7_RELEASE">Rhino 1.7.7</a></td><td>June 17, 2015</td></tr>
-<tr><td><a href="https://github.com/mozilla/rhino/releases/tag/Rhino1_7_7_1_RELEASE">Rhino 1.7.7.1</a></td><td>February 2, 2016</td></tr>
 </table>
 
 [Release Notes](./RELEASE-NOTES.md) for recent releases.
@@ -94,8 +92,8 @@ mavenReleaseRepo=
 
 Rhino can run as a stand-alone interpreter from the command line:
 
-    java -jar buildGradle/libs/rhino-1.7.7.1.jar
-    Rhino 1.7.7 2015 05 03
+    java -jar build/libs/rhino-1.7.7-SNAPSHOT.jar
+    Rhino 1.7.7-SNAPSHOT 2015 05 03
     js> print('Hello, World!');
     Hello, World!
     js>
diff --git a/RELEASE-NOTES.md b/RELEASE-NOTES.md
index f9c0fc4..299f831 100644
--- a/RELEASE-NOTES.md
+++ b/RELEASE-NOTES.md
@@ -1,133 +1,3 @@
-# Rhino 1.7.7.1
-## February 1, 2016
-
-This release fixes a few critical bugs that were affecting code in the field:
-
-* Improve String.prototype.repeat to work more efficiently and to not overflow
-* Fix CallSite.isNative() and isTopLevel() so that they do not throw fatal errors
-* Replace the implementation of the "YearFromTime" internal method for the Date class to avoid large CPU loops
-
-Specific Changes:
-
-*     Formatting issue with SourceReader.
-*     Fix CallSite.isNative() and isTopLevel() to not throw.
-*     Make String.prototype.repeat not overflow for large values, and change code style a bit.
-*     Add tests from 1.7.7.
-*     Add Gradle code from 1.7.7.
-*     Replace YearFromTime with code from jsdate.cpp to avoid long CPU loops.
-
-# Rhino 1.7.7
-## June 17, 2015
-
-Major changes in this release:
-
-[Release 1.7.7](https://github.com/mozilla/rhino/issues?q=milestone%3A%22Release+1.7.7%22+is%3Aclosed)
-
-Specific changes:
-
-* [Issue 202](https://github.com/mozilla/rhino/issues/202) Initial support for ECMA Script 6 "method definitions".
-* [Issue 201](https://github.com/mozilla/rhino/issues/201) Make sure that all native Error instances can be converted
-to JSON.
-* [Issue 184](https://github.com/mozilla/rhino/issues/184) Fix compile encoding errors.
-* [Issue 178](https://github.com/mozilla/rhino/issues/178) Support build using Gradle (build using Ant is still
-supported but will be removed in a future release.)
-* [Issue 176](https://github.com/mozilla/rhino/issues/176) Add ScriptRuntime.throwCustomError to make it easier
-to re-throw Java exceptions
-* [Issue 166](https://github.com/mozilla/rhino/issues/166) Support many ES6 additions to the Math class.
-* [Issue 165](https://github.com/mozilla/rhino/issues/165) Support many ES6 additions to the Number class.
-* [Issue 163](https://github.com/mozilla/rhino/issues/163) Support ES6 additions to the String class.
-
-Thanks to everyone who contributed!
-
-Ahmed Ashour (3):
-*     Add .gitattributes for End-Of-Line automatic handling
-*     Remove extra space
-*     Update .gitignore for eclipse generated files.
-
-Evgeny Shepelyuk (45):
-*     Implementing possibility of writing  JS tests code inside JUnit Test.
-*     + gradle wrapper     + sources and test compilation     + jar building
-*     + More JUnit style for Gradle compatibility     - disabled test removed
-*     + running tests
-*     + benchmark test changes for Gradle compaibility     + run benchmark from Gradle     + publishing artifacts from Gradle
-*     + benchmark test changes for Gradle compaibility     + run benchmark from Gradle     + publishing artifacts from Gradle
-*     + publishing artifacts to maven compatible repositories
-*     + releasing with Gradle
-*     + releasing with Gradle
-*     + releasing with Gradle
-*     + releasing with Gradle
-*     [Gradle Release Plugin] - new version commit:  '1.7.8'.
-*     + releasing with Gradle
-*     + releasing with Gradle
-*     + releasing with Gradle
-*     [Gradle Release Plugin] - pre tag commit:  '1.7.8'.
-*     Revert "+ publishing artifacts to maven compatible repositories"
-*     rollback gradle release
-*     + properly populating manifest     + exclude unnecesary files from jar
-*     + adding license to jar
-*     + build will not fail when maven credentials are not defined
-*     + getting rhino display version from MANIFEST
-*     * modifying README with Gradle details
-*     Update README.md
-*     Improving reporting of MozillaSuiteTest tests
-*     Improving reporting of MozillaSuiteTest tests
-*     + initial implementation of String.prototype.includes
-*     + initial implementation of String.prototype.includes
-*     + initial implementation of String.prototype.includes
-*     + initial implementation of String.prototype.startsWith
-*     + initial implementation of String.prototype.startsWith
-*     + initial implementation of String.prototype.endsWith
-*     + initial implementation of String.prototype.endsWith
-*     + initial implementation of String.prototype.endsWith
-*     + implementation of String.prototype.normalize
-*     + implementation of String.prototype.normalize
-*     + implementation of String.prototype.normalize
-*     + implementation of String.prototype.repeat
-*     + implementation of String.prototype.repeat
-*     + implementation of String.prototype.codePointAt
-*     + implementation of String.prototype.codePointAt
-*     * fixing tests after implementation of ES6 string methods     + implementing RequireObjectCoercible from ECMA spec
-*     * fixing tests after implementation of ES6 string methods     + implementing RequireObjectCoercible from ECMA spec
-*     * fixing tests after implementation of ES6 string methods     + implementing RequireObjectCoercible from ECMA spec
-*     Better exception reporting
-
-Gregory Brail (16):
-*     Update for new development iteration.
-*     Read manifest URLs in a loop until we find the right one when trying     to determine the implementation version.
-*     Permissions fix.
-*     Fix potential NPE in ComplianceTest.
-*     Re-run IDMap on NativeString.
-*     Merge branch 'issue_176_2' of https://github.com/raimi/rhino into raimi-issue_176_2
-*     Merge branch 'master' of https://github.com/asashour/rhino into asashour-master
-*     Add .gitattributes.
-*     Re-arrange "global variables" regression tests for fewer spurious failures     under Gradle.
-*     Don't make "javaException" and "rhinoException" on the NativeError     object enumerable, because they cannot be converted to JSON.
-*     Fix file name for V8 benchmark results.
-*     Add some ES6 methods to Math and Number.
-*     "BigO" regression test exhibits different and inconsistent behavior     on Java 8. So fix it.
-*     Fix a bug in Math.hypot().
-*     Added a constant for ECMAScript 6 language level:     Context.VERSION_ES6.
-*     Add "readline" and "write" to console.
-
-Raimund Jacob (5):
-*     Allow throwing arbitrary objects from java world
-*     176: Adjust javadoc to reality.
-*     Emacs, sorry
-*     Issue176: Test infrastructure
-*     176: Actually Working Tests
-
-sainaen (1):
-*     Print exception message in case of JavaScriptException in ScriptTestsBase
-
-tntim96 (1):
-*     Fix Test compile encoding error 'unmappable character for encoding ASCII' - https://github.com/mozilla/rhino/issues/184
-
-uchida_t (5):
-*     set capacity for StringBuilder in String#repeat
-*     Implement ES6 MethodDefinition
-*     `set` and `get` is valid method name.
-*     NumericLiteral/StringLiteral is valid method name.
-
 # Rhino 1.7.6
 ## April 15, 2015
 
diff --git a/build.gradle b/build.gradle
index c5f1be3..d8e8a48 100644
--- a/build.gradle
+++ b/build.gradle
@@ -1,8 +1,8 @@
+import sun.applet.Main
+
 apply plugin: 'java'
 apply plugin: 'idea'
 apply plugin: 'maven-publish'
-apply plugin: 'jacoco'
-apply plugin: 'distribution'
 
 sourceCompatibility = 1.6
 targetCompatibility = 1.6
@@ -42,8 +42,6 @@ sourceSets {
 
 dependencies {
     testCompile "junit:junit:4.12"
-    testCompile "org.yaml:snakeyaml:1.15"
-    testCompile "net.trajano.caliper:caliper:1.2.1"
 }
 
 test {
@@ -54,39 +52,18 @@ test {
     systemProperty 'user.language', 'en'
     systemProperty 'user.country', 'US'
     systemProperty 'user.timezone', 'America/Los_Angeles'
-    systemProperty 'file.encoding', 'UTF-8'
     maxHeapSize = "256m"
     testLogging.showStandardStreams = true
 }
 
-task sunSpiderBenchmark(type: JavaExec) {
-    main "com.google.caliper.runner.CaliperMain"
-    systemProperty 'rhino.benchmark.report', "${buildDir.absolutePath}"
-    args "-Cresults.upload.class=org.mozilla.javascript.benchmarks.ResultPlotter", "-i", "runtime", "org.mozilla.javascript.benchmarks.CaliperSpiderBenchmark.Spider"
-    classpath sourceSets.test.runtimeClasspath
-}
-
 task testBenchmark(type: Test) {
-    jacoco {
-        enabled = false
-    }
-    include "**/benchmarks/V8Benchmark*"
+    include "**/benchmarks/*Benchmark*"
     systemProperty 'rhino.benchmark.report', "${buildDir.absolutePath}"
-    systemProperty 'file.encoding', 'UTF-8'
     workingDir = file("testsrc/benchmarks")
     maxHeapSize = "256m"
     testLogging.showStandardStreams = true
     forkEvery = 1
 }
-testBenchmark.dependsOn sunSpiderBenchmark
-
-task microBenchmark(type: JavaExec) {
-    main "com.google.caliper.runner.CaliperMain"
-    args "-i", "runtime", "org.mozilla.javascript.benchmarks.CaliperObjectBenchmark.FieldAccess", "-DstringKeys=100,1000", "-DintKeys=0,10,1000"
-    classpath sourceSets.test.runtimeClasspath
-}
-
-
 
 idea {
     module {
@@ -132,9 +109,6 @@ task rhinoJavadocJar(type: Jar, dependsOn: rhinoJavadoc) {
 publishing {
     publications {
         rhino(MavenPublication) {
-            groupId 'org.mozilla'
-            artifactId 'rhino'
-
             pom.withXml {
                 def root = asNode()
 
@@ -144,11 +118,6 @@ publishing {
 """)
                 root.appendNode("url", "https://developer.mozilla.org/en/Rhino")
 
-                def p = root.appendNode("parent")
-                p.appendNode("groupId", "org.sonatype.oss")
-                p.appendNode("artifactId", "oss-parent")
-                p.appendNode("version", "7")
-
                 def l = root.appendNode("licenses").appendNode("license")
                 l.appendNode("name", "Mozilla Public License, Version 2.0")
                 l.appendNode("url", "http://www.mozilla.org/MPL/2.0/index.txt")
@@ -188,45 +157,4 @@ publishing {
             }
         }
     }
-}
-
-jacoco {
-    toolVersion = "0.7.4.201502262128"
-}
-
-jacocoTestReport.dependsOn test
-jacocoTestReport {
-    reports {
-        html.destination "${buildDir}/jacocoHtml"
-    }
-}
-
-
-
-distributions {
-    main {
-        contents {
-            from(sourceSets.main.allSource) {
-                exclude 'man'
-                into 'rhino' + project.version + '/src'
-            }
-            from(javadoc.destinationDir) {
-                into 'rhino' + project.version + '/docs'
-            }
-            from(jar.outputs.files) {
-                into 'rhino' + project.version + '/lib'
-            }
-            from(sourceSets.main.allSource) {
-                include 'man/*.1'
-                into 'rhino' + project.version
-            }
-            from(file(".")) {
-                include '*.txt'
-                into 'rhino' + project.version 
-            }
-            into "/"
-        }
-    }
-}
-
-distZip.dependsOn javadoc, jar
+}
\ No newline at end of file
diff --git a/build.properties b/build.properties
index a22d698..8a9a7f5 100644
warning: LF will be replaced by CRLF in build.properties.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in gradle.properties.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in gradle/wrapper/gradle-wrapper.properties.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in maven/maven-pom.xml.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in maven/maven-snapshot-deploy.sh.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in maven/maven-staging-deploy.sh.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/manifest.
The file will have its original line endings in your working directory.
--- a/build.properties
+++ b/build.properties
@@ -4,9 +4,9 @@
 
 name: rhino
 Name: Rhino
-version: 1.7.8-SNAPSHOT
+version: 1.7.7
 # See Context#getImplementationVersion() for format of this!
-implementation.version: Rhino 1.7.8-SNAPSHOT ${implementation.date}
+implementation.version: Rhino 1.7.7 ${implementation.date}
 
 build.dir: build
 rhino.jar: js.jar
diff --git a/gradle.properties b/gradle.properties
index 20f9731..bad960b 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,5 @@
 #Sun, 26 Apr 2015 10:43:55 +0300
 rootProject.name=rhino
 group=org.mozilla
-version=1.7.8-SNAPSHOT
+version=1.7.7-SNAPSHOT
 buildDir=buildGradle
-mavenSnapshotRepo=https://oss.sonatype.org/content/repositories/snapshots
-mavenReleaseRepo=https://oss.sonatype.org/service/local/staging/deploy/maven
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index fd7e590..085a1cd 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 57efa16..9304b3c 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 01 10:11:01 PDT 2015
+#Sun Apr 26 16:37:24 EEST 2015
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.6-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip
diff --git a/maven/maven-pom.xml b/maven/maven-pom.xml
index effb89d..f189e25 100644
--- a/maven/maven-pom.xml
+++ b/maven/maven-pom.xml
@@ -12,7 +12,7 @@
   <groupId>org.mozilla</groupId>
   <artifactId>rhino</artifactId>
   <name>Mozilla Rhino</name>
-  <version>1.7.8-SNAPSHOT</version>
+  <version>1.7.7-SNAPSHOT</version>
 
   <packaging>jar</packaging>
   <description>
diff --git a/maven/maven-snapshot-deploy.sh b/maven/maven-snapshot-deploy.sh
index 7c6d459..adecde0 100755
--- a/maven/maven-snapshot-deploy.sh
+++ b/maven/maven-snapshot-deploy.sh
@@ -1,15 +1,7 @@
 #!/bin/sh
 
-deployFile=`ls ../buildGradle/libs/rhino*.jar`
-
-if [ ! -f $deployFile ]
-then
-  echo "File cannot be found in $deployFile"
-  exit 2
-fi
-
 mvn deploy:deploy-file \
-  -Dfile=${deployFile} \
+  -Dfile=../build/rhino1_7R5pre/js.jar \
   -DpomFile=maven-pom.xml \
   -DrepositoryId=sonatype-nexus-snapshots \
   -Durl=https://oss.sonatype.org/content/repositories/snapshots/
diff --git a/maven/maven-staging-deploy.sh b/maven/maven-staging-deploy.sh
index 5159608..323e025 100755
--- a/maven/maven-staging-deploy.sh
+++ b/maven/maven-staging-deploy.sh
@@ -5,12 +5,9 @@ vers=`egrep '^version:' ../build.properties | awk '{print $2}'`
 echo "Deploying ${vers}"
 
 pom=maven-pom.xml
-jsjar=../buildGradle/libs/rhino-${vers}.jar
-echo "Installing ${jsjar}"
-srczip=../buildGradle/libs/rhino-${vers}-sources.jar
-echo "Sources are ${srczip}"
-doczip=../buildGradle/libs/rhino-${vers}-javadoc.jar
-echo "Javadoc is ${doczip}"
+jsjar=../build/rhino${vers}/js.jar
+srczip=../rhino${vers}-sources.zip
+doczip=../build/rhino${vers}/javadoc.zip
 
 if [ ! -f $jsjar ]
 then
@@ -20,7 +17,7 @@ fi
 
 if [ ! -f $srczip ]
 then
-  echo "Missing rhino-${vers}-sources.zip. Run \"ant source-zip\"."
+  echo "Missing rhino${vers}-sources.zip. Run \"ant source-zip\"."
   exit 2
 fi
 
diff --git a/release-steps.txt b/release-steps.txt
deleted file mode 100644
index bc07ac3..0000000
--- a/release-steps.txt
+++ /dev/null
@@ -1,37 +0,0 @@
-Update version in:
-	src/manifest
-	build.properties
-	gradle.properties
-	maven/maven-pom.xml
-
-Paste release notes into RELEASE_NOTES.md:
-	git shortlog LAST_TAG.. | sed 's/^ /*/'
-
-Paste release info into README.md
-	Copy README into gh-pages
-	Extract build/*/javadoc.zip to gh-pages/javadoc
-
-Re-run compat-table "engine.js"
-	Copy HTML to gh-pages/compat
-
-./gradlew publishToMavenLocal distZip 
-cd maven
-./maven-staging-deploy.sh
-
-Go to oss.sonatype.org
-	Find "org.mozilla" staging repo, close, release, and drop.
-
-git tag for new release
-
-Update release in GitHub
-	Paste release notes, upload "rhinoXXX.zip" and "js.jar"
-
-Update to new snapshot version in:
-	src/manifest
-	build.properties
-	gradle.properties
-	maven/maven-pom.xml
-
-Update the Homebrew formula. Submit a PR for:
-	Homebrew/homebrew
-		Library/Formula/rhino.rb
diff --git a/src/manifest b/src/manifest
index 8c5cbdc..ff75131 100644
--- a/src/manifest
+++ b/src/manifest
@@ -1,6 +1,6 @@
 Manifest-Version: 1.0
 Main-Class: org.mozilla.javascript.tools.shell.Main
-Implementation-Version: 1.7.8-SNAPSHOT
-Implementation-Title: Mozilla Rhino 1.7.8
+Implementation-Version: 1.7.7-SNAPSHOT
+Implementation-Title: Mozilla Rhino 1.7.7
 Implementation-Vendor: Mozilla Foundation
 Implementation-URL: http://www.mozilla.org/rhino
diff --git a/src/org/mozilla/javascript/Arguments.java b/src/org/mozilla/javascript/Arguments.java
index 5d89e3b..e58eeb1 100644
--- a/src/org/mozilla/javascript/Arguments.java
+++ b/src/org/mozilla/javascript/Arguments.java
@@ -14,7 +14,7 @@ package org.mozilla.javascript;
  * @see org.mozilla.javascript.NativeCall
  * @author Norris Boyd
  */
-final class Arguments extends IdScriptableObject
+class Arguments extends IdScriptableObject
 {
     static final long serialVersionUID = 4275508002492040609L;
 
@@ -42,13 +42,28 @@ final class Arguments extends IdScriptableObject
         } else {
             callerObj = NOT_FOUND;
         }
-
-        defineProperty(NativeSymbol.ITERATOR_PROPERTY, iteratorMethod, ScriptableObject.DONTENUM);
     }
 
+    public Arguments(final Arguments original) {
+        this.activation = original.activation;
+
+        setParentScope(original.getParentScope());
+        setPrototype(original.getPrototype());
+
+        args = original.args;
+        lengthObj = original.lengthObj;
+        calleeObj = original.calleeObj;
+
+        callerObj = original.callerObj;
+    }
+    
+    
     @Override
     public String getClassName()
     {
+        if (Context.getContext().hasFeature(Context.FEATURE_HTMLUNIT_ARGUMENTS_IS_OBJECT)) {
+            return "Object";
+        }
         return FTAG;
     }
 
@@ -74,7 +89,7 @@ final class Arguments extends IdScriptableObject
         putIntoActivation(index, value);
       }
       synchronized (this) {
-        if (args == activation.originalArgs) {
+        if (activation != null && args == activation.originalArgs) {
           args = args.clone();
         }
         args[index] = value;
@@ -120,10 +135,6 @@ final class Arguments extends IdScriptableObject
 
     private boolean sharedWithActivation(int index)
     {
-        Context cx = Context.getContext();
-        if (cx.isStrictMode()) {
-            return false;
-        }
         NativeFunction f = activation.function;
         int definedCount = f.getParamCount();
         if (index < definedCount) {
@@ -153,12 +164,6 @@ final class Arguments extends IdScriptableObject
     }
 
     @Override
-    public void put(String name, Scriptable start, Object value)
-    {
-        super.put(name, start, value);
-    }
-
-    @Override
     public void delete(int index)
     {
         if (0 <= index && index < args.length) {
@@ -199,13 +204,6 @@ final class Arguments extends IdScriptableObject
             break L0;
         }
 // #/generated#
-        Context cx = Context.getContext();
-        if (cx.isStrictMode()) {
-            if (id == Id_callee || id == Id_caller) {
-                return super.findInstanceIdInfo(s);
-            }
-        }
-
 
         if (id == 0) return super.findInstanceIdInfo(s);
 
@@ -380,50 +378,9 @@ final class Arguments extends IdScriptableObject
       }
     }
 
-    // ECMAScript2015
-    // 9.4.4.6 CreateUnmappedArgumentsObject(argumentsList)
-    //   8. Perform DefinePropertyOrThrow(obj, "caller", PropertyDescriptor {[[Get]]: %ThrowTypeError%,
-    //      [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false}).
-    //   9. Perform DefinePropertyOrThrow(obj, "callee", PropertyDescriptor {[[Get]]: %ThrowTypeError%,
-    //      [[Set]]: %ThrowTypeError%, [[Enumerable]]: false, [[Configurable]]: false}).
-    void defineAttributesForStrictMode() {
-        Context cx = Context.getContext();
-        if (!cx.isStrictMode()) {
-            return;
-        }
-        setGetterOrSetter("caller", 0, new ThrowTypeError("caller"), true);
-        setGetterOrSetter("caller", 0, new ThrowTypeError("caller"), false);
-        setGetterOrSetter("callee", 0, new ThrowTypeError("callee"), true);
-        setGetterOrSetter("callee", 0, new ThrowTypeError("callee"), false);
-        setAttributes("caller", DONTENUM | PERMANENT);
-        setAttributes("callee", DONTENUM | PERMANENT);
-        callerObj = null;
-        calleeObj = null;
-    }
-
-    private static BaseFunction iteratorMethod = new BaseFunction() {
-        @Override
-        public Object call(Context cx, Scriptable scope, Scriptable thisObj,
-                           Object[] args) {
-            // TODO : call %ArrayProto_values%
-            // 9.4.4.6 CreateUnmappedArgumentsObject(argumentsList)
-            //  1. Perform DefinePropertyOrThrow(obj, @@iterator, PropertyDescriptor {[[Value]]:%ArrayProto_values%,
-            //     [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}).
-            return new NativeArrayIterator(scope, thisObj);
-        }
-    };
-
-    private static class ThrowTypeError extends BaseFunction {
-        private String propertyName;
-
-        ThrowTypeError(String propertyName) {
-            this.propertyName = propertyName;
-        }
-
-        @Override
-        public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
-            throw ScriptRuntime.typeError1("msg.arguments.not.access.strict", propertyName);
-        }
+    @Override
+    public Object getDefaultValue(Class<?> typeHint) {
+        return "[object " + getClassName() + "]";
     }
 
 // Fields to hold caller, callee and length properties,
diff --git a/src/org/mozilla/javascript/ArrowFunction.java b/src/org/mozilla/javascript/ArrowFunction.java
deleted file mode 100644
index e7a968c..0000000
--- a/src/org/mozilla/javascript/ArrowFunction.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript;
-
-/**
- * The class for  Arrow Function Definitions
- * EcmaScript 6 Rev 14, March 8, 2013 Draft spec , 13.2
- */
-public class ArrowFunction extends BaseFunction {
-    
-    static final long serialVersionUID = -7377989503697220633L;
-    
-    private final Callable targetFunction;
-    private final Scriptable boundThis;
-
-    public ArrowFunction(Context cx, Scriptable scope, Callable targetFunction, Scriptable boundThis)
-    {
-        this.targetFunction = targetFunction;
-        this.boundThis = boundThis;
-
-        ScriptRuntime.setFunctionProtoAndParent(this, scope);
-
-        Function thrower = ScriptRuntime.typeErrorThrower();
-        NativeObject throwing = new NativeObject();
-        throwing.put("get", throwing, thrower);
-        throwing.put("set", throwing, thrower);
-        throwing.put("enumerable", throwing, false);
-        throwing.put("configurable", throwing, false);
-        throwing.preventExtensions();
-
-        this.defineOwnProperty(cx, "caller", throwing, false);
-        this.defineOwnProperty(cx, "arguments", throwing, false);
-    }
-
-    @Override
-    public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args)
-    {
-        Scriptable callThis = boundThis != null ? boundThis : ScriptRuntime.getTopCallScope(cx);
-        return targetFunction.call(cx, scope, callThis, args);
-    }
-
-    @Override
-    public Scriptable construct(Context cx, Scriptable scope, Object[] args) {
-        throw ScriptRuntime.typeError1("msg.not.ctor", decompile(0, 0));
-    }
-
-    @Override
-    public boolean hasInstance(Scriptable instance) {
-        if (targetFunction instanceof Function) {
-            return ((Function) targetFunction).hasInstance(instance);
-        }
-        throw ScriptRuntime.typeError0("msg.not.ctor");
-    }
-
-    @Override
-    public int getLength() {
-        if (targetFunction instanceof BaseFunction) {
-            return ((BaseFunction) targetFunction).getLength();
-        }
-        return 0;
-    }
-
-    @Override
-    String decompile(int indent, int flags)
-    {
-        if (targetFunction instanceof BaseFunction) {
-            return ((BaseFunction)targetFunction).decompile(indent, flags);
-        }
-        return super.decompile(indent, flags);
-    }
-}
diff --git a/src/org/mozilla/javascript/BaseFunction.java b/src/org/mozilla/javascript/BaseFunction.java
index f08c7b6..221e79a 100644
--- a/src/org/mozilla/javascript/BaseFunction.java
+++ b/src/org/mozilla/javascript/BaseFunction.java
@@ -419,13 +419,11 @@ public class BaseFunction extends IdScriptableObject implements Function
         if (!justbody) {
             sb.append("function ");
             sb.append(getFunctionName());
-            sb.append("() {\n\t");
+            sb.append("() {\n    ");
         }
-        sb.append("[native code, arity=");
-        sb.append(getArity());
-        sb.append("]\n");
+        sb.append("[native code]\n");
         if (!justbody) {
-            sb.append("}\n");
+            sb.append("}");
         }
         return sb.toString();
     }
diff --git a/src/org/mozilla/javascript/CodeGenerator.java b/src/org/mozilla/javascript/CodeGenerator.java
index 423bc38..55b0f3c 100644
--- a/src/org/mozilla/javascript/CodeGenerator.java
+++ b/src/org/mozilla/javascript/CodeGenerator.java
@@ -10,6 +10,7 @@ import org.mozilla.javascript.ast.AstRoot;
 import org.mozilla.javascript.ast.ScriptNode;
 import org.mozilla.javascript.ast.Jump;
 import org.mozilla.javascript.ast.FunctionNode;
+import org.mozilla.javascript.ast.VariableInitializer;
 
 /**
  * Generates bytecode for the Interpreter.
@@ -71,11 +72,10 @@ class CodeGenerator extends Icode {
         } else {
             scriptOrFn = tree;
         }
-
         itsData = new InterpreterData(compilerEnv.getLanguageVersion(),
                                       scriptOrFn.getSourceName(),
                                       encodedSource,
-                                      scriptOrFn.isInStrictMode());
+                                      ((AstRoot)tree).isInStrictMode());
         itsData.topLevel = true;
 
         if (returnFunction) {
@@ -101,9 +101,7 @@ class CodeGenerator extends Icode {
           addIcode(Icode_GENERATOR);
           addUint16(theFunction.getBaseLineno() & 0xFFFF);
         }
-        if (theFunction.isInStrictMode()) {
-            itsData.isStrict = true;
-        }
+        itsData.declaredAsVar = (theFunction.getParent() instanceof VariableInitializer);
 
         generateICodeFromTree(theFunction.getLastChild());
     }
@@ -479,7 +477,6 @@ class CodeGenerator extends Icode {
           case Token.ENUM_INIT_KEYS:
           case Token.ENUM_INIT_VALUES:
           case Token.ENUM_INIT_ARRAY:
-          case Token.ENUM_INIT_VALUES_IN_ORDER:
             visitExpression(child, 0);
             addIndexOp(type, getLocalBlockRef(node));
             stackChange(-1);
@@ -509,8 +506,7 @@ class CodeGenerator extends Icode {
                 int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);
                 FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);
                 // See comments in visitStatement for Token.FUNCTION case
-                if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION &&
-                    fn.getFunctionType() != FunctionNode.ARROW_FUNCTION) {
+                if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {
                     throw Kit.codeBug();
                 }
                 addIndexOp(Icode_CLOSURE_EXPR, fnIndex);
@@ -1092,9 +1088,6 @@ class CodeGenerator extends Icode {
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Arguments.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/BaseFunction.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/CodeGenerator.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ConsString.java.
The file will have its original line endings in your working directory.
             } else if (childType == Token.SET) {
                 visitExpression(child.getFirstChild(), 0);
                 addIcode(Icode_LITERAL_SETTER);
-            } else if (childType == Token.METHOD) {
-                visitExpression(child.getFirstChild(), 0);
-                addIcode(Icode_LITERAL_SET);
             } else {
                 visitExpression(child, 0);
                 addIcode(Icode_LITERAL_SET);
diff --git a/src/org/mozilla/javascript/ConsString.java b/src/org/mozilla/javascript/ConsString.java
index 62cd9a8..11c10b7 100644
--- a/src/org/mozilla/javascript/ConsString.java
+++ b/src/org/mozilla/javascript/ConsString.java
@@ -7,7 +7,6 @@
 package org.mozilla.javascript;
 
 import java.io.Serializable;
-import java.util.ArrayList;
 
 /**
  * <p>This class represents a string composed of two components, each of which
@@ -44,6 +43,10 @@ public class ConsString implements CharSequence, Serializable {
         if (str2 instanceof ConsString) {
             depth += ((ConsString)str2).depth;
         }
+        // Don't let it grow too deep, can cause stack overflows
+        if (depth > 2000) {
+            flatten();
+        }
     }
 
     // Replace with string representation when serializing
@@ -59,19 +62,7 @@ public class ConsString implements CharSequence, Serializable {
     private synchronized String flatten() {
         if (depth > 0) {
             StringBuilder b = new StringBuilder(length);
-            ArrayList<CharSequence> buffer = new ArrayList<CharSequence>();
-            buffer.add(s2);
-            buffer.add(s1);
-            while(!buffer.isEmpty()) {
-                CharSequence next = buffer.remove(buffer.size() - 1);
-                if (next instanceof ConsString) {
-                    ConsString casted = (ConsString) next;
-                    buffer.add(casted.s2);
-                    buffer.add(casted.s1);
-                } else {
-                    b.append(next);
-                }
-            }
+            appendTo(b);
             s1 = b.toString();
             s2 = "";
             depth = 0;
@@ -79,6 +70,19 @@ public class ConsString implements CharSequence, Serializable {
         return (String)s1;
     }
 
+    private synchronized void appendTo(StringBuilder b) {
+        appendFragment(s1, b);
+        appendFragment(s2, b);
+    }
+
+    private static void appendFragment(CharSequence s, StringBuilder b) {
+        if (s instanceof ConsString) {
+            ((ConsString)s).appendTo(b);
+        } else {
+            b.append(s);
+        }
+    }
+
     public int length() {
         return length;
     }
diff --git a/src/org/mozilla/javascript/Context.java b/src/org/mozilla/javascript/Context.java
index 85bdaa8..902b5d8 100644
--- a/src/org/mozilla/javascript/Context.java
+++ b/src/org/mozilla/javascript/Context.java
@@ -112,11 +112,6 @@ public class Context
     public static final int VERSION_1_8 =      180;
 
     /**
-     * ECMAScript 6.
-     */
-    public static final int VERSION_ES6 =      200;
-
-    /**
      * Controls behaviour of <tt>Date.prototype.getYear()</tt>.
      * If <tt>hasFeature(FEATURE_NON_ECMA_GET_YEAR)</tt> returns true,
      * Date.prototype.getYear subtructs 1900 only if 1900 <= date < 2000.
@@ -293,20 +288,121 @@ public class Context
     public static final int FEATURE_V8_EXTENSIONS = 14;
 
     /**
-     * Defines how an undefined  "this" parameter is handled in certain calls. Previously Rhino
-     * would convert an undefined "this" to null, whereas recent specs call for it to be treated
-     * differently. Default is to be set if language version <= 1.7.
-     * @since 1.7.7
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * The same web browser (e.g. FF) may allow setting read-only property, 
+     * ignores setting the read-only property, or even throw an exception.
+     *
+     * So, by having this feature, ScriptableObject itself is asked throw
+     * {@link ScriptableObject#isReadOnlySettable} whether to allow, ignore or throw an exception.
+     *
+     * By default {@link #hasFeature(int)} returns false.
      */
-    public static final int FEATURE_OLD_UNDEF_NULL_THIS = 15;
+    public static final int FEATURE_HTMLUNIT_ASK_OBJECT_TO_WRITE_READONLY = 100;
 
     /**
-     * If set, then the order of property key enumeration will be first numeric keys in numeric order,
-     * followed by string keys in order of creation, and finally Symbol keys, as specified in ES6.
-     * Default is true for language version >= "ES6" and false otherwise.
-     * @since 1.7.8
+     * Special to HtmlUnit's Rhino fork.
+     * Indicates if a JavaScript catch statement can catch Java exceptions
+     * (exceptions occurring in host objects).
+     * By default {@link #hasFeature(int)} returns true.
      */
-    public static final int FEATURE_ENUMERATE_IDS_FIRST = 16;
+    public static final int FEATURE_HTMLUNIT_JS_CATCH_JAVA_EXCEPTION = 101;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Is the default value of {@link Arguments} "Object" or "Arguments"
+     *
+     * By default {@link #hasFeature(int)} returns false.
+     */
+    public static final int FEATURE_HTMLUNIT_ARGUMENTS_IS_OBJECT = 102;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * When setting the function name to call, call thisObject.setter.
+     *
+     * This is needed for something like "function onclick() {onclick = null}"
+     *
+     * Implemented by transforming it into "function onclick() {<b>this.</b>onclick = null}"
+     *
+     * By default {@link #hasFeature(int)} returns false.
+     */
+    public static final int FEATURE_HTMLUNIT_FUNCTION_NULL_SETTER = 103;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Whether the "someFunc.arguments" is a read-only view of the function argument
+     * or the real arguments.
+     *
+     * By default {@link #hasFeature(int)} returns false.
+     */
+    public static final int FEATURE_HTMLUNIT_FN_ARGUMENTS_IS_RO_VIEW = 104;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that 'eval' function should have access to the local function scope.
+     *
+     * By default {@link #hasFeature(int)} returns true.
+     */
+    public static final int FEATURE_HTMLUNIT_EVAL_LOCAL_SCOPE = 105;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that 'exception' (technically NativeError) exposes "stack" property.
+     *
+     * By default {@link #hasFeature(int)} returns true.
+     */
+    public static final int FEATURE_HTMLUNIT_ERROR_STACK = 106;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that ".constructor" property is defined for all {@link ScriptableObject}s.
+     *
+     * By default {@link #hasFeature(int)} returns true.
+     */
+    public static final int FEATURE_HTMLUNIT_CONSTRUCTOR = 107;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that function can be defined as
+     * <code>function object.property() {}</code> instead of <code>object.property = function() {}</code>.
+     *
+     * By default {@link #hasFeature(int)} returns false.
+     */
+    public static final int FEATURE_HTMLUNIT_FUNCTION_OBJECT_METHOD = 108;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that function is defined even before its declaration, inside a block.
+     *
+     * By default {@link #hasFeature(int)} returns false.
+     */
+    public static final int FEATURE_HTMLUNIT_FUNCTION_DECLARED_FORWARD_IN_BLOCK = 109;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that parseInt() should have radix 10 by default.
+     *
+     * By default {@link #hasFeature(int)} returns true.
+     */
+    public static final int FEATURE_HTMLUNIT_PARSE_INT_RADIX_10 = 110;
+
+    /**
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Indicates that for(x in []) should enumerate the numbers first.
+     *
+     * By default {@link #hasFeature(int)} returns false.
+     */
+    public static final int FEATURE_HTMLUNIT_ENUM_NUMBERS_FIRST = 111;
 
     public static final String languageVersionProperty = "language version";
     public static final String errorReporterProperty   = "error reporter";
@@ -672,7 +768,6 @@ public class Context
             case VERSION_1_6:
             case VERSION_1_7:
             case VERSION_1_8:
-            case VERSION_ES6:
                 return true;
         }
         return false;
@@ -1325,7 +1420,7 @@ public class Context
         // Annotate so we can check later to ensure no java code in
         // intervening frames
         isContinuationsTopCall = true;
-        return ScriptRuntime.doTopCall(function, this, scope, scope, args, isTopLevelStrict);
+        return ScriptRuntime.doTopCall(function, this, scope, scope, args);
     }
 
     /**
@@ -1482,7 +1577,7 @@ public class Context
                              securityDomain);
     }
 
-    final Script compileString(String source,
+    protected Script compileString(String source,
                                Evaluator compiler,
                                ErrorReporter compilationErrorReporter,
                                String sourceName, int lineno,
@@ -1523,7 +1618,7 @@ public class Context
                                securityDomain);
     }
 
-    final Function compileFunction(Scriptable scope, String source,
+    protected Function compileFunction(Scriptable scope, String source,
                                    Evaluator compiler,
                                    ErrorReporter compilationErrorReporter,
                                    String sourceName, int lineno,
@@ -2499,9 +2594,6 @@ public class Context
         if (returnFunction) {
             p.calledByCompileFunction = true;
         }
-        if (isStrictMode()) {
-            p.setDefaultUseStrictDirective(true);
-        }
         AstRoot ast;
         if (sourceString != null) {
             ast = p.parse(sourceString, sourceName, lineno);
@@ -2688,10 +2780,6 @@ public class Context
             activationNames.remove(name);
     }
 
-    public final boolean isStrictMode() {
-        return isTopLevelStrict || (currentActivationCall != null && currentActivationCall.isStrict);
-    }
-
     private static String implementationVersion;
 
     private final ContextFactory factory;
@@ -2761,6 +2849,4 @@ public class Context
 
     // Generate an observer count on compiled code
     public boolean generateObserverCount = false;
-
-    boolean isTopLevelStrict;
 }
diff --git a/src/org/mozilla/javascript/ContextFactory.java b/src/org/mozilla/javascript/ContextFactory.java
index ba607a3..db87a62 100644
--- a/src/org/mozilla/javascript/ContextFactory.java
+++ b/src/org/mozilla/javascript/ContextFactory.java
@@ -283,11 +283,41 @@ public class ContextFactory
           case Context.FEATURE_V8_EXTENSIONS:
             return true;
 
-          case Context.FEATURE_OLD_UNDEF_NULL_THIS:
-              return cx.getLanguageVersion() <= Context.VERSION_1_7;
+          case Context.FEATURE_HTMLUNIT_JS_CATCH_JAVA_EXCEPTION:
+            return true;
 
-          case Context.FEATURE_ENUMERATE_IDS_FIRST:
-              return cx.getLanguageVersion() >= Context.VERSION_ES6;
+          case Context.FEATURE_HTMLUNIT_ASK_OBJECT_TO_WRITE_READONLY:
+            return false;
+
+          case Context.FEATURE_HTMLUNIT_ARGUMENTS_IS_OBJECT:
+            return false;
+
+          case Context.FEATURE_HTMLUNIT_FUNCTION_NULL_SETTER:
+            return false;
+
+          case Context.FEATURE_HTMLUNIT_FN_ARGUMENTS_IS_RO_VIEW:
+            return false;
+
+          case Context.FEATURE_HTMLUNIT_EVAL_LOCAL_SCOPE:
+            return true;
+
+          case Context.FEATURE_HTMLUNIT_ERROR_STACK:
+            return true;
+
+          case Context.FEATURE_HTMLUNIT_CONSTRUCTOR:
+            return true;
+
+          case Context.FEATURE_HTMLUNIT_FUNCTION_OBJECT_METHOD:
+            return false;
+
+          case Context.FEATURE_HTMLUNIT_FUNCTION_DECLARED_FORWARD_IN_BLOCK:
+            return false;
+
+          case Context.FEATURE_HTMLUNIT_PARSE_INT_RADIX_10:
+            return true;
+
+          case Context.FEATURE_HTMLUNIT_ENUM_NUMBERS_FIRST:
+              return false;
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Context.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ContextFactory.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ContinuationPending.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Decompiler.java.
The file will have its original line endings in your working directory.
         }
         // It is a bug to call the method with unknown featureIndex
         throw new IllegalArgumentException(String.valueOf(featureIndex));
@@ -591,4 +621,4 @@ public class ContextFactory
     {
         return Context.enter(cx, this);
     }
-}
\ No newline at end of file
+}
diff --git a/src/org/mozilla/javascript/ContinuationPending.java b/src/org/mozilla/javascript/ContinuationPending.java
index 72d488d..d0da59d 100644
--- a/src/org/mozilla/javascript/ContinuationPending.java
+++ b/src/org/mozilla/javascript/ContinuationPending.java
@@ -26,10 +26,9 @@ public class ContinuationPending extends RuntimeException {
      * users of the API should get continuations created on their behalf by
      * calling {@link org.mozilla.javascript.Context#executeScriptWithContinuations(Script, Scriptable)}
      * and {@link org.mozilla.javascript.Context#callFunctionWithContinuations(Callable, Scriptable, Object[])}
-     * Creating subclasses allowed.
      * @param continuationState Internal Continuation object
      */
-    protected ContinuationPending(NativeContinuation continuationState) {
+    ContinuationPending(NativeContinuation continuationState) {
         this.continuationState = continuationState;
     }
 
@@ -44,14 +43,6 @@ public class ContinuationPending extends RuntimeException {
     }
 
     /**
-     * Set continuation object. Allows subclasses to modify the internal state.
-     * @param continuation object
-     */
-    public void setContinuation(NativeContinuation continuation) {
-        this.continuationState = continuation;
-    }
-    
-    /**
      * @return internal continuation state
      */
     NativeContinuation getContinuationState() {
diff --git a/src/org/mozilla/javascript/Decompiler.java b/src/org/mozilla/javascript/Decompiler.java
index 28fd044..8cd849b 100644
--- a/src/org/mozilla/javascript/Decompiler.java
+++ b/src/org/mozilla/javascript/Decompiler.java
@@ -86,10 +86,8 @@ public class Decompiler
     int markFunctionStart(int functionType)
     {
         int savedOffset = getCurrentOffset();
-        if (functionType != FunctionNode.ARROW_FUNCTION) {
-            addToken(Token.FUNCTION);
-            append((char)functionType);
-        }
+        addToken(Token.FUNCTION);
+        append((char)functionType);
         return savedOffset;
     }
 
@@ -311,8 +309,6 @@ public class Decompiler
         }
 
         if (!toSource) {
-            // add an initial newline to exactly match js.
-            result.append('\n');
             for (int j = 0; j < indent; j++)
                 result.append(' ');
         } else {
@@ -325,12 +321,7 @@ public class Decompiler
             switch(source.charAt(i)) {
             case Token.GET:
             case Token.SET:
-            case Token.METHOD:
-                if (source.charAt(i) == Token.GET) {
-                    result.append("get ");
-                } else if (source.charAt(i) == Token.SET) {
-                    result.append("set ");
-                }
+                result.append(source.charAt(i) == Token.GET ? "get " : "set ");
                 ++i;
                 i = printSourceString(source, i + 1, false, result);
                 // Now increment one more to get past the FUNCTION token
@@ -794,10 +785,6 @@ public class Decompiler
                 result.append("debugger;\n");
                 break;
 
-            case Token.ARROW:
-                result.append(" => ");
-                break;
-
             default:
                 // If we don't know how to decompile it, raise an exception.
                 throw new RuntimeException("Token: " +
@@ -806,11 +793,7 @@ public class Decompiler
             ++i;
         }
 
-        if (!toSource) {
-            // add that trailing newline if it's an outermost function.
-            if (!justFunctionBody)
-                result.append('\n');
-        } else {
+        if (toSource) {
             if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {
                 result.append(')');
             }
diff --git a/src/org/mozilla/javascript/Delegator.java b/src/org/mozilla/javascript/Delegator.java
index 8e8bac4..e273d0f 100644
--- a/src/org/mozilla/javascript/Delegator.java
+++ b/src/org/mozilla/javascript/Delegator.java
@@ -85,85 +85,85 @@ public class Delegator implements Function {
      * @see org.mozilla.javascript.Scriptable#getClassName
      */
     public String getClassName() {
-        return obj.getClassName();
+        return getDelegee().getClassName();
     }
     /**
      * @see org.mozilla.javascript.Scriptable#get(String, Scriptable)
      */
     public Object get(String name, Scriptable start) {
-        return obj.get(name,start);
+        return getDelegee().get(name,start);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#get(int, Scriptable)
      */
     public Object get(int index, Scriptable start) {
-        return obj.get(index,start);
+        return getDelegee().get(index,start);
         }
     /**
      * @see org.mozilla.javascript.Scriptable#has(String, Scriptable)
      */
     public boolean has(String name, Scriptable start) {
-        return obj.has(name,start);
+        return getDelegee().has(name,start);
         }
     /**
      * @see org.mozilla.javascript.Scriptable#has(int, Scriptable)
      */
     public boolean has(int index, Scriptable start) {
-        return obj.has(index,start);
+        return getDelegee().has(index,start);
         }
     /**
      * @see org.mozilla.javascript.Scriptable#put(String, Scriptable, Object)
      */
     public void put(String name, Scriptable start, Object value) {
-        obj.put(name,start,value);
+        getDelegee().put(name,start,value);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#put(int, Scriptable, Object)
      */
     public void put(int index, Scriptable start, Object value) {
-        obj.put(index,start,value);
+        getDelegee().put(index,start,value);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#delete(String)
      */
     public void delete(String name) {
-        obj.delete(name);
+        getDelegee().delete(name);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#delete(int)
      */
     public void delete(int index) {
-        obj.delete(index);
+        getDelegee().delete(index);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#getPrototype
      */
     public Scriptable getPrototype() {
-        return obj.getPrototype();
+        return getDelegee().getPrototype();
     }
     /**
      * @see org.mozilla.javascript.Scriptable#setPrototype
      */
     public void setPrototype(Scriptable prototype) {
-        obj.setPrototype(prototype);
+        getDelegee().setPrototype(prototype);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#getParentScope
      */
     public Scriptable getParentScope() {
-        return obj.getParentScope();
+        return getDelegee().getParentScope();
     }
     /**
      * @see org.mozilla.javascript.Scriptable#setParentScope
      */
     public void setParentScope(Scriptable parent) {
-        obj.setParentScope(parent);
+        getDelegee().setParentScope(parent);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#getIds
      */
     public Object[] getIds() {
-        return obj.getIds();
+        return getDelegee().getIds();
     }
     /**
      * Note that this method does not get forwarded to the delegee if
@@ -181,13 +181,13 @@ public class Delegator implements Function {
         return (hint == null ||
                 hint == ScriptRuntime.ScriptableClass ||
                 hint == ScriptRuntime.FunctionClass) ?
-            this : obj.getDefaultValue(hint);
+            this : getDelegee().getDefaultValue(hint);
     }
     /**
      * @see org.mozilla.javascript.Scriptable#hasInstance
      */
     public boolean hasInstance(Scriptable instance) {
-        return obj.hasInstance(instance);
+        return getDelegee().hasInstance(instance);
     }
     /**
      * @see org.mozilla.javascript.Function#call
@@ -195,7 +195,7 @@ public class Delegator implements Function {
     public Object call(Context cx, Scriptable scope, Scriptable thisObj,
                        Object[] args)
     {
-        return ((Function)obj).call(cx,scope,thisObj,args);
+        return ((Function)getDelegee()).call(cx,scope,thisObj,args);
     }
 
     /**
@@ -215,7 +215,7 @@ public class Delegator implements Function {
      */
     public Scriptable construct(Context cx, Scriptable scope, Object[] args)
     {
-        if (obj == null) {
+        if (getDelegee() == null) {
             //this little trick allows us to declare prototype objects for
             //Delegators
             Delegator n = newInstance();
@@ -229,7 +229,7 @@ public class Delegator implements Function {
             return n;
         }
         else {
-            return ((Function)obj).construct(cx,scope,args);
+            return ((Function)getDelegee()).construct(cx,scope,args);
         }
     }
 }
diff --git a/src/org/mozilla/javascript/ES6Iterator.java b/src/org/mozilla/javascript/ES6Iterator.java
deleted file mode 100644
index 1a7958a..0000000
--- a/src/org/mozilla/javascript/ES6Iterator.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript;
-
-import static org.mozilla.javascript.NativeSymbol.ITERATOR_PROPERTY;
-import static org.mozilla.javascript.NativeSymbol.TO_STRING_TAG_PROPERTY;
-
-public abstract class ES6Iterator extends IdScriptableObject {
-
-    static void init(ScriptableObject scope, boolean sealed, IdScriptableObject prototype, String tag) {
-        if (scope != null) {
-            prototype.setParentScope(scope);
-            prototype.setPrototype(getObjectPrototype(scope));
-        }
-        prototype.activatePrototypeMap(MAX_PROTOTYPE_ID);
-        if (sealed) {
-            prototype.sealObject();
-        }
-
-        // Need to access Iterator prototype when constructing
-        // Iterator instances, but don't have a iterator constructor
-        // to use to find the prototype. Use the "associateValue"
-        // approach instead.
-        if (scope != null) {
-            scope.associateValue(tag, prototype);
-        }
-    }
-
-    protected boolean exhausted = false;
-
-    ES6Iterator() {}
-
-    ES6Iterator(Scriptable scope) {
-        // Set parent and prototype properties. Since we don't have a
-        // "Iterator" constructor in the top scope, we stash the
-        // prototype in the top scope's associated value.
-        Scriptable top = ScriptableObject.getTopLevelScope(scope);
-        this.setParentScope(top);
-        IdScriptableObject prototype = (IdScriptableObject)
-            ScriptableObject.getTopScopeValue(top, getTag());
-        setPrototype(prototype);
-    }
-
-    @Override
-    protected void initPrototypeId(int id)
-    {
-        switch (id) {
-            case Id_next:
-                initPrototypeMethod(getTag(), id, NEXT_METHOD, 0);
-                return;
-            case Id_iterator:
-                initPrototypeMethod(getTag(), id, ITERATOR_PROPERTY, "[Symbol.iterator]", 0);
-                return;
-            case Id_toStringTag:
-                initPrototypeValue(Id_toStringTag, TO_STRING_TAG_PROPERTY, getClassName(), DONTENUM | READONLY);
-                return;
-            default: throw new IllegalArgumentException(String.valueOf(id));
-        }
-    }
-
-    @Override
-    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope,
-                             Scriptable thisObj, Object[] args)
-    {
-        if (!f.hasTag(getTag())) {
-            return super.execIdCall(f, cx, scope, thisObj, args);
-        }
-        int id = f.methodId();
-
-        if (!(thisObj instanceof ES6Iterator))
-            throw incompatibleCallError(f);
-
-        ES6Iterator iterator = (ES6Iterator) thisObj;
-
-        switch (id) {
-        case Id_next:
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Delegator.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/FunctionObject.java.
The file will have its original line endings in your working directory.
-            return iterator.next(cx, scope);
-        case Id_iterator:
-            return iterator;
-        default:
-            throw new IllegalArgumentException(String.valueOf(id));
-        }
-    }
-
-    @Override
-    protected int findPrototypeId(String s) {
-        if (s.charAt(0) == 'n') {
-            return Id_next;
-        } else if (ITERATOR_PROPERTY.equals(s)) {
-            return Id_iterator;
-        } else if (TO_STRING_TAG_PROPERTY.equals(s)) {
-            return Id_toStringTag;
-        }
-        return 0;
-    }
-
-    abstract protected boolean isDone(Context cx, Scriptable scope);
-
-    abstract protected Object nextValue(Context cx, Scriptable scope);
-
-    protected Object next(Context cx, Scriptable scope) {
-        Object value = Undefined.instance;
-        boolean done = isDone(cx, scope) || this.exhausted;
-        if (!done) {
-            value = nextValue(cx, scope);
-        } else {
-            this.exhausted = true;
-        }
-        return makeIteratorResult(cx, scope, done, value);
-    }
-
-    abstract protected String getTag();
-
-    // 25.1.1.3 The IteratorResult Interface
-    private Scriptable makeIteratorResult(Context cx, Scriptable scope, boolean done, Object value) {
-        Scriptable iteratorResult = cx.newObject(scope);
-        ScriptableObject.putProperty(iteratorResult, VALUE_PROPERTY, value);
-        ScriptableObject.putProperty(iteratorResult, DONE_PROPERTY, done);
-        return iteratorResult;
-    }
-
-    private static final int
-        Id_next             = 1,
-        Id_iterator         = 2,
-        Id_toStringTag      = 3,
-        MAX_PROTOTYPE_ID    = Id_toStringTag;
-
-    public static final String NEXT_METHOD = "next";
-    public static final String DONE_PROPERTY = "done";
-    public static final String VALUE_PROPERTY = "value";
-}
diff --git a/src/org/mozilla/javascript/FunctionObject.java b/src/org/mozilla/javascript/FunctionObject.java
index 1d396a6..4df9cc3 100644
--- a/src/org/mozilla/javascript/FunctionObject.java
+++ b/src/org/mozilla/javascript/FunctionObject.java
@@ -398,6 +398,9 @@ public class FunctionObject extends BaseFunction
         } else {
             if (!isStatic) {
                 Class<?> clazz = member.getDeclaringClass();
+                if (thisObj instanceof Delegator) {
+                    thisObj = ((Delegator) thisObj).getDelegee();
+                }
                 if (!clazz.isInstance(thisObj)) {
                     boolean compatible = false;
                     if (thisObj == scope) {
diff --git a/src/org/mozilla/javascript/IRFactory.java b/src/org/mozilla/javascript/IRFactory.java
index 684a549..ad24816 100644
--- a/src/org/mozilla/javascript/IRFactory.java
+++ b/src/org/mozilla/javascript/IRFactory.java
@@ -270,11 +270,7 @@ public final class IRFactory extends Parser
             defineSymbol(Token.LET, name, false);
             iterators[i] = init;
 
-            if (acl.isForOf()) {
-                decompiler.addName("of ");
-            } else {
-                decompiler.addToken(Token.IN);
-            }
+            decompiler.addToken(Token.IN);
             iteratedObjs[i] = transform(acl.getIteratedObject());
             decompiler.addToken(Token.RP);
         }
@@ -309,8 +305,7 @@ public final class IRFactory extends Parser
                                    iterators[i],
                                    iteratedObjs[i],
                                    body,
-                                   acl.isForEach(),
-                                   acl.isForOf());
+                                   acl.isForEach());
             }
         } finally {
             for (int i = 0; i < pushed; i++) {
@@ -361,6 +356,7 @@ public final class IRFactory extends Parser
 
     private Node transformAssignment(Assignment node) {
         AstNode left = removeParens(node.getLeft());
+        left = transformAssignmentLeft(node, left);
         Node target = null;
         if (isDestructuring(left)) {
             decompile(left);
@@ -374,6 +370,32 @@ public final class IRFactory extends Parser
                                 transform(node.getRight()));
     }
 
+    private AstNode transformAssignmentLeft(Assignment node, AstNode left) {
+        AstNode right = node.getRight();
+
+        if (right.getType() == Token.NULL && node.getType() == Token.ASSIGN
+                && left instanceof Name && right instanceof KeywordLiteral
+                && Context.getCurrentContext().hasFeature(Context.FEATURE_HTMLUNIT_FUNCTION_NULL_SETTER)) {
+
+            final String identifier = ((Name) left).getIdentifier();
+            for (AstNode p = node.getParent(); p != null; p = p.getParent()) {
+                if (p instanceof FunctionNode) {
+                    final Name functionName = ((FunctionNode) p).getFunctionName();
+                    if (functionName != null && functionName.getIdentifier().equals(identifier)) {
+                        final PropertyGet propertyGet = new PropertyGet();
+                        final KeywordLiteral thisKeyword = new KeywordLiteral();
+                        thisKeyword.setType(Token.THIS);
+                        propertyGet.setLeft(thisKeyword);
+                        propertyGet.setRight(left);
+                        node.setLeft(propertyGet);
+                        return propertyGet;
+                    }
+                }
+            }
+        }
+        return left;
+    }
+
     private Node transformBlock(AstNode node) {
         if (node instanceof Scope) {
             pushScope((Scope)node);
@@ -443,6 +465,16 @@ public final class IRFactory extends Parser
     }
 
     private Node transformElementGet(ElementGet node) {
+        //Ensure "function['eval']" is transformed into "function.eval"
+        if (node.getElement().type == Token.STRING
+                && "eval".equals(((StringLiteral) node.getElement()).getValue())) {
+            final PropertyGet propertyGet = new PropertyGet();
+            propertyGet.setLeft(node.getTarget());
+            final Name name = new Name();
+            name.setIdentifier("eval");
+            propertyGet.setRight(name);
+            return transform(propertyGet);
+        }
         // OPT: could optimize to createPropertyGet
         // iff elem is string that can not be number
         Node target = transform(node.getTarget());
@@ -473,18 +505,14 @@ public final class IRFactory extends Parser
                 declType = ((VariableDeclaration)iter).getType();
             }
             Node lhs = transform(iter);
-            if (loop.isForOf()) {
-                decompiler.addName("of ");
-            } else {
-                decompiler.addToken(Token.IN);
-            }
+            decompiler.addToken(Token.IN);
             Node obj = transform(loop.getIteratedObject());
             decompiler.addToken(Token.RP);
             decompiler.addEOL(Token.LC);
             Node body = transform(loop.getBody());
             decompiler.addEOL(Token.RC);
             return createForIn(declType, loop, lhs, obj, body,
-                               loop.isForEach(), loop.isForOf());
+                               loop.isForEach());
         } finally {
             popScope();
         }
@@ -680,11 +708,7 @@ public final class IRFactory extends Parser
             defineSymbol(Token.LET, name, false);
             iterators[i] = init;
 
-            if (acl.isForOf()) {
-                decompiler.addName("of ");
-            } else {
-                decompiler.addToken(Token.IN);
-            }
+            decompiler.addToken(Token.IN);
             iteratedObjs[i] = transform(acl.getIteratedObject());
             decompiler.addToken(Token.RP);
         }
@@ -716,8 +740,7 @@ public final class IRFactory extends Parser
                                    iterators[i],
                                    iteratedObjs[i],
                                    body,
-                                   acl.isForEach(),
-                                   acl.isForOf());
+                                   acl.isForEach());
             }
         } finally {
             for (int i = 0; i < pushed; i++) {
@@ -868,29 +891,25 @@ public final class IRFactory extends Parser
             int size = elems.size(), i = 0;
             properties = new Object[size];
             for (ObjectProperty prop : elems) {
-                if (prop.isGetterMethod()) {
+                if (prop.isGetter()) {
                     decompiler.addToken(Token.GET);
-                } else if (prop.isSetterMethod()) {
+                } else if (prop.isSetter()) {
                     decompiler.addToken(Token.SET);
-                } else if (prop.isNormalMethod()) {
-                    decompiler.addToken(Token.METHOD);
                 }
 
                 properties[i++] = getPropKey(prop.getLeft());
 
                 // OBJECTLIT is used as ':' in object literal for
                 // decompilation to solve spacing ambiguity.
-                if (!(prop.isMethod())) {
+                if (!(prop.isGetter() || prop.isSetter())) {
                     decompiler.addToken(Token.OBJECTLIT);
                 }
 
                 Node right = transform(prop.getRight());
-                if (prop.isGetterMethod()) {
+                if (prop.isGetter()) {
                     right = createUnary(Token.GET, right);
-                } else if (prop.isSetterMethod()) {
+                } else if (prop.isSetter()) {
                     right = createUnary(Token.SET, right);
-                } else if (prop.isNormalMethod()) {
-                    right = createUnary(Token.METHOD, right);
                 }
                 object.addChildToBack(right);
 
@@ -957,11 +976,8 @@ public final class IRFactory extends Parser
 
     private Node transformReturn(ReturnStatement node) {
         boolean expClosure = Boolean.TRUE.equals(node.getProp(Node.EXPRESSION_CLOSURE_PROP));
-        boolean isArrow = Boolean.TRUE.equals(node.getProp(Node.ARROW_FUNCTION_PROP));
         if (expClosure) {
-            if (!isArrow) {
-                decompiler.addName(" ");
-            }
+            decompiler.addName(" ");
         } else {
             decompiler.addToken(Token.RETURN);
         }
@@ -1527,7 +1543,7 @@ public final class IRFactory extends Parser
      * Generate IR for a for..in loop.
      */
     private Node createForIn(int declType, Node loop, Node lhs,
-                             Node obj, Node body, boolean isForEach, boolean isForOf)
+                             Node obj, Node body, boolean isForEach)
     {
         int destructuring = -1;
         int destructuringLen = 0;
@@ -1565,7 +1581,6 @@ public final class IRFactory extends Parser
 
         Node localBlock = new Node(Token.LOCAL_BLOCK);
         int initType = isForEach ? Token.ENUM_INIT_VALUES
-                       : isForOf ? Token.ENUM_INIT_VALUES_IN_ORDER
                                  : (destructuring != -1
                                     ? Token.ENUM_INIT_ARRAY
                                     : Token.ENUM_INIT_KEYS);
@@ -1580,9 +1595,8 @@ public final class IRFactory extends Parser
         Node assign;
         if (destructuring != -1) {
             assign = createDestructuringAssignment(declType, lvalue, id);
-            if (!isForEach && !isForOf &&
-                (destructuring == Token.OBJECTLIT ||
-                 destructuringLen != 2))
+            if (!isForEach && (destructuring == Token.OBJECTLIT ||
+                               destructuringLen != 2))
             {
                 // destructuring assignment is only allowed in for..each or
                 // with an array type of length 2 (to hold key and value)
@@ -2291,11 +2305,7 @@ public final class IRFactory extends Parser
         } else if (fn.getMemberExprNode() != null) {
             mexpr = transform(fn.getMemberExprNode());
         }
-        boolean isArrow = fn.getFunctionType() == FunctionNode.ARROW_FUNCTION;
-        boolean noParen = isArrow && fn.getLp() == -1;
-        if (!noParen) {
-            decompiler.addToken(Token.LP);
-        }
+        decompiler.addToken(Token.LP);
         List<AstNode> params = fn.getParams();
         for (int i = 0; i < params.size(); i++) {
             decompile(params.get(i));
@@ -2303,12 +2313,7 @@ public final class IRFactory extends Parser
                 decompiler.addToken(Token.COMMA);
             }
         }
-        if (!noParen) {
-            decompiler.addToken(Token.RP);
-        }
-        if (isArrow) {
-            decompiler.addToken(Token.ARROW);
-        }
+        decompiler.addToken(Token.RP);
         if (!fn.isExpressionClosure()) {
             decompiler.addEOL(Token.LC);
         }
diff --git a/src/org/mozilla/javascript/IdFunctionObject.java b/src/org/mozilla/javascript/IdFunctionObject.java
index 57f7ef2..de228e1 100644
--- a/src/org/mozilla/javascript/IdFunctionObject.java
+++ b/src/org/mozilla/javascript/IdFunctionObject.java
@@ -115,29 +115,6 @@ public class IdFunctionObject extends BaseFunction
     }
 
     @Override
-    String decompile(int indent, int flags)
-    {
-        StringBuilder sb = new StringBuilder();
-        boolean justbody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));
-        if (!justbody) {
-            sb.append("function ");
-            sb.append(getFunctionName());
-            sb.append("() { ");
-        }
-        sb.append("[native code for ");
-        if (idcall instanceof Scriptable) {
-            Scriptable sobj = (Scriptable)idcall;
-            sb.append(sobj.getClassName());
-            sb.append('.');
-        }
-        sb.append(getFunctionName());
-        sb.append(", arity=");
-        sb.append(getArity());
-        sb.append(justbody ? "]\n" : "] }\n");
-        return sb.toString();
-    }
-
-    @Override
     public int getArity()
     {
         return arity;
diff --git a/src/org/mozilla/javascript/IdFunctionObjectES6.java b/src/org/mozilla/javascript/IdFunctionObjectES6.java
deleted file mode 100644
index 61cde3d..0000000
--- a/src/org/mozilla/javascript/IdFunctionObjectES6.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package org.mozilla.javascript;
-
-public class IdFunctionObjectES6 extends IdFunctionObject{
-
-    public IdFunctionObjectES6(IdFunctionCall idcall, Object tag, int id, String name, int arity, Scriptable scope) {
-        super(idcall, tag, id, name, arity, scope);
-    }
-
-    private static final int
-        Id_length       = 1,
-        Id_name         = 3;
-
-    private boolean myLength = true;
-    private boolean myName = true;
-
-    @Override
-    protected int findInstanceIdInfo(String s) {
-        if (s.equals("length")) return instanceIdInfo(READONLY | DONTENUM, Id_length);
-        else if (s.equals("name")) return instanceIdInfo(READONLY | DONTENUM, Id_name);
-        return super.findInstanceIdInfo(s);
-    }
-
-    @Override
-    protected Object getInstanceIdValue(int id) {
-        if (id == Id_length && !myLength) {
-            return NOT_FOUND;
-        } else if (id == Id_name && !myName) {
-            return NOT_FOUND;
-        }
-        return super.getInstanceIdValue(id);
-    }
-
-    @Override
-    protected void setInstanceIdValue(int id, Object value) {
-        if (id == Id_length && value == NOT_FOUND) {
-            this.myLength = false;
-            return;
-        } else if (id == Id_name && value == NOT_FOUND) {
-            this.myName = false;
-            return;
-        }
-        super.setInstanceIdValue(id, value);
-    }
-}
diff --git a/src/org/mozilla/javascript/IdScriptableObject.java b/src/org/mozilla/javascript/IdScriptableObject.java
index 1900795..76c7e91 100644
--- a/src/org/mozilla/javascript/IdScriptableObject.java
+++ b/src/org/mozilla/javascript/IdScriptableObject.java
@@ -188,15 +188,7 @@ public abstract class IdScriptableObject extends ScriptableObject
         {
             ensureId(id);
             int attr = attributeArray[id - 1];
-            // non-configurable
-            if ((attr & PERMANENT) != 0) {
-                Context cx = Context.getContext();
-                if (cx.isStrictMode()) {
-                    int nameSlot = (id  - 1) * SLOT_SPAN + NAME_SLOT;
-                    String name = (String)valueArray[nameSlot];
-                    throw ScriptRuntime.typeError1("msg.delete.property.with.configurable.false", name);
-                }
-            } else {
+            if ((attr & PERMANENT) == 0) {
                 int valueSlot = (id  - 1) * SLOT_SPAN;
                 synchronized (this) {
                     valueArray[valueSlot] = NOT_FOUND;
@@ -402,13 +394,7 @@ public abstract class IdScriptableObject extends ScriptableObject
             // Let the super class to throw exceptions for sealed objects
             if (!isSealed()) {
                 int attr = (info >>> 16);
-                // non-configurable
-                if ((attr & PERMANENT) != 0) {
-                    Context cx = Context.getContext();
-                    if (cx.isStrictMode()) {
-                        throw ScriptRuntime.typeError1("msg.delete.property.with.configurable.false", name);
-                    }
-                } else {
+                if ((attr & PERMANENT) == 0) {
                     int id = (info & 0xFFFF);
                     setInstanceIdValue(id, NOT_FOUND);
                 }
@@ -625,21 +611,12 @@ public abstract class IdScriptableObject extends ScriptableObject
         }
     }
 
-    public final IdFunctionObject initPrototypeMethod(Object tag, int id, String name,
-                                          int arity)
-    {
-		return initPrototypeMethod(tag, id, name, name, arity);
-    }
-
-    public final IdFunctionObject initPrototypeMethod(Object tag, int id, String propertyName, String functionName,
+    public final void initPrototypeMethod(Object tag, int id, String name,
                                           int arity)
     {
         Scriptable scope = ScriptableObject.getTopLevelScope(this);
-        IdFunctionObject function = newIdFunction(tag, id,
-            functionName != null ? functionName : propertyName,
-            arity, scope);
-        prototypeValues.initValue(id, propertyName, function, DONTENUM);
-        return function;
+        IdFunctionObject f = newIdFunction(tag, id, name, arity, scope);
+        prototypeValues.initValue(id, name, f, DONTENUM);
     }
 
     public final void initPrototypeConstructor(IdFunctionObject f)
@@ -711,15 +688,10 @@ public abstract class IdScriptableObject extends ScriptableObject
     private IdFunctionObject newIdFunction(Object tag, int id, String name,
                                            int arity, Scriptable scope)
     {
-        IdFunctionObject function = null;
-        if (Context.getContext().getLanguageVersion() < Context.VERSION_ES6) {
-            function = new IdFunctionObject(this, tag, id, name, arity, scope);
-        } else {
-            function = new IdFunctionObjectES6(this, tag, id, name, arity, scope);
-        }
-
-        if (isSealed()) { function.sealObject(); }
-        return function;
+        IdFunctionObject f = new IdFunctionObject(this, tag, id, name, arity,
+                                                  scope);
+        if (isSealed()) { f.sealObject(); }
+        return f;
     }
 
     @Override
diff --git a/src/org/mozilla/javascript/InterpretedFunction.java b/src/org/mozilla/javascript/InterpretedFunction.java
index 37b2e4d..1b161ab 100644
--- a/src/org/mozilla/javascript/InterpretedFunction.java
+++ b/src/org/mozilla/javascript/InterpretedFunction.java
@@ -16,6 +16,8 @@ final class InterpretedFunction extends NativeFunction implements Script
     SecurityController securityController;
     Object securityDomain;
 
+	private Arguments arguments;
+
     private InterpretedFunction(InterpreterData idata,
                                 Object staticSecurityDomain)
     {
@@ -75,7 +77,7 @@ final class InterpretedFunction extends NativeFunction implements Script
      * Create function embedded in script or another function.
      */
     static InterpretedFunction createFunction(Context cx, Scriptable scope,
-                                              InterpretedFunction parent,
+                                              InterpretedFunction  parent,
                                               int index)
     {
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/IRFactory.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/IdFunctionObject.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/IdScriptableObject.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/InterpretedFunction.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Interpreter.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/InterpreterData.java.
The file will have its original line endings in your working directory.
         InterpretedFunction f = new InterpretedFunction(parent, index);
@@ -104,7 +106,7 @@ final class InterpretedFunction extends NativeFunction implements Script
                        Object[] args)
     {
         if (!ScriptRuntime.hasTopCall(cx)) {
-            return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args, idata.isStrict);
+            return ScriptRuntime.doTopCall(this, cx, scope, thisObj, args);
         }
         return Interpreter.interpret(this, cx, scope, thisObj, args);
     }
@@ -118,7 +120,7 @@ final class InterpretedFunction extends NativeFunction implements Script
         if (!ScriptRuntime.hasTopCall(cx)) {
             // It will go through "call" path. but they are equivalent
             return ScriptRuntime.doTopCall(
-                this, cx, scope, scope, ScriptRuntime.emptyArgs, idata.isStrict);
+                this, cx, scope, scope, ScriptRuntime.emptyArgs);
         }
         return Interpreter.interpret(
             this, cx, scope, scope, ScriptRuntime.emptyArgs);
@@ -176,5 +178,57 @@ final class InterpretedFunction extends NativeFunction implements Script
     {
         return idata.argIsConst[index];
     }
+
+    /**
+     * Provides the decompiled source of the function what is helpful
+     * while debugging.
+     */
+    @Override
+    public String toString() {
+    	return decompile(2, 0);
+    }
+
+	void setArguments(final Arguments arguments) {
+		if (arguments == null) {
+			this.arguments = null;
+			return;
+		}
+
+		final Context currentContext = Context.getCurrentContext();
+		if (currentContext.hasFeature(Context.FEATURE_HTMLUNIT_FN_ARGUMENTS_IS_RO_VIEW)) {
+			this.arguments = new Arguments(arguments) {
+				@Override
+				public void put(int index, Scriptable start, Object value) {
+					// ignore
+				}
+				
+				@Override
+				public void put(String name, Scriptable start, Object value) {
+					// ignore
+				}
+
+				@Override
+				public void delete(int index) {
+					// ignore
+				}
+				
+				@Override
+				public void delete(String name) {
+					// ignore
+				}
+			};
+        }
+		else {
+			this.arguments = arguments;
+		}
+	}
+	
+	@Override
+	public Object get(final String name, final Scriptable start) {
+		if (start == this && "arguments".equals(name)) {
+			return this.arguments;
+		}
+		return super.get(name, start);
+	}
 }
 
diff --git a/src/org/mozilla/javascript/Interpreter.java b/src/org/mozilla/javascript/Interpreter.java
index c591b1c..d58fab2 100644
--- a/src/org/mozilla/javascript/Interpreter.java
+++ b/src/org/mozilla/javascript/Interpreter.java
@@ -853,7 +853,7 @@ public final class Interpreter extends Icode implements Evaluator
                                              Scriptable scope, Object[] args)
     {
         if (!ScriptRuntime.hasTopCall(cx)) {
-            return ScriptRuntime.doTopCall(c, cx, scope, null, args, cx.isTopLevelStrict);
+            return ScriptRuntime.doTopCall(c, cx, scope, null, args);
         }
 
         Object arg;
@@ -1648,8 +1648,7 @@ switch (op) {
     }
     case Token.ENUM_INIT_KEYS :
     case Token.ENUM_INIT_VALUES :
-    case Token.ENUM_INIT_ARRAY :
-    case Token.ENUM_INIT_VALUES_IN_ORDER : {
+    case Token.ENUM_INIT_ARRAY : {
         Object lhs = stack[stackTop];
         if (lhs == DBL_MRK) lhs = ScriptRuntime.wrapNumber(sDbl[stackTop]);
         --stackTop;
@@ -1658,8 +1657,6 @@ switch (op) {
                          ? ScriptRuntime.ENUMERATE_KEYS :
                        op == Token.ENUM_INIT_VALUES
                          ? ScriptRuntime.ENUMERATE_VALUES :
-                       op == Token.ENUM_INIT_VALUES_IN_ORDER
-                         ? ScriptRuntime.ENUMERATE_VALUES_IN_ORDER :
                        ScriptRuntime.ENUMERATE_ARRAY;
         stack[indexReg] = ScriptRuntime.enumInit(lhs, cx, frame.scope, enumType);
         continue Loop;
@@ -1714,14 +1711,9 @@ switch (op) {
         stack[indexReg] = frame.scope;
         continue Loop;
     case Icode_CLOSURE_EXPR :
-        InterpretedFunction fn = InterpretedFunction.createFunction(cx, frame.scope,
-                                                                    frame.fnOrScript,
-                                                                    indexReg);
-        if (fn.idata.itsFunctionType == FunctionNode.ARROW_FUNCTION) {
-            stack[++stackTop] = new ArrowFunction(cx, frame.scope, fn, frame.thisObj);
-        } else {
-            stack[++stackTop] = fn;
-        }
+        stack[++stackTop] = InterpretedFunction.createFunction(cx, frame.scope,
+                                                               frame.fnOrScript,
+                                                               indexReg);
         continue Loop;
     case Icode_CLOSURE_STMT :
         initFunction(cx, frame.scope, frame.fnOrScript, indexReg);
@@ -2758,11 +2750,8 @@ switch (op) {
             scope = fnOrScript.getParentScope();
 
             if (useActivation) {
-                if (idata.itsFunctionType == FunctionNode.ARROW_FUNCTION) {
-                    scope = ScriptRuntime.createArrowFunctionActivation(fnOrScript, scope, args, idata.isStrict);
-                } else {
-                    scope = ScriptRuntime.createFunctionActivation(fnOrScript, scope, args, idata.isStrict);
-                }
+                scope = ScriptRuntime.createFunctionActivation(
+                            fnOrScript, scope, args);
             }
         } else {
             scope = callerScope;
@@ -2876,6 +2865,17 @@ switch (op) {
     private static void enterFrame(Context cx, CallFrame frame, Object[] args,
                                    boolean continuationRestart)
     {
+       if (frame.parentFrame != null && !frame.parentFrame.fnOrScript.isScript()) {
+           frame.fnOrScript.defaultPut("caller", frame.parentFrame.fnOrScript);
+           frame.fnOrScript.setAttributes("caller", ScriptableObject.DONTENUM);
+       }
+       if (frame.scope instanceof NativeCall) {
+           Object arguments = ScriptableObject.getProperty(frame.scope, "arguments");
+           if (arguments instanceof Arguments) {
+               frame.fnOrScript.setArguments((Arguments) arguments);
+           }
+       }
+
         boolean usesActivation = frame.idata.itsNeedsActivation;
         boolean isDebugged = frame.debuggerFrame != null;
         if(usesActivation || isDebugged) {
@@ -2925,6 +2925,9 @@ switch (op) {
     private static void exitFrame(Context cx, CallFrame frame,
                                   Object throwable)
     {
+        frame.fnOrScript.defaultPut("caller", null);
+        frame.fnOrScript.setArguments(null);
+
         if (frame.idata.itsNeedsActivation) {
             ScriptRuntime.exitActivationFunction(cx);
         }
diff --git a/src/org/mozilla/javascript/InterpreterData.java b/src/org/mozilla/javascript/InterpreterData.java
index 817d52c..7c9b5a0 100644
--- a/src/org/mozilla/javascript/InterpreterData.java
+++ b/src/org/mozilla/javascript/InterpreterData.java
@@ -34,7 +34,7 @@ final class InterpreterData implements Serializable, DebuggableScript
         this.languageVersion = parent.languageVersion;
         this.itsSourceFile = parent.itsSourceFile;
         this.encodedSource = parent.encodedSource;
-        this.isStrict = parent.isStrict;
+
         init();
     }
 
@@ -89,6 +89,8 @@ final class InterpreterData implements Serializable, DebuggableScript
 
     boolean evalScriptFlag; // true if script corresponds to eval() code
 
+	boolean declaredAsVar; // true if the function has been declared like "var foo = function() {...}"
+
     public boolean isTopLevel()
     {
         return topLevel;
diff --git a/src/org/mozilla/javascript/MemberBox.java b/src/org/mozilla/javascript/MemberBox.java
index 52145c0..b6eeb80 100644
--- a/src/org/mozilla/javascript/MemberBox.java
+++ b/src/org/mozilla/javascript/MemberBox.java
@@ -25,7 +25,37 @@ final class MemberBox implements Serializable
     transient Class<?>[] argTypes;
     transient Object delegateTo;
     transient boolean vararg;
+    transient Function asFunction;
 
+    /**
+     * Function returned by calls to __lookupGetter__/__lookupSetter__
+     */
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/MemberBox.java.
The file will have its original line endings in your working directory.
+    Function asFunction(final String name, final Scriptable scope, final Scriptable prototype) {
+    	if (asFunction == null) {
+    		asFunction = new BaseFunction(scope, prototype) {
+    	          @Override
+    	          public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] originalArgs) {
+                      MemberBox nativeGetter = MemberBox.this;
+                      Object getterThis;
+                      Object[] args;
+                      if (nativeGetter.delegateTo == null) {
+                          getterThis = thisObj;
+                          args = ScriptRuntime.emptyArgs;
+                      } else {
+                          getterThis = nativeGetter.delegateTo;
+                          args = new Object[] { thisObj };
+                      }
+                      return nativeGetter.invoke(getterThis, args);
+    	          }
+    	          
+    	          @Override
+    	        public String getFunctionName() {
+    	        	return name;
+    	        }
+    		};
+    	}
+    	return asFunction;
+    }
 
     MemberBox(Method method)
     {
@@ -121,6 +151,17 @@ final class MemberBox implements Serializable
     Object invoke(Object target, Object[] args)
     {
         Method method = method();
+        
+        // handle delegators
+        if (target instanceof Delegator) {
+        	target = ((Delegator) target).getDelegee();
+        }
+        for (int i=0; i<args.length; ++i) {
+        	if (args[i] instanceof Delegator) {
+        		args[i] = ((Delegator) args[i]).getDelegee();
+        	}
+        }
+        
         try {
             try {
                 return method.invoke(target, args);
@@ -145,7 +186,22 @@ final class MemberBox implements Serializable
             } while ((e instanceof InvocationTargetException));
             if (e instanceof ContinuationPending)
                 throw (ContinuationPending) e;
-            throw Context.throwAsScriptRuntimeEx(e);
+
+            if (e instanceof RhinoException || Context.getCurrentContext().hasFeature(Context.FEATURE_HTMLUNIT_JS_CATCH_JAVA_EXCEPTION))
+                throw Context.throwAsScriptRuntimeEx(e);            
+            else
+            	throw new RuntimeException("Exception invoking " + method.getName(), e);
+        } catch (IllegalArgumentException iae) {
+            StringBuilder builder = new StringBuilder();
+            for (Object arg : args) {
+                String type = arg == null ? "null" : arg.getClass().getSimpleName();
+                if (builder.length() != 0) {
+                    builder.append(", ");
+                }
+                builder.append(type);
+            }
+            throw new IllegalArgumentException("Exception invoking " + method.getDeclaringClass().getSimpleName()
+                    + '.' +  method.getName() + "() with arguments [" + builder + "]", iae);
         } catch (Exception ex) {
             throw Context.throwAsScriptRuntimeEx(ex);
         }
diff --git a/src/org/mozilla/javascript/NativeArray.java b/src/org/mozilla/javascript/NativeArray.java
index ede36ca..f4b9b7b 100644
--- a/src/org/mozilla/javascript/NativeArray.java
+++ b/src/org/mozilla/javascript/NativeArray.java
@@ -7,6 +7,8 @@
 package org.mozilla.javascript;
 
 import org.mozilla.javascript.regexp.NativeRegExp;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -18,9 +20,6 @@ import java.util.ListIterator;
 import java.util.NoSuchElementException;
 import java.util.Set;
 
-import static org.mozilla.javascript.NativeSymbol.ITERATOR_PROPERTY;
-import static org.mozilla.javascript.ScriptRuntimeES6.requireObjectCoercible;
-
 /**
  * This class implements the Array native object.
  * @author Norris Boyd
@@ -28,6 +27,24 @@ import static org.mozilla.javascript.ScriptRuntimeES6.requireObjectCoercible;
  */
 public class NativeArray extends IdScriptableObject implements List
 {
+    static {
+        try {
+            // A workaround to change the default sort logic, to allow non-conformant comparison method
+            // this starts to be observed since Java 7
+            Class<?> klass = Class.forName("java.util.Arrays$LegacyMergeSort");
+            Field field = klass.getDeclaredField("userRequested");
+            field.setAccessible(true);
+
+            Field modifiersField = Field.class.getDeclaredField("modifiers");
+            modifiersField.setAccessible(true);
+            modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
+
+            field.setBoolean(null, true);
+        }
+        catch (final Exception e) {
+            // RIP
+        }
+    }
     static final long serialVersionUID = 7331366857676127338L;
 
     /*
@@ -189,7 +206,7 @@ public class NativeArray extends IdScriptableObject implements List
     @Override
     protected void initPrototypeId(int id)
     {
-        String s, fnName = null;
+        String s;
         int arity;
         switch (id) {
           case Id_constructor:    arity=1; s="constructor";    break;
@@ -217,11 +234,9 @@ public class NativeArray extends IdScriptableObject implements List
           case Id_findIndex:      arity=1; s="findIndex";      break;
           case Id_reduce:         arity=1; s="reduce";         break;
           case Id_reduceRight:    arity=1; s="reduceRight";    break;
-          case Id_iterator:       arity=0; s= ITERATOR_PROPERTY; fnName="[Symbol.iterator]"; break;
           default: throw new IllegalArgumentException(String.valueOf(id));
         }
-
-        initPrototypeMethod(ARRAY_TAG, id, s, fnName, arity);
+        initPrototypeMethod(ARRAY_TAG, id, s, arity);
     }
 
     @Override
@@ -332,15 +347,12 @@ public class NativeArray extends IdScriptableObject implements List
               case Id_some:
               case Id_find:
               case Id_findIndex:
-                return iterativeMethod(cx, f, scope, thisObj, args);
+                return iterativeMethod(cx, id, scope, thisObj, args);
               case Id_reduce:
               case Id_reduceRight:
                 return reduceMethod(cx, id, scope, thisObj, args);
-
-              case Id_iterator:
-                return new NativeArrayIterator(scope, thisObj);
             }
-            throw new IllegalArgumentException("Array.prototype has no method: " + f.getFunctionName());
+            throw new IllegalArgumentException(String.valueOf(id));
         }
     }
 
@@ -1601,24 +1613,14 @@ public class NativeArray extends IdScriptableObject implements List
     /**
      * Implements the methods "every", "filter", "forEach", "map", and "some".
      */
-    private static Object iterativeMethod(Context cx, IdFunctionObject idFunctionObject, Scriptable scope,
+    private static Object iterativeMethod(Context cx, int id, Scriptable scope,
                                           Scriptable thisObj, Object[] args)
     {
-        int id = idFunctionObject.methodId();
-
-        if (Id_find == id || Id_findIndex == id) thisObj = requireObjectCoercible(cx, thisObj, idFunctionObject);
-
         long length = getLengthProperty(cx, thisObj);
         Object callbackArg = args.length > 0 ? args[0] : Undefined.instance;
         if (callbackArg == null || !(callbackArg instanceof Function)) {
             throw ScriptRuntime.notFunctionError(callbackArg);
-        }
-        if (cx.getLanguageVersion() >= Context.VERSION_ES6 && (callbackArg instanceof NativeRegExp)) {
-            // Previously, it was allowed to pass RegExp instance as a callback (it implements Function)
-            // But according to ES2015 21.2.6 Properties of RegExp Instances:
-            // > RegExp instances are ordinary objects that inherit properties from the RegExp prototype object.
-            // > RegExp instances have internal slots [[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]].
-            // so, no [[Call]] for RegExp-s
+        } else if ((id == Id_find || id == Id_findIndex) && !(callbackArg instanceof NativeFunction)) {
             throw ScriptRuntime.notFunctionError(callbackArg);
         }
 
@@ -1631,6 +1633,10 @@ public class NativeArray extends IdScriptableObject implements List
             thisArg = ScriptRuntime.toObject(cx, scope, args[1]);
         }
 
+        if ((Id_find == id || Id_findIndex == id) && thisArg == thisObj) {
+            throw ScriptRuntime.typeError("Array.prototype method called on null or undefined");
+        }
+
         Scriptable array = null;
         if (id == Id_filter || id == Id_map) {
             int resultLength = id == Id_map ? (int) length : 0;
@@ -1641,11 +1647,7 @@ public class NativeArray extends IdScriptableObject implements List
             Object[] innerArgs = new Object[3];
             Object elem = getRawElem(thisObj, i);
             if (elem == Scriptable.NOT_FOUND) {
-                if (id == Id_find || id == Id_findIndex) {
-                    elem = Undefined.instance;
-                } else {
-                    continue;
-                }
+                continue;
             }
             innerArgs[0] = elem;
             innerArgs[1] = Long.valueOf(i);
@@ -1671,9 +1673,9 @@ public class NativeArray extends IdScriptableObject implements List
                 break;
               case Id_find:
                 if (ScriptRuntime.toBoolean(result))
-                    return elem;
+                  return elem;
                 break;
-              case Id_findIndex:
+            case Id_findIndex:
                 if (ScriptRuntime.toBoolean(result))
                     return ScriptRuntime.wrapNumber(i);
                 break;
@@ -2000,7 +2002,6 @@ public class NativeArray extends IdScriptableObject implements List
                 else if (c=='t') { X="toString";id=Id_toString; }
                 break L;
             case 9: X="findIndex";id=Id_findIndex; break L;
-            case 10: X="@@iterator";id=Id_iterator; break L;
             case 11: c=s.charAt(0);
                 if (c=='c') { X="constructor";id=Id_constructor; }
                 else if (c=='l') { X="lastIndexOf";id=Id_lastIndexOf; }
@@ -2041,9 +2042,9 @@ public class NativeArray extends IdScriptableObject implements List
         Id_findIndex            = 23,
         Id_reduce               = 24,
         Id_reduceRight          = 25,
-        Id_iterator             = 26,
 
-        MAX_PROTOTYPE_ID        = 26;
+
+        MAX_PROTOTYPE_ID        = 25;
 
 // #/string_id_map#
 
diff --git a/src/org/mozilla/javascript/NativeArrayIterator.java b/src/org/mozilla/javascript/NativeArrayIterator.java
deleted file mode 100644
index 1507095..0000000
--- a/src/org/mozilla/javascript/NativeArrayIterator.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript;
-
-public final class NativeArrayIterator extends ES6Iterator {
-    private static final long serialVersionUID = 1L;
-    private static final String ITERATOR_TAG = "ArrayIterator";
-
-    static void init(ScriptableObject scope, boolean sealed) {
-        ES6Iterator.init(scope, sealed, new NativeArrayIterator(), ITERATOR_TAG);
-    }
-
-    /**
-     * Only for constructing the prototype object.
-     */
-    private NativeArrayIterator() {
-        super();
-    }
-
-    public NativeArrayIterator(Scriptable scope, Scriptable arrayLike) {
-        super(scope);
-        this.index = 0;
-        this.arrayLike = arrayLike;
-    }
-
-    @Override
-    public String getClassName() {
-        return "Array Iterator";
-    }
-
-    @Override
-    protected boolean isDone(Context cx, Scriptable scope) {
-        return index >= NativeArray.getLengthProperty(cx, arrayLike);
-    }
-
-    @Override
-    protected Object nextValue(Context cx, Scriptable scope) {
-        Object value = arrayLike.get(index++, arrayLike);
-        if (value == ScriptableObject.NOT_FOUND) {
-            value = Undefined.instance;
-        }
-        return value;
-    }
-
-    @Override
-    protected String getTag() {
-        return ITERATOR_TAG;
-    }
-
-    private Scriptable arrayLike;
-    private int index;
-}
-
diff --git a/src/org/mozilla/javascript/NativeBoolean.java b/src/org/mozilla/javascript/NativeBoolean.java
index 2ab42ab..d83f792 100644
--- a/src/org/mozilla/javascript/NativeBoolean.java
+++ b/src/org/mozilla/javascript/NativeBoolean.java
@@ -74,7 +74,7 @@ final class NativeBoolean extends IdScriptableObject
             } else {
                 b = args[0] instanceof ScriptableObject &&
                         ((ScriptableObject) args[0]).avoidObjectDetection()
-                    ? true
+                    ? false
                     : ScriptRuntime.toBoolean(args[0]);
             }
             if (thisObj == null) {
diff --git a/src/org/mozilla/javascript/NativeCall.java b/src/org/mozilla/javascript/NativeCall.java
index 3bca84b..1f18df5 100644
--- a/src/org/mozilla/javascript/NativeCall.java
+++ b/src/org/mozilla/javascript/NativeCall.java
@@ -6,6 +6,8 @@
 
 package org.mozilla.javascript;
 
+import org.mozilla.javascript.debug.DebuggableScript;
+
 /**
  * This class implements the activation object.
  *
@@ -28,7 +30,7 @@ public final class NativeCall extends IdScriptableObject
 
     NativeCall() { }
 
-    NativeCall(NativeFunction function, Scriptable scope, Object[] args, boolean isArrow, boolean isStrict)
+    NativeCall(NativeFunction function, Scriptable scope, Object[] args)
     {
         this.function = function;
 
@@ -36,7 +38,6 @@ public final class NativeCall extends IdScriptableObject
         // leave prototype null
 
         this.originalArgs = (args == null) ? ScriptRuntime.emptyArgs : args;
-        this.isStrict = isStrict;
 
         // initialize values of arguments
         int paramAndVarCount = function.getParamAndVarCount();
@@ -52,9 +53,8 @@ public final class NativeCall extends IdScriptableObject
 
         // initialize "arguments" property but only if it was not overridden by
         // the parameter with the same name
-        if (!super.has("arguments", this) && !isArrow) {
-            arguments = new Arguments(this);
-            defineProperty("arguments", arguments, PERMANENT);
+        if (!super.has("arguments", this)) {
+            defineProperty("arguments", new Arguments(this), PERMANENT);
         }
 
         if (paramAndVarCount != 0) {
@@ -63,8 +63,22 @@ public final class NativeCall extends IdScriptableObject
                 if (!super.has(name, this)) {
                     if (function.getParamOrVarConst(i))
                         defineProperty(name, Undefined.instance, CONST);
-                    else
-                        defineProperty(name, Undefined.instance, PERMANENT);
+                    else {
+                        boolean define = true;
+                        if (function instanceof InterpretedFunction) {
+                            InterpreterData idata = ((InterpretedFunction) function).idata;
+                            for (int f = 0; f < idata.getFunctionCount(); f++) {
+                                final InterpreterData functionData = (InterpreterData) idata.getFunction(f);
+								if (name.equals(functionData.getFunctionName())) {
+                                    define = functionData.declaredAsVar; // define local property only for inner functions declared with var
+                                    break;
+                                }
+                            }
+                        }
+                        if (define) {
+                            defineProperty(name, Undefined.instance, PERMANENT);
+                        }
+                    }
                 }
             }
         }
@@ -115,20 +129,12 @@ public final class NativeCall extends IdScriptableObject
         throw new IllegalArgumentException(String.valueOf(id));
     }
 
-    public void defineAttributesForArguments() {
-        if (arguments != null) {
-            arguments.defineAttributesForStrictMode();
-        }
-    }
-
     private static final int
         Id_constructor   = 1,
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeArray.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeBoolean.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeCall.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeCallSite.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeDate.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeError.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeGenerator.java.
The file will have its original line endings in your working directory.
         MAX_PROTOTYPE_ID = 1;
 
     NativeFunction function;
     Object[] originalArgs;
-    boolean isStrict;
-    private Arguments arguments;
 
     transient NativeCall parentActivationCall;
 }
diff --git a/src/org/mozilla/javascript/NativeCallSite.java b/src/org/mozilla/javascript/NativeCallSite.java
index 2fec127..8496f72 100644
--- a/src/org/mozilla/javascript/NativeCallSite.java
+++ b/src/org/mozilla/javascript/NativeCallSite.java
@@ -100,8 +100,6 @@ public class NativeCallSite extends IdScriptableObject
         case Id_getEvalOrigin:
         case Id_isEval:
         case Id_isConstructor:
-        case Id_isNative:
-        case Id_isToplevel:
             return getFalse();
         case Id_toString:
             return js_toString(thisObj);
diff --git a/src/org/mozilla/javascript/NativeDate.java b/src/org/mozilla/javascript/NativeDate.java
index 28ffcee..cf83b06 100644
--- a/src/org/mozilla/javascript/NativeDate.java
+++ b/src/org/mozilla/javascript/NativeDate.java
@@ -16,9 +16,6 @@ import java.util.TimeZone;
  * This class implements the Date native object.
  * See ECMA 15.9.
  * @author Mike McCabe
- *
- * Significant parts of this code are adapted from the venerable jsdate.cpp (also Mozilla):
- * https://dxr.mozilla.org/mozilla-central/source/js/src/jsdate.cpp
  */
 final class NativeDate extends IdScriptableObject
 {
@@ -432,25 +429,35 @@ final class NativeDate extends IdScriptableObject
 
     private static int YearFromTime(double t)
     {
-        if (Double.isInfinite(t) || Double.isNaN(t)) {
-            return 0;
+        int lo = (int) Math.floor((t / msPerDay) / 366) + 1970;
+        int hi = (int) Math.floor((t / msPerDay) / 365) + 1970;
+        int mid;
+
+        /* above doesn't work for negative dates... */
+        if (hi < lo) {
+            int temp = lo;
+            lo = hi;
+            hi = temp;
         }
 
-        double y = Math.floor(t / (msPerDay * 365.2425)) + 1970;
-        double t2 = TimeFromYear(y);
-
-        /*
-         * Adjust the year if the approximation was wrong.  Since the year was
-         * computed using the average number of ms per year, it will usually
-         * be wrong for dates within several hours of a year transition.
-         */
-        if (t2 > t) {
-            y--;
-        } else {
-            if (t2 + msPerDay * DaysInYear(y) <= t)
-                y++;
+        /* Use a simple binary search algorithm to find the right
+           year.  This seems like brute force... but the computation
+           of hi and lo years above lands within one year of the
+           correct answer for years within a thousand years of
+           1970; the loop below only requires six iterations
+           for year 270000. */
+        while (hi > lo) {
+            mid = (hi + lo) / 2;
+            if (TimeFromYear(mid) > t) {
+                hi = mid - 1;
+            } else {
+                lo = mid + 1;
+                if (TimeFromYear(lo) > t) {
+                    return mid;
+                }
+            }
         }
-        return (int)y;
+        return lo;
     }
 
     private static double DayFromMonth(int m, int year)
@@ -466,14 +473,6 @@ final class NativeDate extends IdScriptableObject
         return day;
     }
 
-    private static double DaysInYear(double year)
-    {
-        if (Double.isInfinite(year) || Double.isNaN(year)) {
-            return ScriptRuntime.NaN;
-        }
-        return IsLeapYear((int)year) ? 366.0 : 365.0;
-    }
-
     private static int DaysInMonth(int year, int month)
     {
         // month is 1-based for DaysInMonth!
diff --git a/src/org/mozilla/javascript/NativeError.java b/src/org/mozilla/javascript/NativeError.java
index 914e518..2066b80 100644
--- a/src/org/mozilla/javascript/NativeError.java
+++ b/src/org/mozilla/javascript/NativeError.java
@@ -161,7 +161,7 @@ final class NativeError extends IdScriptableObject
         // generated on demand, is cached after the first access, and is
         // overwritable like an ordinary property. Hence this setup with
         // the getter and setter below.
-        if (stackProvider == null) {
+        if (stackProvider == null && Context.getContext().hasFeature(Context.FEATURE_HTMLUNIT_ERROR_STACK)) {
             stackProvider = re;
             defineProperty("stack", this,
                            ERROR_DELEGATE_GET_STACK, ERROR_DELEGATE_SET_STACK,
@@ -192,11 +192,14 @@ final class NativeError extends IdScriptableObject
         // Determine whether to format the stack trace ourselves, or call the user's code to do it
         Object value;
         if (prepare == null) {
+	    	RhinoException.useMozillaStackStyle(true);
             value = RhinoException.formatStackTrace(stack, stackProvider.details());
+    		RhinoException.useMozillaStackStyle(false);
         } else {
             value = callPrepareStack(prepare, stack);
         }
 
+    	RhinoException.useMozillaStackStyle(false);
         // We store the stack as local property both to cache it
         // and to make the property writable
         setStackDelegated(target, value);
diff --git a/src/org/mozilla/javascript/NativeGenerator.java b/src/org/mozilla/javascript/NativeGenerator.java
index 1cbc843..a63a49b 100644
--- a/src/org/mozilla/javascript/NativeGenerator.java
+++ b/src/org/mozilla/javascript/NativeGenerator.java
@@ -72,6 +72,27 @@ public final class NativeGenerator extends IdScriptableObject {
         return "Generator";
     }
 
+    private static class CloseGeneratorAction implements ContextAction {
+        private NativeGenerator generator;
+
+        CloseGeneratorAction(NativeGenerator generator) {
+            this.generator = generator;
+        }
+
+        public Object run(Context cx) {
+            Scriptable scope = ScriptableObject.getTopLevelScope(generator);
+            Callable closeGenerator = new Callable() {
+                public Object call(Context cx, Scriptable scope,
+                                   Scriptable thisObj, Object[] args) {
+                     return ((NativeGenerator)thisObj).resume(cx, scope,
+                             GENERATOR_CLOSE, new GeneratorClosedException());
+                }
+            };
+            return ScriptRuntime.doTopCall(closeGenerator, cx, scope,
+                                           generator, null);
+        }
+    }
+
     @Override
     protected void initPrototypeId(int id) {
         String s;
diff --git a/src/org/mozilla/javascript/NativeGlobal.java b/src/org/mozilla/javascript/NativeGlobal.java
index bd06aa5..4338f79 100644
--- a/src/org/mozilla/javascript/NativeGlobal.java
+++ b/src/org/mozilla/javascript/NativeGlobal.java
@@ -9,6 +9,7 @@ package org.mozilla.javascript;
 import java.io.Serializable;
 
 import org.mozilla.javascript.xml.XMLLib;
+
 import static org.mozilla.javascript.ScriptableObject.DONTENUM;
 import static org.mozilla.javascript.ScriptableObject.READONLY;
 import static org.mozilla.javascript.ScriptableObject.PERMANENT;
@@ -150,10 +151,16 @@ public class NativeGlobal implements Serializable, IdFunctionCall
                     return js_eval(cx, scope, args);
 
                 case Id_isFinite: {
+                    boolean result;
                     if (args.length < 1) {
-                        return Boolean.FALSE;
+                        result = false;
+                    } else {
+                        double d = ScriptRuntime.toNumber(args[0]);
+                        result = (d == d
+                                  && d != Double.POSITIVE_INFINITY
+                                  && d != Double.NEGATIVE_INFINITY);
                     }
-                    return NativeNumber.isFinite(args[0]);
+                    return ScriptRuntime.wrapBoolean(result);
                 }
 
                 case Id_isNaN: {
@@ -203,7 +210,7 @@ public class NativeGlobal implements Serializable, IdFunctionCall
     /**
      * The global method parseInt, as per ECMA-262 15.1.2.2.
      */
-    static Object js_parseInt(Object[] args) {
+    private Object js_parseInt(Object[] args) {
         String s = ScriptRuntime.toString(args, 0);
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeGlobal.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeJavaObject.java.
The file will have its original line endings in your working directory.
         int radix = ScriptRuntime.toInt32(args, 1);
 
@@ -243,8 +250,9 @@ public class NativeGlobal implements Serializable, IdFunctionCall
                     radix = 16;
                     start += 2;
                 } else if ('0' <= c && c <= '9') {
-                    radix = 8;
-                    start++;
+                    if (!Context.getCurrentContext().hasFeature(Context.FEATURE_HTMLUNIT_PARSE_INT_RADIX_10)) {
+                        radix = 8;
+                    }
                 }
             }
         }
@@ -258,7 +266,7 @@ public class NativeGlobal implements Serializable, IdFunctionCall
      *
      * @param args the arguments to parseFloat, ignoring args[>=1]
      */
-    static Object js_parseFloat(Object[] args)
+    private Object js_parseFloat(Object[] args)
     {
         if (args.length < 1)
             return ScriptRuntime.NaNobj;
diff --git a/src/org/mozilla/javascript/NativeJavaObject.java b/src/org/mozilla/javascript/NativeJavaObject.java
index bb2fa79..4f4fec8 100644
--- a/src/org/mozilla/javascript/NativeJavaObject.java
+++ b/src/org/mozilla/javascript/NativeJavaObject.java
@@ -362,14 +362,10 @@ public class NativeJavaObject implements Scriptable, Wrapper, Serializable
                 }
             }
             else if (to.isInterface()) {
-
-                if (fromObj instanceof NativeFunction) {
+                if (fromObj instanceof NativeObject || fromObj instanceof NativeFunction) {
                     // See comments in createInterfaceAdapter
                     return 1;
                 }
-                if (fromObj instanceof NativeObject) {
-                    return 2;
-                }
                 return 12;
             }
             else if (to.isPrimitive() && to != Boolean.TYPE) {
diff --git a/src/org/mozilla/javascript/NativeMath.java b/src/org/mozilla/javascript/NativeMath.java
index fd463ea..94d0b55 100644
--- a/src/org/mozilla/javascript/NativeMath.java
+++ b/src/org/mozilla/javascript/NativeMath.java
@@ -6,8 +6,6 @@
 
 package org.mozilla.javascript;
 
-import org.mozilla.javascript.typedarrays.Conversions;
-
 /**
  * This class implements the Math native object.
  * See ECMA 15.8.
@@ -51,29 +49,19 @@ final class NativeMath extends IdScriptableObject
               case Id_asin:     arity = 1; name = "asin";     break;
               case Id_atan:     arity = 1; name = "atan";     break;
               case Id_atan2:    arity = 2; name = "atan2";    break;
-              case Id_cbrt:     arity = 1; name = "cbrt";     break;
               case Id_ceil:     arity = 1; name = "ceil";     break;
               case Id_cos:      arity = 1; name = "cos";      break;
-              case Id_cosh:     arity = 1; name = "cosh";     break;
               case Id_exp:      arity = 1; name = "exp";      break;
-              case Id_expm1:    arity = 1; name = "expm1";    break;
               case Id_floor:    arity = 1; name = "floor";    break;
-              case Id_hypot:    arity = 2; name = "hypot";    break;
-              case Id_imul:     arity = 2; name = "imul";     break;
               case Id_log:      arity = 1; name = "log";      break;
-              case Id_log1p:    arity = 1; name = "log1p";    break;
-              case Id_log10:    arity = 1; name = "log10";    break;
               case Id_max:      arity = 2; name = "max";      break;
               case Id_min:      arity = 2; name = "min";      break;
               case Id_pow:      arity = 2; name = "pow";      break;
               case Id_random:   arity = 0; name = "random";   break;
               case Id_round:    arity = 1; name = "round";    break;
               case Id_sin:      arity = 1; name = "sin";      break;
-              case Id_sinh:     arity = 1; name = "sinh";     break;
               case Id_sqrt:     arity = 1; name = "sqrt";     break;
               case Id_tan:      arity = 1; name = "tan";      break;
-              case Id_tanh:     arity = 1; name = "tanh";     break;
-              case Id_trunc:    arity = 1; name = "trunc";    break;
               default: throw new IllegalStateException(String.valueOf(id));
             }
             initPrototypeMethod(MATH_TAG, id, name, arity);
@@ -135,11 +123,6 @@ final class NativeMath extends IdScriptableObject
                 x = Math.atan2(x, ScriptRuntime.toNumber(args, 1));
                 break;
 
-            case Id_cbrt:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.cbrt(x);
-                break;
-
             case Id_ceil:
                 x = ScriptRuntime.toNumber(args, 0);
                 x = Math.ceil(x);
@@ -152,15 +135,6 @@ final class NativeMath extends IdScriptableObject
                     ? Double.NaN : Math.cos(x);
                 break;
 
-            case Id_cosh:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.cosh(x);
-                break;
-
-            case Id_hypot:
-                x = js_hypot(args);
-                break;
-
             case Id_exp:
                 x = ScriptRuntime.toNumber(args, 0);
                 x = (x == Double.POSITIVE_INFINITY) ? x
@@ -168,35 +142,17 @@ final class NativeMath extends IdScriptableObject
                     : Math.exp(x);
                 break;
 
-            case Id_expm1:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.expm1(x);
-                break;
-
             case Id_floor:
                 x = ScriptRuntime.toNumber(args, 0);
                 x = Math.floor(x);
                 break;
 
-            case Id_imul:
-                return js_imul(args);
-
             case Id_log:
                 x = ScriptRuntime.toNumber(args, 0);
                 // Java's log(<0) = -Infinity; we need NaN
                 x = (x < 0) ? Double.NaN : Math.log(x);
                 break;
 
-            case Id_log1p:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.log1p(x);
-                break;
-
-            case Id_log10:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.log10(x);
-                break;
-
             case Id_max:
             case Id_min:
                 x = (methodId == Id_max)
@@ -252,11 +208,6 @@ final class NativeMath extends IdScriptableObject
                     ? Double.NaN : Math.sin(x);
                 break;
 
-            case Id_sinh:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.sinh(x);
-                break;
-
             case Id_sqrt:
                 x = ScriptRuntime.toNumber(args, 0);
                 x = Math.sqrt(x);
@@ -267,16 +218,6 @@ final class NativeMath extends IdScriptableObject
                 x = Math.tan(x);
                 break;
 
-            case Id_tanh:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = Math.tanh(x);
-                break;
-
-            case Id_trunc:
-                x = ScriptRuntime.toNumber(args, 0);
-                x = js_trunc(x);
-                break;
-
             default: throw new IllegalStateException(String.valueOf(methodId));
         }
         return ScriptRuntime.wrapNumber(x);
@@ -337,53 +278,13 @@ final class NativeMath extends IdScriptableObject
         return result;
     }
 
-    // Based on code from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot
-    private double js_hypot(Object[] args)
-    {
-        if (args == null) {
-            return 0.0;
-        }
-        double y = 0.0;
-
-        for (Object o : args) {
-            double d = ScriptRuntime.toNumber(o);
-            if (d == ScriptRuntime.NaN) {
-                return d;
-            }
-            if ((d == Double.POSITIVE_INFINITY) || (d == Double.NEGATIVE_INFINITY)) {
-                return Double.POSITIVE_INFINITY;
-            }
-            y += d * d;
-        }
-        return Math.sqrt(y);
-    }
-
-    private double js_trunc(double d)
-    {
-        return ((d < 0.0) ? Math.ceil(d) : Math.floor(d));
-    }
-
-    // From EcmaScript 6 section 20.2.2.19
-    private Object js_imul(Object[] args)
-    {
-        if ((args == null) || (args.length < 2)) {
-            return ScriptRuntime.wrapNumber(ScriptRuntime.NaN);
-        }
-
-        long x = Conversions.toUint32(args[0]);
-        long y = Conversions.toUint32(args[1]);
-        long product = (x * y) % Conversions.THIRTYTWO_BIT;
-        long result = (product >= (1L << 31L)) ? (product - Conversions.THIRTYTWO_BIT) : product;
-        return ScriptRuntime.toNumber(result);
-    }
-
 // #string_id_map#
 
     @Override
     protected int findPrototypeId(String s)
     {
         int id;
-// #generated# Last update: 2015-06-16 09:41:02 PDT
+// #generated# Last update: 2004-03-17 13:51:32 CET
         L0: { id = 0; String X = null; int c;
             L: switch (s.length()) {
             case 1: if (s.charAt(0)=='E') {id=Id_E; break L0;} break L;
@@ -404,13 +305,8 @@ final class NativeMath extends IdScriptableObject
                 } break L;
             case 4: switch (s.charAt(1)) {
                 case 'N': X="LN10";id=Id_LN10; break L;
-                case 'a': X="tanh";id=Id_tanh; break L;
-                case 'b': X="cbrt";id=Id_cbrt; break L;
                 case 'c': X="acos";id=Id_acos; break L;
                 case 'e': X="ceil";id=Id_ceil; break L;
-                case 'i': X="sinh";id=Id_sinh; break L;
-                case 'm': X="imul";id=Id_imul; break L;
-                case 'o': X="cosh";id=Id_cosh; break L;
                 case 'q': X="sqrt";id=Id_sqrt; break L;
                 case 's': X="asin";id=Id_asin; break L;
                 case 't': X="atan";id=Id_atan; break L;
@@ -419,15 +315,8 @@ final class NativeMath extends IdScriptableObject
                 case 'L': X="LOG2E";id=Id_LOG2E; break L;
                 case 'S': X="SQRT2";id=Id_SQRT2; break L;
                 case 'a': X="atan2";id=Id_atan2; break L;
-                case 'e': X="expm1";id=Id_expm1; break L;
                 case 'f': X="floor";id=Id_floor; break L;
-                case 'h': X="hypot";id=Id_hypot; break L;
-                case 'l': c=s.charAt(4);
-                    if (c=='0') { X="log10";id=Id_log10; }
-                    else if (c=='p') { X="log1p";id=Id_log1p; }
-                    break L;
                 case 'r': X="round";id=Id_round; break L;
-                case 't': X="trunc";id=Id_trunc; break L;
                 } break L;
             case 6: c=s.charAt(0);
                 if (c=='L') { X="LOG10E";id=Id_LOG10E; }
@@ -437,7 +326,6 @@ final class NativeMath extends IdScriptableObject
             case 8: X="toSource";id=Id_toSource; break L;
             }
             if (X!=null && X!=s && !X.equals(s)) id = 0;
-            break L0;
         }
 // #/generated#
         return id;
@@ -463,27 +351,8 @@ final class NativeMath extends IdScriptableObject
         Id_sin          = 17,
         Id_sqrt         = 18,
         Id_tan          = 19,
-        Id_cbrt         = 20,
-        Id_cosh         = 21,
-        Id_expm1        = 22,
-        Id_hypot        = 23,
-        Id_log1p        = 24,
-        Id_log10        = 25,
-        Id_sinh         = 26,
-        Id_tanh         = 27,
-        Id_imul         = 28,
-        Id_trunc        = 29,
 
-        LAST_METHOD_ID  = Id_trunc;
-
-/* Missing from ES6:
-    acosh
-    asinh
-    atanh
-    clz32
-    fround
-    log2
- */
+        LAST_METHOD_ID  = 19;
 
     private static final int
         Id_E            = LAST_METHOD_ID + 1,
diff --git a/src/org/mozilla/javascript/NativeNumber.java b/src/org/mozilla/javascript/NativeNumber.java
index 9a7100f..30114c8 100644
--- a/src/org/mozilla/javascript/NativeNumber.java
+++ b/src/org/mozilla/javascript/NativeNumber.java
@@ -20,8 +20,6 @@ final class NativeNumber extends IdScriptableObject
     private static final Object NUMBER_TAG = "Number";
 
     private static final int MAX_PRECISION = 100;
-    private static final double MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
-    private static final double MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;
 
     static void init(Scriptable scope, boolean sealed)
     {
@@ -60,19 +58,6 @@ final class NativeNumber extends IdScriptableObject
         ctor.defineProperty("MIN_VALUE",
                             ScriptRuntime.wrapNumber(Double.MIN_VALUE),
                             attr);
-        ctor.defineProperty("MAX_SAFE_INTEGER",
-                            ScriptRuntime.wrapNumber(MAX_SAFE_INTEGER),
-                            attr);
-        ctor.defineProperty("MIN_SAFE_INTEGER",
-                            ScriptRuntime.wrapNumber(MIN_SAFE_INTEGER),
-                            attr);
-
-        addIdFunctionProperty(ctor, NUMBER_TAG, ConstructorId_isFinite, "isFinite", 1);
-        addIdFunctionProperty(ctor, NUMBER_TAG, ConstructorId_isNaN, "isNaN", 1);
-        addIdFunctionProperty(ctor, NUMBER_TAG, ConstructorId_isInteger, "isInteger", 1);
-        addIdFunctionProperty(ctor, NUMBER_TAG, ConstructorId_isSafeInteger, "isSafeInteger", 1);
-        addIdFunctionProperty(ctor, NUMBER_TAG, ConstructorId_parseFloat, "parseFloat", 1);
-        addIdFunctionProperty(ctor, NUMBER_TAG, ConstructorId_parseInt, "parseInt", 1);
 
         super.fillConstructorProperties(ctor);
     }
@@ -113,9 +98,6 @@ final class NativeNumber extends IdScriptableObject
             }
             // Number(val) converts val to a number value.
             return ScriptRuntime.wrapNumber(val);
-
-        } else if (id < Id_constructor) {
-            return execConstructorCall(id, args);
         }
 
         // The rest of Number.prototype methods require thisObj to be Number
@@ -188,57 +170,6 @@ final class NativeNumber extends IdScriptableObject
         }
     }
 
-    private Object execConstructorCall(int id, Object[] args)
-    {
-        switch (id) {
-        case ConstructorId_isFinite:
-            if ((args.length == 0) || (Undefined.instance == args[0])) {
-                return false;
-            }
-            if (args[0] instanceof Number) {
-                // Match ES6 polyfill, which only works for "number" types
-                return isFinite(args[0]);
-            }
-            return false;
-
-        case ConstructorId_isNaN:
-            if ((args.length == 0) || (Undefined.instance == args[0])) {
-                return false;
-            }
-            if (args[0] instanceof Number) {
-                return isNaN((Number)args[0]);
-            }
-            return false;
-
-        case ConstructorId_isInteger:
-            if ((args.length == 0) || (Undefined.instance == args[0])) {
-                return false;
-            }
-            if (args[0] instanceof Number) {
-                return isInteger((Number)args[0]);
-            }
-            return false;
-
-        case ConstructorId_isSafeInteger:
-            if ((args.length == 0) || (Undefined.instance == args[0])) {
-                return false;
-            }
-            if (args[0] instanceof Number) {
-                return isSafeInteger((Number)args[0]);
-            }
-            return false;
-
-        case ConstructorId_parseFloat:
-            return NativeGlobal.js_parseFloat(args);
-
-        case ConstructorId_parseInt:
-            return NativeGlobal.js_parseInt(args);
-
-        default:
-            throw new IllegalArgumentException(String.valueOf(id));
-        }
-    }
-
     @Override
     public String toString() {
         return ScriptRuntime.numberToString(doubleValue, 10);
@@ -269,59 +200,6 @@ final class NativeNumber extends IdScriptableObject
         return sb.toString();
     }
 
-    static Object isFinite(Object val)
-    {
-        double d = ScriptRuntime.toNumber(val);
-        Double nd = Double.valueOf(d);
-        return ScriptRuntime.wrapBoolean(!nd.isInfinite() && !nd.isNaN());
-    }
-
-    private Object isNaN(Number val)
-    {
-        Double nd = doubleVal(val);
-        return ScriptRuntime.toBoolean(isDoubleNan(nd));
-    }
-
-    private boolean isDoubleNan(Double d)
-    {
-        return d.isNaN();
-    }
-
-    private boolean isInteger(Number val)
-    {
-        Double nd = doubleVal(val);
-        return ScriptRuntime.toBoolean(isDoubleInteger(nd));
-    }
-
-    private boolean isDoubleInteger(Double d)
-    {
-        return (!d.isInfinite() && !d.isNaN() &&
-                (Math.floor(d.doubleValue()) == d.doubleValue()));
-    }
-
-    private boolean isSafeInteger(Number val)
-    {
-        Double nd = doubleVal(val);
-        return ScriptRuntime.toBoolean(isDoubleSafeInteger(nd));
-    }
-
-    private boolean isDoubleSafeInteger(Double d)
-    {
-        return (isDoubleInteger(d) &&
-                (d.doubleValue() <= MAX_SAFE_INTEGER) &&
-                (d.doubleValue() >= MIN_SAFE_INTEGER));
-    }
-
-    private Double doubleVal(Number val)
-    {
-        if (val instanceof Double) {
-            return (Double)val;
-        } else {
-            double d = val.doubleValue();
-            return Double.valueOf(d);
-        }
-    }
-
 // #string_id_map#
 
     @Override
@@ -354,13 +232,6 @@ final class NativeNumber extends IdScriptableObject
     }
 
     private static final int
-        ConstructorId_isFinite       = -1,
-        ConstructorId_isNaN          = -2,
-        ConstructorId_isInteger      = -3,
-        ConstructorId_isSafeInteger  = -4,
-        ConstructorId_parseFloat     = -5,
-        ConstructorId_parseInt       = -6,
-
         Id_constructor           = 1,
         Id_toString              = 2,
         Id_toLocaleString        = 3,
diff --git a/src/org/mozilla/javascript/NativeObject.java b/src/org/mozilla/javascript/NativeObject.java
index b654b89..51d26fe 100644
--- a/src/org/mozilla/javascript/NativeObject.java
+++ b/src/org/mozilla/javascript/NativeObject.java
@@ -72,6 +72,8 @@ public class NativeObject extends IdScriptableObject implements Map
                 "seal", 1);
         addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_freeze,
                 "freeze", 1);
+        addIdFunctionProperty(ctor, OBJECT_TAG, ConstructorId_assign,
+                "assign", 2);
         super.fillConstructorProperties(ctor);
     }
 
@@ -258,21 +260,25 @@ public class NativeObject extends IdScriptableObject implements Map
                       else
                           break;
                   }
-                  if (gs != null)
+                  if (gs != null) {
+                	  if (gs instanceof MemberBox) {
+                		  gs = ((MemberBox) gs).asFunction(name, f.getParentScope(), f.getPrototype());
+                	  }
                       return gs;
+                  }
               }
               return Undefined.instance;
 
           case ConstructorId_getPrototypeOf:
               {
                 Object arg = args.length < 1 ? Undefined.instance : args[0];
-                Scriptable obj = getCompatibleObject(cx, scope, arg);
+                Scriptable obj = ensureScriptable(arg);
                 return obj.getPrototype();
               }
           case ConstructorId_keys:
               {
                 Object arg = args.length < 1 ? Undefined.instance : args[0];
-                Scriptable obj = getCompatibleObject(cx, scope, arg);
+                Scriptable obj = ensureScriptable(arg);
                 Object[] ids = obj.getIds();
                 for (int i = 0; i < ids.length; i++) {
                   ids[i] = ScriptRuntime.toString(ids[i]);
@@ -282,8 +288,7 @@ public class NativeObject extends IdScriptableObject implements Map
           case ConstructorId_getOwnPropertyNames:
               {
                 Object arg = args.length < 1 ? Undefined.instance : args[0];
-                Scriptable s = getCompatibleObject(cx, scope, arg);
-                ScriptableObject obj = ensureScriptableObject(s);
+                ScriptableObject obj = ensureScriptableObject(arg);
                 Object[] ids = obj.getAllIds();
                 for (int i = 0; i < ids.length; i++) {
                   ids[i] = ScriptRuntime.toString(ids[i]);
@@ -296,8 +301,7 @@ public class NativeObject extends IdScriptableObject implements Map
                 // TODO(norris): There's a deeper issue here if
                 // arg instanceof Scriptable. Should we create a new
                 // interface to admit the new ECMAScript 5 operations?
-                Scriptable s = getCompatibleObject(cx, scope, arg);
-                ScriptableObject obj = ensureScriptableObject(s);
+                ScriptableObject obj = ensureScriptableObject(arg);
                 Object nameArg = args.length < 2 ? Undefined.instance : args[1];
                 String name = ScriptRuntime.toString(nameArg);
                 Scriptable desc = obj.getOwnPropertyDescriptor(cx, name);
@@ -416,6 +420,19 @@ public class NativeObject extends IdScriptableObject implements Map
 
                 return obj;
               }
+          case ConstructorId_assign:
+              {
+                  ScriptableObject target = ensureScriptableObject(args[0]);
+                  for (int i = 1; i < args.length; i++) {
+                      if (args[i] != Undefined.instance) {
+                          ScriptableObject obj = ensureScriptableObject(args[i]);
+                          for (Object objId : obj.getIds()) {
+                              target.defineOwnProperty(cx, objId, obj.getOwnPropertyDescriptor(cx, objId));
+                          }
+                      }
+                  }
+                  return target;
+              }
 
 
           default:
@@ -423,15 +440,6 @@ public class NativeObject extends IdScriptableObject implements Map
         }
     }
 
-    private Scriptable getCompatibleObject(Context cx, Scriptable scope, Object arg)
-    {
-        if (cx.getLanguageVersion() >= Context.VERSION_ES6) {
-            Scriptable s = ScriptRuntime.toObject(cx, scope, arg);
-            return ensureScriptable(s);
-        }
-        return ensureScriptable(arg);
-    }
-
     // methods implementing java.util.Map
 
     public boolean containsKey(Object key) {
@@ -682,12 +690,13 @@ public class NativeObject extends IdScriptableObject implements Map
         ConstructorId_defineProperty = -5,
         ConstructorId_isExtensible = -6,
         ConstructorId_preventExtensions = -7,
-        ConstructorId_defineProperties= -8,
+        ConstructorId_defineProperties = -8,
         ConstructorId_create = -9,
         ConstructorId_isSealed = -10,
         ConstructorId_isFrozen = -11,
         ConstructorId_seal = -12,
         ConstructorId_freeze = -13,
+        ConstructorId_assign = -14,
 
         Id_constructor           = 1,
         Id_toString              = 2,
diff --git a/src/org/mozilla/javascript/NativeString.java b/src/org/mozilla/javascript/NativeString.java
index d8766f9..43276ba 100644
--- a/src/org/mozilla/javascript/NativeString.java
+++ b/src/org/mozilla/javascript/NativeString.java
@@ -11,9 +11,8 @@ import org.mozilla.javascript.regexp.NativeRegExp;
 import java.text.Collator;
 import java.text.Normalizer;
 
-import static org.mozilla.javascript.NativeSymbol.ITERATOR_PROPERTY;
 import static org.mozilla.javascript.ScriptRuntime.rangeError;
-import static org.mozilla.javascript.ScriptRuntimeES6.requireObjectCoercible;
+import static org.mozilla.javascript.ScriptRuntime.requireObjectCoercible;
 
 /**
  * This class implements the String native object.
@@ -128,7 +127,7 @@ final class NativeString extends IdScriptableObject
     @Override
     protected void initPrototypeId(int id)
     {
-        String s, fnName = null;
+        String s;
         int arity;
         switch (id) {
           case Id_constructor:       arity=1; s="constructor";       break;
@@ -176,10 +175,9 @@ final class NativeString extends IdScriptableObject
           case Id_normalize:         arity=0; s="normalize";         break;
           case Id_repeat:            arity=1; s="repeat";            break;
           case Id_codePointAt:       arity=1; s="codePointAt";       break;
-          case Id_iterator:          arity=0; s= ITERATOR_PROPERTY; fnName="[Symbol.iterator]"; break;
           default: throw new IllegalArgumentException(String.valueOf(id));
         }
-        initPrototypeMethod(STRING_TAG, id, s, fnName, arity);
+        initPrototypeMethod(STRING_TAG, id, s, arity);
     }
 
     @Override
@@ -278,7 +276,8 @@ final class NativeString extends IdScriptableObject
                 case Id_includes:
                 case Id_startsWith:
                 case Id_endsWith:
-                    String s = ScriptRuntime.toString(requireObjectCoercible(cx, thisObj, f));
+                    String s = ScriptRuntime.toString(requireObjectCoercible(thisObj, f));
+
                     if (args.length > 0 && args[0] instanceof NativeRegExp) {
                         throw ScriptRuntime.typeError2("msg.first.arg.not.regexp", String.class.getSimpleName(), f.getFunctionName());
                     }
@@ -408,7 +407,7 @@ final class NativeString extends IdScriptableObject
                         .toUpperCase(cx.getLocale());
                 }
                 case Id_trim: {
-                    String str = ScriptRuntime.toString(requireObjectCoercible(cx, thisObj, f));
+                    String str = ScriptRuntime.toString(thisObj);
                     char[] chars = str.toCharArray();
 
                     int start = 0;
@@ -448,8 +447,7 @@ final class NativeString extends IdScriptableObject
 
                     return str.substring(start, end);
                 }
-                case Id_normalize:
-                {
+                case Id_normalize: {
                     String formStr = ScriptRuntime.toString(args, 0);
 
                     Normalizer.Form form;
@@ -459,26 +457,47 @@ final class NativeString extends IdScriptableObject
                     else if (Normalizer.Form.NFC.name().equals(formStr) || args.length == 0) form = Normalizer.Form.NFC;
                     else throw rangeError("The normalization form should be one of NFC, NFD, NFKC, NFKD");
 
-                    return Normalizer.normalize(ScriptRuntime.toString(requireObjectCoercible(cx, thisObj, f)), form);
+                    return Normalizer.normalize(ScriptRuntime.toString(requireObjectCoercible(thisObj, f)), form);
                 }
 
                 case Id_repeat:
                 {
-                    return js_repeat(cx, thisObj, f, args);
+                    String str = ScriptRuntime.toString(requireObjectCoercible(thisObj, f));
+                    double cnt = ScriptRuntime.toInteger(args, 0);
+
+                    if (cnt == 0) {
+                        return "";
+                    }
+
+                    if (cnt < 0 || cnt == Double.POSITIVE_INFINITY) throw rangeError("Invalid count value");
+
+                    long size = str.length() * (long) cnt;
+                    // Check for overflow
+                    if (cnt >= Integer.MAX_VALUE || size >= Integer.MAX_VALUE) {
+                        size = Integer.MAX_VALUE;
+                    }
+
+                    StringBuilder retval = new StringBuilder((int) size);
+                    retval.append(str);
+
+                    int i = 1;
+                    while (i <= cnt/2) {
+                        retval.append(retval);
+                        i *= 2;
+                    }
+                    while (i++ < cnt) retval.append(str);
+
+                    return retval.toString();
                 }
                 case Id_codePointAt:
                 {
-                    String str = ScriptRuntime.toString(requireObjectCoercible(cx, thisObj, f));
+                    String str = ScriptRuntime.toString(requireObjectCoercible(thisObj, f));
                     double cnt = ScriptRuntime.toInteger(args, 0);
 
                     return (cnt < 0 || cnt >= str.length())
                         ? Undefined.instance
                         : str.codePointAt((int) cnt);
                 }
-
-              case Id_iterator:
-                  return new NativeStringIterator(scope, thisObj);
-
             }
             throw new IllegalArgumentException("String.prototype has no method: " + f.getFunctionName());
         }
@@ -544,24 +563,6 @@ final class NativeString extends IdScriptableObject
         super.put(index, start, value);
     }
 
-    @Override
-    public Object[] getAllIds()
-    {
-        // In ES6, Strings have entries in the property map for each character.
-        Context cx = Context.getCurrentContext();
-        if ((cx != null) && (cx.getLanguageVersion() >= Context.VERSION_ES6)) {
-            Object[] sids = super.getAllIds();
-            Object[] a = new Object[sids.length + string.length()];
-            int i;
-            for (i = 0; i < string.length(); i++) {
-                a[i] = Integer.valueOf(i);
-            }
-            System.arraycopy(sids, 0, a, i, sids.length);
-            return a;
-        }
-        return super.getAllIds();
-    }
-
     /*
      *
      * See ECMA 15.5.4.6.  Uses Java String.indexOf()
@@ -740,41 +741,6 @@ final class NativeString extends IdScriptableObject
         return target.subSequence((int) begin, (int) end);
     }
 
-    private static String js_repeat(Context cx, Scriptable thisObj, IdFunctionObject f, Object[] args)
-    {
-        String str = ScriptRuntime.toString(requireObjectCoercible(cx, thisObj, f));
-        double cnt = ScriptRuntime.toInteger(args, 0);
-
-        if ((cnt < 0.0) || (cnt == Double.POSITIVE_INFINITY)) {
-            throw rangeError("Invalid count value");
-        }
-
-        if (cnt == 0.0 || str.length() == 0) {
-            return "";
-        }
-
-        long size = str.length() * (long)cnt;
-        // Check for overflow
-        if ((cnt > Integer.MAX_VALUE) || (size > Integer.MAX_VALUE)) {
-            throw rangeError("Invalid size or count value");
-        }
-
-        StringBuilder retval = new StringBuilder((int) size);
-        retval.append(str);
-
-        int i = 1;
-        int icnt = (int)cnt;
-        while (i <= (icnt / 2)) {
-            retval.append(retval);
-            i *= 2;
-        }
-        if (i < icnt) {
-            retval.append(retval.substring(0, str.length() * (icnt - i)));
-        }
-
-        return retval.toString();
-    }
-
 // #string_id_map#
 
     @Override
@@ -837,7 +803,6 @@ final class NativeString extends IdScriptableObject
             case 10: c=s.charAt(0);
                 if (c=='c') { X="charCodeAt";id=Id_charCodeAt; }
                 else if (c=='s') { X="startsWith";id=Id_startsWith; }
-                else if (c=='@') { X="@@iterator";id=Id_iterator; }
                 break L;
             case 11: switch (s.charAt(2)) {
                 case 'L': X="toLowerCase";id=Id_toLowerCase; break L;
@@ -908,8 +873,7 @@ final class NativeString extends IdScriptableObject
         Id_normalize                 = 43,
         Id_repeat                    = 44,
         Id_codePointAt               = 45,
-        Id_iterator                  = 46,
-        MAX_PROTOTYPE_ID             = Id_iterator;
+        MAX_PROTOTYPE_ID             = Id_codePointAt;
 
 // #/string_id_map#
 
diff --git a/src/org/mozilla/javascript/NativeStringIterator.java b/src/org/mozilla/javascript/NativeStringIterator.java
deleted file mode 100644
index 065b2d2..0000000
--- a/src/org/mozilla/javascript/NativeStringIterator.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript;
-
-public final class NativeStringIterator extends ES6Iterator {
-    private static final long serialVersionUID = 1L;
-    private static final String ITERATOR_TAG = "StringIterator";
-
-    static void init(ScriptableObject scope, boolean sealed) {
-        ES6Iterator.init(scope, sealed, new NativeStringIterator(), ITERATOR_TAG);
-    }
-
-    /**
-     * Only for constructing the prototype object.
-     */
-    private NativeStringIterator() {
-        super();
-    }
-
-    NativeStringIterator(Scriptable scope, Scriptable stringLike) {
-        super(scope);
-        this.index = 0;
-        this.string  = ScriptRuntime.toString(stringLike);
-    }
-
-    @Override
-    public String getClassName() {
-        return "String Iterator";
-    }
-
-    @Override
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeMath.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeNumber.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeObject.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NativeString.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Node.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/NodeTransformer.java.
The file will have its original line endings in your working directory.
-    protected boolean isDone(Context cx, Scriptable scope) {
-        return index >= string.length();
-    }
-
-    @Override
-    protected Object nextValue(Context cx, Scriptable scope) {
-        int newIndex = string.offsetByCodePoints(index, 1);
-        Object value = string.substring(index, newIndex);
-        index = newIndex;
-        return value;
-    }
-
-    @Override
-    protected String getTag() {
-        return ITERATOR_TAG;
-    }
-
-    private String string;
-    private int index;
-}
diff --git a/src/org/mozilla/javascript/NativeSymbol.java b/src/org/mozilla/javascript/NativeSymbol.java
deleted file mode 100644
index 3c76cfd..0000000
--- a/src/org/mozilla/javascript/NativeSymbol.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript;
-
-public class NativeSymbol extends IdScriptableObject {
-
-    public static final String SPECIES_PROPERTY = "@@species";
-    public static final String ITERATOR_PROPERTY = "@@iterator";
-    public static final String TO_STRING_TAG_PROPERTY = "@@toStringTag";
-
-    public static final String CLASS_NAME = "Symbol";
-
-    public static void init(Context cx, Scriptable scope, boolean sealed) {
-        NativeSymbol obj = new NativeSymbol();
-        obj.exportAsJSClass(MAX_PROTOTYPE_ID, scope, sealed);
-    }
-
-    private NativeSymbol() {
-    }
-
-    @Override
-    public String getClassName() {
-        return CLASS_NAME;
-    }
-
-    @Override
-    protected void fillConstructorProperties(IdFunctionObject ctor) {
-        super.fillConstructorProperties(ctor);
-        ctor.defineProperty("iterator", ITERATOR_PROPERTY, DONTENUM | READONLY | PERMANENT);
-        ctor.defineProperty("species", SPECIES_PROPERTY, DONTENUM | READONLY | PERMANENT);
-        ctor.defineProperty("toStringTag", TO_STRING_TAG_PROPERTY, DONTENUM | READONLY | PERMANENT);
-    }
-
-    // #string_id_map#
-
-    @Override
-    protected int findPrototypeId(String s) {
-        int id = 0;
-// #generated# Last update: 2015-06-07 10:40:05 EEST
-        L0: { id = 0; String X = null;
-            if (s.length()==11) { X="constructor";id=Id_constructor; }
-            if (X!=null && X!=s && !X.equals(s)) id = 0;
-            break L0;
-        }
-// #/generated#
-        return id;
-    }
-
-    private static final int
-        Id_constructor          = 1,
-        MAX_PROTOTYPE_ID        = Id_constructor;
-
-    // #/string_id_map#
-
-
-    @Override
-    protected void initPrototypeId(int id)
-    {
-        String s = null;
-        int arity = -1;
-        switch (id) {
-            case Id_constructor:        arity = 0; s = "constructor"; break;
-            default:                    super.initPrototypeId(id);
-        }
-        initPrototypeMethod(CLASS_NAME, id, s, arity);
-    }
-
-    @Override
-    public Object execIdCall(IdFunctionObject f, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
-        if (!f.hasTag(CLASS_NAME)) {
-            return super.execIdCall(f, cx, scope, thisObj, args);
-        }
-        int id = f.methodId();
-        switch (id) {
-            case Id_constructor:
-                return new NativeSymbol();
-        }
-        return super.execIdCall(f, cx, scope, thisObj, args);
-
-    }
-
-    @Override
-    public String getTypeOf() {
-        return "symbol";
-    }
-}
diff --git a/src/org/mozilla/javascript/Node.java b/src/org/mozilla/javascript/Node.java
index 62ace50..5e276e6 100644
--- a/src/org/mozilla/javascript/Node.java
+++ b/src/org/mozilla/javascript/Node.java
@@ -63,8 +63,7 @@ public class Node implements Iterable<Node>
         JSDOC_PROP           = 24,
         EXPRESSION_CLOSURE_PROP = 25, // JS 1.8 expression closure pseudo-return
         DESTRUCTURING_SHORTHAND = 26, // JS 1.8 destructuring shorthand
-        ARROW_FUNCTION_PROP  = 27,
-        LAST_PROP            = 27;
+        LAST_PROP            = 26;
 
     // values of ISNUMBER_PROP to specify
     // which of the children are Number types
diff --git a/src/org/mozilla/javascript/NodeTransformer.java b/src/org/mozilla/javascript/NodeTransformer.java
index 6d45bd9..28064c5 100644
--- a/src/org/mozilla/javascript/NodeTransformer.java
+++ b/src/org/mozilla/javascript/NodeTransformer.java
@@ -6,15 +6,16 @@
 
 package org.mozilla.javascript;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.mozilla.javascript.ast.AstRoot;
 import org.mozilla.javascript.ast.FunctionNode;
 import org.mozilla.javascript.ast.Jump;
+import org.mozilla.javascript.ast.Name;
 import org.mozilla.javascript.ast.Scope;
 import org.mozilla.javascript.ast.ScriptNode;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * This class transforms a tree to a lower-level representation for codegen.
  *
@@ -31,20 +32,14 @@ public class NodeTransformer
 
     public final void transform(ScriptNode tree)
     {
-        transform(tree, false);
-    }
-
-    public final void transform(ScriptNode tree, boolean inStrictMode)
-    {
-        inStrictMode = inStrictMode || tree.isInStrictMode();
-        transformCompilationUnit(tree, inStrictMode);
+        transformCompilationUnit(tree);
         for (int i = 0; i != tree.getFunctionCount(); ++i) {
             FunctionNode fn = tree.getFunctionNode(i);
-            transform(fn, inStrictMode);
+            transform(fn);
         }
     }
 
-    private void transformCompilationUnit(ScriptNode tree, boolean inStrictMode)
+    private void transformCompilationUnit(ScriptNode tree)
     {
         loops = new ObjArray();
         loopEnds = new ObjArray();
@@ -59,6 +54,8 @@ public class NodeTransformer
 
         //uncomment to print tree before transformation
         if (Token.printTrees) System.out.println(tree.toStringTree(tree));
+        boolean inStrictMode = tree instanceof AstRoot &&
+                               ((AstRoot)tree).isInStrictMode();
         transformCompilationUnit_r(tree, tree, tree, createScopeObjects,
                                    inStrictMode);
     }
@@ -69,6 +66,34 @@ public class NodeTransformer
                                             boolean createScopeObjects,
                                             boolean inStrictMode)
     {
+        if (parent instanceof Scope
+                && Context.getContext().hasFeature(Context.FEATURE_HTMLUNIT_FUNCTION_DECLARED_FORWARD_IN_BLOCK)) {
+            // Make sure that all "Name" children are at the start of all siblings
+            Node lastInitialName = null;
+            boolean initial = true;
+            Node node = parent.getFirstChild();
+            while (node != null) {
+                if (node instanceof Name) {
+                    if (initial) {
+                        lastInitialName =  node;
+                    }
+                    else {
+                        parent.removeChild(node);
+                        if (lastInitialName == null)  {
+                            parent.addChildToFront(node);
+                        }
+                        else {
+                            parent.addChildAfter(node, lastInitialName);
+                        }
+                        lastInitialName = node;
+                    }
+                }
+                else {
+                    initial = false;
+                }
+                node = node.getNext();
+            }
+        }
         Node node = null;
       siblingLoop:
         for (;;) {
diff --git a/src/org/mozilla/javascript/Parser.java b/src/org/mozilla/javascript/Parser.java
index d5dda69..73bfc55 100644
--- a/src/org/mozilla/javascript/Parser.java
+++ b/src/org/mozilla/javascript/Parser.java
@@ -93,8 +93,6 @@ public class Parser
     private String prevNameTokenString = "";
     private int prevNameTokenLineno;
 
-    private boolean defaultUseStrictDirective;
-
     // Exception to unwind
     private static class ParserException extends RuntimeException
     {
@@ -255,7 +253,7 @@ public class Parser
     void reportError(String messageId, String messageArg, int position,
                      int length)
     {
-        addError(messageId, messageArg, position, length);
+        addError(messageId, position, length);
 
         if (!compilerEnv.recoverFromErrors()) {
             throw new ParserException();
@@ -551,11 +549,8 @@ public class Parser
 
         boolean inDirectivePrologue = true;
         boolean savedStrictMode = inUseStrictDirective;
-
-        inUseStrictDirective = defaultUseStrictDirective;
-        if (inUseStrictDirective) {
-            root.setInStrictMode(true);
-        }
+        // TODO: eval code should get strict mode from invoking code
+        inUseStrictDirective = false;
 
         try {
             for (;;) {
@@ -571,6 +566,17 @@ public class Parser
                         n = function(calledByCompileFunction
                                      ? FunctionNode.FUNCTION_EXPRESSION
                                      : FunctionNode.FUNCTION_STATEMENT);
+                        FunctionNode functionNode = (FunctionNode) n;
+                        if (functionNode.getName().indexOf('.') != -1) {
+                            String functionName = functionNode.getName();
+                            String left = functionName.substring(0,  functionName.indexOf('.'));
+                            String right = functionName.substring(functionName.indexOf('.') + 1);
+                            PropertyGet propertyGet = new PropertyGet(new Name(0, left), new Name(0, right));
+                            Assignment assignment = new Assignment(Token.ASSIGN, propertyGet, functionNode, -1);
+                            functionNode.setFunctionName(null);
+                            functionNode.setFunctionType(FunctionNode.FUNCTION_EXPRESSION);
+                            n = new ExpressionStatement(assignment, !insideFunction());
+                        }
                     } catch (ParserException e) {
                         break;
                     }
@@ -626,18 +632,17 @@ public class Parser
         return root;
     }
 
-    private AstNode parseFunctionBody(int type, FunctionNode fnNode)
+    private AstNode parseFunctionBody()
         throws IOException
     {
         boolean isExpressionClosure = false;
         if (!matchToken(Token.LC)) {
-            if (compilerEnv.getLanguageVersion() < Context.VERSION_1_8 && type != FunctionNode.ARROW_FUNCTION) {
+            if (compilerEnv.getLanguageVersion() < Context.VERSION_1_8) {
                 reportError("msg.no.brace.body");
             } else {
                 isExpressionClosure = true;
             }
         }
-        boolean isArrow = type == FunctionNode.ARROW_FUNCTION;
         ++nestingOfFunction;
         int pos = ts.tokenBeg;
         Block pn = new Block(pos);  // starts at LC position
@@ -654,9 +659,6 @@ public class Parser
                 // expression closure flag is required on both nodes
                 n.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);
                 pn.putProp(Node.EXPRESSION_CLOSURE_PROP, Boolean.TRUE);
-                if (isArrow) {
-                    n.putProp(Node.ARROW_FUNCTION_PROP, Boolean.TRUE);
-                }
                 pn.addStatement(n);
             } else {
                 bodyLoop: for (;;) {
@@ -680,10 +682,6 @@ public class Parser
                                     inDirectivePrologue = false;
                                 } else if (directive.equals("use strict")) {
                                     inUseStrictDirective = true;
-                                    fnNode.setInStrictMode(true);
-                                    if (!savedStrictMode) {
-                                        setRequiresActivation();
-                                    }
                                 }
                             }
                             break;
@@ -798,12 +796,19 @@ public class Parser
                 }
             }
             if (!matchToken(Token.LP)) {
-                if (compilerEnv.isAllowMemberExprAsFunctionName()) {
-                    AstNode memberExprHead = name;
-                    name = null;
-                    memberExprNode = memberExprTail(false, memberExprHead);
+                if (Context.getContext().hasFeature(Context.FEATURE_HTMLUNIT_FUNCTION_OBJECT_METHOD)
+                        && matchToken(Token.DOT) && matchToken(Token.NAME)) {
+                    name.setIdentifier(name.getIdentifier() + '.' + createNameNode(true, Token.NAME).getIdentifier());
+                    mustMatchToken(Token.LP, "msg.no.paren.parms");
+                }
+                else {
+                    if (compilerEnv.isAllowMemberExprAsFunctionName()) {
+                        AstNode memberExprHead = name;
+                        name = null;
+                        memberExprNode = memberExprTail(false, memberExprHead);
+                    }
+                    mustMatchToken(Token.LP, "msg.no.paren.parms");
                 }
-                mustMatchToken(Token.LP, "msg.no.paren.parms");
             }
         } else if (matchToken(Token.LP)) {
             // Anonymous function:  leave name as null
@@ -838,7 +843,7 @@ public class Parser
         PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);
         try {
             parseFunctionParams(fnNode);
-            fnNode.setBody(parseFunctionBody(type, fnNode));
+            fnNode.setBody(parseFunctionBody());
             fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);
             fnNode.setLength(ts.tokenEnd - functionSourceStart);
 
@@ -882,93 +887,6 @@ public class Parser
         return fnNode;
     }
 
-    private AstNode arrowFunction(AstNode params) throws IOException {
-        int baseLineno = ts.lineno;  // line number where source starts
-        int functionSourceStart = params != null ? params.getPosition() : -1;  // start of "function" kwd
-
-        FunctionNode fnNode = new FunctionNode(functionSourceStart);
-        fnNode.setFunctionType(FunctionNode.ARROW_FUNCTION);
-        fnNode.setJsDocNode(getAndResetJsDoc());
-
-        // Would prefer not to call createDestructuringAssignment until codegen,
-        // but the symbol definitions have to happen now, before body is parsed.
-        Map<String, Node> destructuring = new HashMap<String, Node>();
-        Set<String> paramNames = new HashSet<String>();
-
-        PerFunctionVariables savedVars = new PerFunctionVariables(fnNode);
-        try {
-            if (params instanceof ParenthesizedExpression) {
-                fnNode.setParens(0, params.getLength());
-                AstNode p = ((ParenthesizedExpression)params).getExpression();
-                if (!(p instanceof EmptyExpression)) {
-                    arrowFunctionParams(fnNode, p, destructuring, paramNames);
-                }
-            } else {
-                arrowFunctionParams(fnNode, params, destructuring, paramNames);
-            }
-
-            if (!destructuring.isEmpty()) {
-                Node destructuringNode = new Node(Token.COMMA);
-                // Add assignment helper for each destructuring parameter
-                for (Map.Entry<String, Node> param: destructuring.entrySet()) {
-                    Node assign = createDestructuringAssignment(Token.VAR,
-                                                                param.getValue(), createName(param.getKey()));
-                    destructuringNode.addChildToBack(assign);
-
-                }
-                fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode);
-            }
-                
-            fnNode.setBody(parseFunctionBody(FunctionNode.ARROW_FUNCTION, fnNode));
-            fnNode.setEncodedSourceBounds(functionSourceStart, ts.tokenEnd);
-            fnNode.setLength(ts.tokenEnd - functionSourceStart);
-        } finally {
-            savedVars.restore();
-        }
-
-        if (fnNode.isGenerator()) {
-            reportError("msg.arrowfunction.generator");
-            return makeErrorNode();
-        }
-
-        fnNode.setSourceName(sourceURI);
-        fnNode.setBaseLineno(baseLineno);
-        fnNode.setEndLineno(ts.lineno);
-
-        return fnNode;
-    }
-
-    private void arrowFunctionParams(FunctionNode fnNode, AstNode params, Map<String, Node> destructuring, Set<String> paramNames) {
-        if (params instanceof ArrayLiteral || params instanceof ObjectLiteral) {
-            markDestructuring(params);
-            fnNode.addParam(params);
-            String pname = currentScriptOrFn.getNextTempName();
-            defineSymbol(Token.LP, pname, false);
-            destructuring.put(pname, params);
-        } else if (params instanceof InfixExpression && params.getType() == Token.COMMA) {
-            arrowFunctionParams(fnNode, ((InfixExpression)params).getLeft(), destructuring, paramNames);
-            arrowFunctionParams(fnNode, ((InfixExpression)params).getRight(), destructuring, paramNames);
-        } else if (params instanceof Name) {
-            fnNode.addParam(params);
-            String paramName = ((Name)params).getIdentifier();
-            defineSymbol(Token.LP, paramName);
-
-            if (this.inUseStrictDirective) {
-                if ("eval".equals(paramName) ||
-                    "arguments".equals(paramName))
-                    {
-                        reportError("msg.bad.id.strict", paramName);
-                    }
-                if (paramNames.contains(paramName))
-                    addError("msg.dup.param.strict", paramName);
-                paramNames.add(paramName);
-            }
-        } else {
-            reportError("msg.no.parm", params.getPosition(), params.getLength());
-            fnNode.addParam(makeErrorNode());
-        }
-    }
-
     // This function does not match the closing RC: the caller matches
     // the RC so it can provide a suitable error message if not matched.
     // This means it's up to the caller to set the length of the node to
@@ -1360,7 +1278,7 @@ public class Parser
         if (currentToken != Token.FOR) codeBug();
         consumeToken();
         int forPos = ts.tokenBeg, lineno = ts.lineno;
-        boolean isForEach = false, isForIn = false, isForOf = false;
+        boolean isForEach = false, isForIn = false;
         int eachPos = -1, inPos = -1, lp = -1, rp = -1;
         AstNode init = null;  // init is also foo in 'foo in object'
         AstNode cond = null;  // cond is also object in 'foo in object'
@@ -1385,15 +1303,11 @@ public class Parser
             int tt = peekToken();
 
             init = forLoopInit(tt);
+
             if (matchToken(Token.IN)) {
                 isForIn = true;
                 inPos = ts.tokenBeg - forPos;
                 cond = expr();  // object over which we're iterating
-            } else if (compilerEnv.getLanguageVersion() >= Context.VERSION_ES6 &&
-                       matchToken(Token.NAME) && "of".equals(ts.getString())) {
-                isForOf = true;
-                inPos = ts.tokenBeg - forPos;
-                cond = expr();  // object over which we're iterating
             } else {  // ordinary for-loop
                 mustMatchToken(Token.SEMI, "msg.no.semi.for");
                 if (peekToken() == Token.SEMI) {
@@ -1417,7 +1331,7 @@ public class Parser
             if (mustMatchToken(Token.RP, "msg.no.paren.for.ctrl"))
                 rp = ts.tokenBeg - forPos;
 
-            if (isForIn || isForOf) {
+            if (isForIn) {
                 ForInLoop fis = new ForInLoop(forPos);
                 if (init instanceof VariableDeclaration) {
                     // check that there was only one variable given
@@ -1425,15 +1339,11 @@ public class Parser
                         reportError("msg.mult.index");
                     }
                 }
-                if (isForOf && isForEach) {
-                    reportError("msg.invalid.for.each");
-                }
                 fis.setIterator(init);
                 fis.setIteratedObject(cond);
                 fis.setInPosition(inPos);
                 fis.setIsForEach(isForEach);
                 fis.setEachPosition(eachPos);
-                fis.setIsForOf(isForOf);
                 pn = fis;
             } else {
                 ForLoop fl = new ForLoop(forPos);
@@ -2172,12 +2082,7 @@ public class Parser
             return returnOrYield(tt, true);
         }
         AstNode pn = condExpr();
-        boolean hasEOL = false;
-        tt = peekTokenOrEOL();
-        if (tt == Token.EOL) {
-            hasEOL = true;
-            tt = peekToken();
-        }
+        tt = peekToken();
         if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {
             consumeToken();
 
@@ -2198,9 +2103,6 @@ public class Parser
             if (currentJsDocComment != null) {
                 pn.setJsDocNode(getAndResetJsDoc());
             }
-        } else if (!hasEOL && tt == Token.ARROW) {
-            consumeToken();
-            pn = arrowFunction(pn);
         }
         return pn;
     }
@@ -2718,7 +2620,7 @@ public class Parser
             int maybeName = nextToken();
             if (maybeName != Token.NAME
                     && !(compilerEnv.isReservedKeywordAsIdentifier()
-                    && TokenStream.isKeyword(ts.getString(), compilerEnv.getLanguageVersion(), inUseStrictDirective))) {
+                    && TokenStream.isKeyword(ts.getString()))) {
               reportError("msg.no.name.after.dot");
             }
 
@@ -2755,13 +2657,6 @@ public class Parser
               ref = attributeAccess();
               break;
 
-          case Token.RESERVED: {
-              String name = ts.getString();
-              saveNameTokenData(ts.tokenBeg, name, ts.lineno);
-              ref = propertyName(-1, name, memberTypeFlags);
-              break;
-          }
-
           default:
               if (compilerEnv.isReservedKeywordAsIdentifier()) {
                   // allow keywords as property names, e.g. ({if: 1})
@@ -2921,53 +2816,39 @@ public class Parser
     private AstNode primaryExpr()
         throws IOException
     {
-        int ttFlagged = peekFlaggedToken();
+        int ttFlagged = nextFlaggedToken();
         int tt = ttFlagged & CLEAR_TI_MASK;
 
         switch(tt) {
           case Token.FUNCTION:
-              consumeToken();
               return function(FunctionNode.FUNCTION_EXPRESSION);
 
           case Token.LB:
-              consumeToken();
               return arrayLiteral();
 
           case Token.LC:
-              consumeToken();
               return objectLiteral();
 
           case Token.LET:
-              consumeToken();
               return let(false, ts.tokenBeg);
 
           case Token.LP:
-              consumeToken();
               return parenExpr();
 
           case Token.XMLATTR:
-              consumeToken();
               mustHaveXML();
               return attributeAccess();
 
           case Token.NAME:
-              consumeToken();
               return name(ttFlagged, tt);
 
           case Token.NUMBER: {
-              consumeToken();
               String s = ts.getString();
-              if (this.inUseStrictDirective && ts.isNumberOldOctal()) {
-                  reportError("msg.no.old.octal.strict");
-              }
-              if (ts.isNumberBinary()) {
-                  s = "0b"+s;
-              }
-              if (ts.isNumberOldOctal()) {
-                  s = "0"+s;
+              if (this.inUseStrictDirective && ts.isNumberOctal()) {
+                  reportError("msg.no.octal.strict");
               }
               if (ts.isNumberOctal()) {
-                  s = "0o"+s;
+                  s = "0"+s;
               }
               if (ts.isNumberHex()) {
                   s = "0x"+s;
@@ -2978,12 +2859,10 @@ public class Parser
           }
 
           case Token.STRING:
-              consumeToken();
               return createStringLiteral();
 
           case Token.DIV:
           case Token.ASSIGN_DIV:
-              consumeToken();
               // Got / or /= which in this context means a regexp
               ts.readRegExp(tt);
               int pos = ts.tokenBeg, end = ts.tokenEnd;
@@ -2996,35 +2875,26 @@ public class Parser
           case Token.THIS:
           case Token.FALSE:
           case Token.TRUE:
-              consumeToken();
               pos = ts.tokenBeg; end = ts.tokenEnd;
               return new KeywordLiteral(pos, end - pos, tt);
 
-          case Token.RP:
-              return new EmptyExpression();
-
           case Token.RESERVED:
-              consumeToken();
               reportError("msg.reserved.id");
               break;
 
           case Token.ERROR:
-              consumeToken();
               // the scanner or one of its subroutines reported the error.
               break;
 
           case Token.EOF:
-              consumeToken();
               reportError("msg.unexpected.eof");
               break;
 
           default:
-              consumeToken();
               reportError("msg.syntax");
               break;
         }
         // should only be reachable in IDE/error-recovery mode
-        consumeToken();
         return makeErrorNode();
     }
 
@@ -3047,10 +2917,6 @@ public class Parser
                 pn.setJsDocNode(jsdocNode);
             }
             mustMatchToken(Token.RP, "msg.no.paren");
-            if (e.getType() == Token.EMPTY && peekToken() != Token.ARROW) {
-              reportError("msg.syntax");
-              return makeErrorNode();
-            }
             pn.setLength(ts.tokenEnd - pn.getPosition());
             pn.setLineno(lineno);
             return pn;
@@ -3182,7 +3048,6 @@ public class Parser
         if (nextToken() != Token.FOR) codeBug();
         int pos = ts.tokenBeg;
         int eachPos = -1, lp = -1, rp = -1, inPos = -1;
-        boolean isForIn = false, isForOf = false;
         ArrayComprehensionLoop pn = new ArrayComprehensionLoop(pos);
 
         pushScope(pn);
@@ -3220,23 +3085,8 @@ public class Parser
                 defineSymbol(Token.LET, ts.getString(), true);
             }
 
-            switch (nextToken()) {
-            case Token.IN:
+            if (mustMatchToken(Token.IN, "msg.in.after.for.name"))
                 inPos = ts.tokenBeg - pos;
-                isForIn = true;
-                break;
-            case Token.NAME:
-                if ("of".equals(ts.getString())) {
-                    if (eachPos != -1) {
-                        reportError("msg.invalid.for.each");
-                    }
-                    inPos = ts.tokenBeg - pos;
-                    isForOf = true;
-                    break;
-                }
-            default:
-                reportError("msg.in.after.for.name");
-            }
             AstNode obj = expr();
             if (mustMatchToken(Token.RP, "msg.no.paren.for.ctrl"))
                 rp = ts.tokenBeg - pos;
@@ -3248,7 +3098,6 @@ public class Parser
             pn.setEachPosition(eachPos);
             pn.setIsForEach(eachPos != -1);
             pn.setParens(lp, rp);
-            pn.setIsForOf(isForOf);
             return pn;
         } finally {
             popScope();
@@ -3345,10 +3194,9 @@ public class Parser
         }
     }
 
-    private static final int PROP_ENTRY   = 1;
-    private static final int GET_ENTRY    = 2;
-    private static final int SET_ENTRY    = 4;
-    private static final int METHOD_ENTRY = 8;
+    private static final int PROP_ENTRY = 1;
+    private static final int GET_ENTRY  = 2;
+    private static final int SET_ENTRY  = 4;
 
     private ObjectLiteral objectLiteral()
         throws IOException
@@ -3370,70 +3218,68 @@ public class Parser
             int entryKind = PROP_ENTRY;
             int tt = peekToken();
             Comment jsdocNode = getAndResetJsDoc();
+            switch(tt) {
+              case Token.NAME:
+                  Name name = createNameNode();
+                  propertyName = ts.getString();
+                  int ppos = ts.tokenBeg;
+                  consumeToken();
 
-            if (tt == Token.RC) {
-                if (afterComma != -1)
-                    warnTrailingComma(pos, elems, afterComma);
-                break commaLoop;
-            } else {
-                AstNode pname = objliteralProperty();
-                if (pname == null) {
-                    propertyName = null;
-                    reportError("msg.bad.prop");
-                } else {
-                    propertyName = ts.getString();
-                    int ppos = ts.tokenBeg;
-                    consumeToken();
+                  // This code path needs to handle both destructuring object
+                  // literals like:
+                  // var {get, b} = {get: 1, b: 2};
+                  // and getters like:
+                  // var x = {get 1() { return 2; };
+                  // So we check a whitelist of tokens to check if we're at the
+                  // first case. (Because of keywords, the second case may be
+                  // many tokens.)
+                  int peeked = peekToken();
+                  boolean maybeGetterOrSetter =
+                          "get".equals(propertyName)
+                          || "set".equals(propertyName);
+                  if (maybeGetterOrSetter
+                          && peeked != Token.COMMA
+                          && peeked != Token.COLON
+                          && peeked != Token.RC)
+                  {
+                      boolean isGet = "get".equals(propertyName);
+                      entryKind = isGet ? GET_ENTRY : SET_ENTRY;
+                      AstNode pname = objliteralProperty();
+                      if (pname == null) {
+                          propertyName = null;
+                      } else {
+                          propertyName = ts.getString();
+                          ObjectProperty objectProp = getterSetterProperty(
+                                  ppos, pname, isGet);
+                          pname.setJsDocNode(jsdocNode);
+                          elems.add(objectProp);
+                      }
+                  } else {
+                      name.setJsDocNode(jsdocNode);
+                      elems.add(plainProperty(name, tt));
+                  }
+                  break;
 
-                    // This code path needs to handle both destructuring object
-                    // literals like:
-                    // var {get, b} = {get: 1, b: 2};
-                    // and getters like:
-                    // var x = {get 1() { return 2; };
-                    // So we check a whitelist of tokens to check if we're at the
-                    // first case. (Because of keywords, the second case may be
-                    // many tokens.)
-                    int peeked = peekToken();
-                    if (peeked != Token.COMMA
-                            && peeked != Token.COLON
-                            && peeked != Token.RC)
-                    {
-                        if (peeked == Token.LP) {
-                            entryKind = METHOD_ENTRY;
-                        } else if (pname.getType() == Token.NAME) {
-                            if ("get".equals(propertyName)) {
-                                entryKind = GET_ENTRY;
-                            } else if ("set".equals(propertyName)) {
-                                entryKind = SET_ENTRY;
-                            }
-                        }
-                        if (entryKind == GET_ENTRY || entryKind == SET_ENTRY) {
-                            pname = objliteralProperty();
-                            if (pname == null) {
-                                reportError("msg.bad.prop");
-                            }
-                            consumeToken();
-                        }
-                        if (pname == null) {
-                            propertyName = null;
-                        } else {
-                            propertyName = ts.getString();
-                            ObjectProperty objectProp = methodDefinition(
-                                    ppos, pname, entryKind);
-                            pname.setJsDocNode(jsdocNode);
-                            elems.add(objectProp);
-                        }
-                    } else {
-                        pname.setJsDocNode(jsdocNode);
-                        elems.add(plainProperty(pname, tt));
-                    }
-                }
+              case Token.RC:
+                  if (afterComma != -1)
+                      warnTrailingComma(pos, elems, afterComma);
+                  break commaLoop;
+
+              default:
+                  AstNode pname = objliteralProperty();
+                  if (pname == null) {
+                      propertyName = null;
+                  } else {
+                      propertyName = ts.getString();
+                      pname.setJsDocNode(jsdocNode);
+                      elems.add(plainProperty(pname, tt));
+                  }
+                  break;
             }
 
             if (this.inUseStrictDirective && propertyName != null) {
                 switch (entryKind) {
                 case PROP_ENTRY:
-                case METHOD_ENTRY:
                     if (getterNames.contains(propertyName)
                             || setterNames.contains(propertyName)) {
                         addError("msg.dup.obj.lit.prop.strict", propertyName);
@@ -3495,14 +3341,16 @@ public class Parser
 
           default:
               if (compilerEnv.isReservedKeywordAsIdentifier()
-                      && TokenStream.isKeyword(ts.getString(), compilerEnv.getLanguageVersion(), inUseStrictDirective)) {
+                      && TokenStream.isKeyword(ts.getString())) {
                   // convert keyword to property name, e.g. ({if: 1})
                   pname = createNameNode();
                   break;
               }
+              reportError("msg.bad.prop");
               return null;
         }
 
+        consumeToken();
         return pname;
     }
 
@@ -3530,7 +3378,8 @@ public class Parser
         return pn;
     }
 
-    private ObjectProperty methodDefinition(int pos, AstNode propName, int entryKind)
+    private ObjectProperty getterSetterProperty(int pos, AstNode propName,
+                                                boolean isGetter)
         throws IOException
     {
         FunctionNode fn = function(FunctionNode.FUNCTION_EXPRESSION);
@@ -3540,19 +3389,12 @@ public class Parser
             reportError("msg.bad.prop");
         }
         ObjectProperty pn = new ObjectProperty(pos);
-        switch (entryKind) {
-        case GET_ENTRY:
-            pn.setIsGetterMethod();
-            fn.setFunctionIsGetterMethod();
-            break;
-        case SET_ENTRY:
-            pn.setIsSetterMethod();
-            fn.setFunctionIsSetterMethod();
-            break;
-        case METHOD_ENTRY:
-            pn.setIsNormalMethod();
-            fn.setFunctionIsNormalMethod();
-            break;
+        if (isGetter) {
+            pn.setIsGetter();
+            fn.setFunctionIsGetter();
+        } else {
+            pn.setIsSetter();
+            fn.setFunctionIsSetter();
         }
         int end = getNodeEnd(fn);
         pn.setLeft(propName);
@@ -3613,12 +3455,10 @@ public class Parser
             return;
         }
         boolean activation = false;
-        if ("arguments".equals(name) &&
-            // An arrow function not generate arguments. So it not need activation.
-            ((FunctionNode)currentScriptOrFn).getFunctionType() != FunctionNode.ARROW_FUNCTION) {
-            activation = true;
-        } else if (compilerEnv.getActivationNames() != null
-                && compilerEnv.getActivationNames().contains(name)) {
+        if ("arguments".equals(name)
+            || (compilerEnv.getActivationNames() != null
+                && compilerEnv.getActivationNames().contains(name)))
+        {
             activation = true;
         } else if ("length".equals(name)) {
             if (token == Token.GETPROP
@@ -4035,11 +3875,11 @@ public class Parser
         int nodeType = left.getType();
         switch (nodeType) {
           case Token.NAME:
-              String name = ((Name) left).getIdentifier();
               if (inUseStrictDirective &&
-                  ("eval".equals(name) || "arguments".equals(name)))
+                  "eval".equals(((Name) left).getIdentifier()))
               {
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Parser.java.
The file will have its original line endings in your working directory.
-                  reportError("msg.bad.id.strict", name);
+                  reportError("msg.bad.id.strict",
+                              ((Name) left).getIdentifier());
               }
               left.setType(Token.BINDNAME);
               return new Node(Token.SETNAME, left, right);
@@ -4117,12 +3957,4 @@ public class Parser
                           + ", ts.tokenBeg=" + ts.tokenBeg
                           + ", currentToken=" + currentToken);
     }
-
-    public void setDefaultUseStrictDirective(boolean useStrict) {
-        defaultUseStrictDirective = useStrict;
-    }
-
-    public boolean inUseStrictDirective() {
-        return inUseStrictDirective;
-    }
 }
diff --git a/src/org/mozilla/javascript/ScriptRuntime.java b/src/org/mozilla/javascript/ScriptRuntime.java
index faca843..0b70e74 100644
--- a/src/org/mozilla/javascript/ScriptRuntime.java
+++ b/src/org/mozilla/javascript/ScriptRuntime.java
@@ -7,16 +7,21 @@
 package org.mozilla.javascript;
 
 import java.io.Serializable;
-import java.lang.reflect.*;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
 import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Locale;
 import java.util.ResourceBundle;
+import java.util.Set;
+import java.util.TreeSet;
 
 import org.mozilla.javascript.ast.FunctionNode;
 import org.mozilla.javascript.v8dtoa.DoubleConversion;
 import org.mozilla.javascript.v8dtoa.FastDtoa;
-import org.mozilla.javascript.xml.XMLObject;
 import org.mozilla.javascript.xml.XMLLib;
+import org.mozilla.javascript.xml.XMLObject;
 
 /**
  * This is the class that implements the runtime.
@@ -198,9 +203,6 @@ public class ScriptRuntime {
 
         NativeIterator.init(scope, sealed); // Also initializes NativeGenerator
 
-        NativeArrayIterator.init(scope, sealed);
-        NativeStringIterator.init(scope, sealed);
-
         boolean withXml = cx.hasFeature(Context.FEATURE_E4X) &&
                           cx.getE4xImplementationFactory() != null;
 
@@ -218,10 +220,8 @@ public class ScriptRuntime {
             new LazilyLoadedCtor(scope, "QName", xmlImpl, sealed, true);
         }
 
-        if (((cx.getLanguageVersion() >= Context.VERSION_1_8) &&
-             cx.hasFeature(Context.FEATURE_V8_EXTENSIONS)) ||
-            (cx.getLanguageVersion() >= Context.VERSION_ES6))
-        {
+        if ((cx.getLanguageVersion() >= Context.VERSION_1_8) &&
+             cx.hasFeature(Context.FEATURE_V8_EXTENSIONS)) {
             new LazilyLoadedCtor(scope, "ArrayBuffer",
                                  "org.mozilla.javascript.typedarrays.NativeArrayBuffer",
                                  sealed, true);
@@ -256,15 +256,7 @@ public class ScriptRuntime {
                                  "org.mozilla.javascript.typedarrays.NativeDataView",
                                  sealed, true);
         }
-
-        if (cx.getLanguageVersion() >= Context.VERSION_ES6) {
-            new LazilyLoadedCtor(scope, NativeSymbol.CLASS_NAME,
-                NativeSymbol.class.getName(),
-                sealed, true);
-
-        }
-
-
+     
         if (scope instanceof TopLevel) {
             ((TopLevel)scope).cacheBuiltins();
         }
@@ -294,7 +286,7 @@ public class ScriptRuntime {
 
         return s;
     }
-
+    
     static String[] getTopPackageNames() {
         // Include "android" top package if running on Android
         return "Dalvik".equals(System.getProperty("java.vm.name")) ?
@@ -784,7 +776,7 @@ public class ScriptRuntime {
         return (sb == null) ? s : sb.toString();
     }
 
-    static boolean isValidIdentifierName(String s, Context cx, boolean isStrict)
+    static boolean isValidIdentifierName(String s)
     {
         int L = s.length();
         if (L == 0)
@@ -795,7 +787,7 @@ public class ScriptRuntime {
             if (!Character.isJavaIdentifierPart(s.charAt(i)))
                 return false;
         }
-        return !TokenStream.isKeyword(s, cx.getLanguageVersion(), isStrict);
+        return !TokenStream.isKeyword(s);
     }
 
     public static CharSequence toCharSequence(Object val) {
@@ -815,7 +807,7 @@ public class ScriptRuntime {
             if (val == null) {
                 return "null";
             }
-            if (val == Undefined.instance || val == Undefined.SCRIPTABLE_UNDEFINED) {
+            if (val == Undefined.instance) {
                 return "undefined";
             }
             if (val instanceof String) {
@@ -842,10 +834,6 @@ public class ScriptRuntime {
 
     static String defaultObjectToString(Scriptable obj)
     {
-        if (obj == null)
-            return "[object Null]";
-        if (Undefined.isUndefined(obj))
-            return "[object Undefined]";
         return "[object " + obj.getClassName() + ']';
     }
 
@@ -978,7 +966,7 @@ public class ScriptRuntime {
                             continue;   // a property has been removed
                         if (i > 0)
                             result.append(", ");
-                        if (ScriptRuntime.isValidIdentifierName(strId, cx, cx.isStrictMode())) {
+                        if (ScriptRuntime.isValidIdentifierName(strId)) {
                             result.append(strId);
                         } else {
                             result.append('\'');
@@ -1035,7 +1023,10 @@ public class ScriptRuntime {
     public static Scriptable toObjectOrNull(Context cx, Object obj,
                                             Scriptable scope)
     {
-        if (obj instanceof Scriptable) {
+    	if (obj instanceof Delegator) {
+    		return ((Delegator) obj).getDelegee();
+    	}
+    	else if (obj instanceof Scriptable) {
             return (Scriptable)obj;
         } else if (obj != null && obj != Undefined.instance) {
             return toObject(cx, scope, obj);
@@ -2108,7 +2099,7 @@ public class ScriptRuntime {
         ObjToIntMap used;
         Object currentId;
         int enumType; /* one of ENUM_INIT_KEYS, ENUM_INIT_VALUES,
-                         ENUM_INIT_ARRAY, ENUMERATE_VALUES_IN_ORDER */
+                         ENUM_INIT_ARRAY */
 
         // if true, integer ids will be returned as numbers rather than strings
         boolean enumNumbers;
@@ -2157,7 +2148,6 @@ public class ScriptRuntime {
     public static final int ENUMERATE_KEYS_NO_ITERATOR = 3;
     public static final int ENUMERATE_VALUES_NO_ITERATOR = 4;
     public static final int ENUMERATE_ARRAY_NO_ITERATOR = 5;
-    public static final int ENUMERATE_VALUES_IN_ORDER = 6;
 
     /**
      * @deprecated Use {@link #enumInit(Object, Context, Scriptable, int)} instead
@@ -2173,12 +2163,6 @@ public class ScriptRuntime {
     {
         IdEnumeration x = new IdEnumeration();
         x.obj = toObjectOrNull(cx, value, scope);
-        // "for of" loop
-        if (enumType == ENUMERATE_VALUES_IN_ORDER) {
-            x.enumType = enumType;
-            x.iterator = null;
-            return enumInitInOrder(cx, x);
-        }
         if (x.obj == null) {
             // null or undefined do not cause errors but rather lead to empty
             // "for in" loop
@@ -2202,25 +2186,6 @@ public class ScriptRuntime {
         return x;
     }
 
-    private static Object enumInitInOrder(Context cx, IdEnumeration x) {
-        if (x.obj == null || !ScriptableObject.hasProperty(x.obj, NativeSymbol.ITERATOR_PROPERTY)) {
-            throw typeError1("msg.not.iterable", toString(x.obj));
-        }
-        Object iterator = ScriptableObject.getProperty(x.obj, NativeSymbol.ITERATOR_PROPERTY);
-        if (!(iterator instanceof Callable)) {
-            throw typeError1("msg.not.iterable", toString(x.obj));
-        }
-        Callable f = (Callable) iterator;
-        Scriptable scope = x.obj.getParentScope();
-        Object[] args = new Object[] {};
-        Object v = f.call(cx, scope, x.obj, args);
-        if (!(v instanceof Scriptable)) {
-            throw typeError1("msg.not.iterable", toString(x.obj));
-        }
-        x.iterator = (Scriptable) v;
-        return x;
-    }
-
     public static void setEnumNumbers(Object enumObj, boolean enumNumbers) {
         ((IdEnumeration)enumObj).enumNumbers = enumNumbers;
     }
@@ -2229,9 +2194,6 @@ public class ScriptRuntime {
     {
         IdEnumeration x = (IdEnumeration)enumObj;
         if (x.iterator != null) {
-            if (x.enumType == ENUMERATE_VALUES_IN_ORDER) {
-                return enumNextInOrder(x);
-            }
             Object v = ScriptableObject.getProperty(x.iterator, "next");
             if (!(v instanceof Callable))
                 return Boolean.FALSE;
@@ -2243,7 +2205,7 @@ public class ScriptRuntime {
                 return Boolean.TRUE;
             } catch (JavaScriptException e) {
                 if (e.getValue() instanceof NativeIterator.StopIteration) {
-                    return Boolean.FALSE;
+                  return Boolean.FALSE;
                 }
                 throw e;
             }
@@ -2277,25 +2239,6 @@ public class ScriptRuntime {
         }
     }
 
-    private static Boolean enumNextInOrder(IdEnumeration enumObj)
-    {
-        Object v = ScriptableObject.getProperty(enumObj.iterator, ES6Iterator.NEXT_METHOD);
-        if (!(v instanceof Callable)) {
-            throw notFunctionError(enumObj.iterator, ES6Iterator.NEXT_METHOD);
-        }
-        Callable f = (Callable) v;
-        Context cx = Context.getContext();
-        Scriptable scope = enumObj.iterator.getParentScope();
-        Object r = f.call(cx, scope, enumObj.iterator, emptyArgs);
-        Scriptable iteratorResult = toObject(cx, scope, r);
-        Object done = ScriptableObject.getProperty(iteratorResult, ES6Iterator.DONE_PROPERTY);
-        if (done != ScriptableObject.NOT_FOUND && toBoolean(done)) {
-            return Boolean.FALSE;
-        }
-        enumObj.currentId = ScriptableObject.getProperty(iteratorResult, ES6Iterator.VALUE_PROPERTY);
-        return Boolean.TRUE;
-    }
-
     public static Object enumId(Object enumObj, Context cx)
     {
         IdEnumeration x = (IdEnumeration)enumObj;
@@ -2354,6 +2297,24 @@ public class ScriptRuntime {
                 x.used.intern(previous[i]);
             }
         }
+        if (ids != null && Context.getCurrentContext().hasFeature(Context.FEATURE_HTMLUNIT_ENUM_NUMBERS_FIRST)) {
+            Set<Integer> integers = new TreeSet<Integer>();
+            List<Object> others = new ArrayList<Object>();
+            for (Object o : ids) {
+                if (o instanceof Integer) {
+                    integers.add((Integer) o);
+                }
+                else {
+                    others.add(o);
+                }
+            }
+            if (!integers.isEmpty()) {
+                Object[] newIds = new Object[ids.length];
+                System.arraycopy(integers.toArray(), 0, newIds, 0, integers.size());
+                System.arraycopy(others.toArray(), 0, newIds, integers.size(), others.size());
+                ids = newIds;
+            }
+        }
         x.ids = ids;
         x.index = 0;
     }
@@ -2369,6 +2330,9 @@ public class ScriptRuntime {
                                                   Context cx,
                                                   Scriptable scope)
     {
+        if ("eval".equals(name)) {
+            lastEvalTopCalled_ = true;
+        }
         Scriptable parent = scope.getParentScope();
         if (parent == null) {
             Object result = topScopeName(cx, scope, name);
@@ -2466,6 +2430,9 @@ public class ScriptRuntime {
                                                   String property,
                                                   Context cx, Scriptable scope)
     {
+        if ("eval".equals(property)) {
+            lastEvalTopCalled_ = false;
+        }
         Scriptable thisObj = toObjectOrNull(cx, obj, scope);
         return getPropFunctionAndThisHelper(obj, property, cx, thisObj);
     }
@@ -2568,6 +2535,18 @@ public class ScriptRuntime {
         return function.construct(cx, scope, args);
     }
 
+    /**
+     * This indicates whether last call of "eval" was at the top scope (i.e. "eval()")
+     * or not (i.e. "scope.eval()"), as each one has different behavior.
+     *
+     * Ideally, we should have "eval" at top scope and we use Context.FEATURE_DYNAMIC_SCOPE,
+     * but it will complex the code.
+     *
+     * The current implementation sets this value to true when "eval" is called, and
+     * false on "something.eval()"
+     */
+    private static boolean lastEvalTopCalled_;
+    
     public static Object callSpecial(Context cx, Callable fun,
                                      Scriptable thisObj,
                                      Object[] args, Scriptable scope,
@@ -2576,6 +2555,12 @@ public class ScriptRuntime {
     {
         if (callType == Node.SPECIALCALL_EVAL) {
             if (thisObj.getParentScope() == null && NativeGlobal.isEvalFunction(fun)) {
+                final boolean isNative = scope instanceof NativeCall;
+                final boolean hasFeature = cx.hasFeature(Context.FEATURE_HTMLUNIT_EVAL_LOCAL_SCOPE);
+
+                if (!lastEvalTopCalled_ && (!hasFeature || !isNative)) {
+                    scope = thisObj;
+                }
                 return evalSpecial(cx, scope, callerThis, args,
                                    filename, lineNumber);
             }
@@ -2624,14 +2609,11 @@ public class ScriptRuntime {
 
         Scriptable callThis = null;
         if (L != 0) {
-            if  (cx.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS)) {
-                callThis = toObjectOrNull(cx, args[0], scope);
-            } else {
-                callThis = args[0] == Undefined.instance ? Undefined.SCRIPTABLE_UNDEFINED : toObjectOrNull(cx, args[0], scope);
-            }
+            callThis = toObjectOrNull(cx, args[0], scope);
         }
-        if (callThis == null && cx.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS)) {
-            callThis = getTopCallScope(cx); // This covers the case of args[0] == (null|undefined) as well.
+        if (callThis == null) {
+            // This covers the case of args[0] == (null|undefined) as well.
+            callThis = getTopCallScope(cx);
         }
 
         Object[] callArgs;
@@ -2656,7 +2638,7 @@ public class ScriptRuntime {
     {
         if (arg1 == null || arg1 == Undefined.instance) {
             return ScriptRuntime.emptyArgs;
-        } else if (arg1 instanceof NativeArray || arg1 instanceof Arguments) {
+        } else if (arg1 instanceof Scriptable) {
             return cx.getElements((Scriptable) arg1);
         } else {
             throw ScriptRuntime.typeError0("msg.arg.isnt.array");
@@ -2741,6 +2723,8 @@ public class ScriptRuntime {
             return "undefined";
         if (value instanceof ScriptableObject)
         	return ((ScriptableObject) value).getTypeOf();
+        if (value instanceof Delegator)
+            return typeof(((Delegator) value).getDelegee());
         if (value instanceof Scriptable)
             return (value instanceof Callable) ? "function" : "object";
         if (value instanceof CharSequence)
@@ -2749,6 +2733,10 @@ public class ScriptRuntime {
             return "number";
         if (value instanceof Boolean)
             return "boolean";
+        if (value instanceof MemberBox)
+            return typeof(((MemberBox) value).member());
+        if (value instanceof Method)
+            return "function";
         throw errorWithClassName("msg.invalid.type", value);
     }
 
@@ -3171,9 +3159,7 @@ public class ScriptRuntime {
             double d = ((Number)x).doubleValue();
             return d == d;
         }
-        if (x == null || x == Undefined.instance || x == Undefined.SCRIPTABLE_UNDEFINED) {
-            if ((x == Undefined.instance && y == Undefined.SCRIPTABLE_UNDEFINED)
-                || (x == Undefined.SCRIPTABLE_UNDEFINED && y == Undefined.instance)) return true;
+        if (x == null || x == Undefined.instance) {
             return false;
         } else if (x instanceof Number) {
             if (y instanceof Number) {
@@ -3191,6 +3177,15 @@ public class ScriptRuntime {
             if (x instanceof Wrapper && y instanceof Wrapper) {
                 return ((Wrapper)x).unwrap() == ((Wrapper)y).unwrap();
             }
+            if (x instanceof Delegator && y instanceof Delegator) {
+                return shallowEq(((Delegator)x).getDelegee(), ((Delegator)y).getDelegee());
+            }
+            if (x instanceof Delegator && ((Delegator)x).getDelegee() == y) {
+                return true;
+            }
+            if (y instanceof Delegator && ((Delegator)y).getDelegee() == x) {
+                return true;
+            }
         } else {
             warnAboutNonJSObject(x);
             return x == y;
@@ -3334,20 +3329,10 @@ public class ScriptRuntime {
         return scope;
     }
 
-    /**
-     * @deprecated Use {@link #doTopCall(Callable, Context, Scriptable, Scriptable, Object[], boolean)} instead
-     */
     public static Object doTopCall(Callable callable,
                                    Context cx, Scriptable scope,
                                    Scriptable thisObj, Object[] args)
     {
-        return doTopCall(callable, cx, scope, thisObj, args, cx.isTopLevelStrict);
-    }
-
-    public static Object doTopCall(Callable callable,
-                                   Context cx, Scriptable scope,
-                                   Scriptable thisObj, Object[] args, boolean isTopLevelStrict)
-    {
         if (scope == null)
             throw new IllegalArgumentException();
         if (cx.topCallScope != null) throw new IllegalStateException();
@@ -3355,8 +3340,6 @@ public class ScriptRuntime {
         Object result;
         cx.topCallScope = ScriptableObject.getTopLevelScope(scope);
         cx.useDynamicScope = cx.hasFeature(Context.FEATURE_DYNAMIC_SCOPE);
-        boolean previousTopLevelStrict = cx.isTopLevelStrict;
-        cx.isTopLevelStrict = isTopLevelStrict;
         ContextFactory f = cx.getFactory();
         try {
             result = f.doTopCall(callable, cx, scope, thisObj, args);
@@ -3364,7 +3347,6 @@ public class ScriptRuntime {
             cx.topCallScope = null;
             // Cleanup cached references
             cx.cachedXMLLib = null;
-            cx.isTopLevelStrict = previousTopLevelStrict;
 
             if (cx.currentActivationCall != null) {
                 // Function should always call exitActivationFunction
@@ -3433,13 +3415,27 @@ public class ScriptRuntime {
                 // Don't overwrite existing def if already defined in object
                 // or prototypes of object.
                 if (!ScriptableObject.hasProperty(scope, name)) {
-                    if (isConst) {
-                        ScriptableObject.defineConstProperty(varScope, name);
-                    } else if (!evalScript) {
+                    if (!evalScript) {
                         // Global var definitions are supposed to be DONTDELETE
-                        ScriptableObject.defineProperty(
-                            varScope, name, Undefined.instance,
-                            ScriptableObject.PERMANENT);
+                        if (isConst)
+                            ScriptableObject.defineConstProperty(varScope, name);
+                        else {
+                            boolean define = true;
+                            if (funObj instanceof InterpretedFunction) {
+                                InterpreterData idata = ((InterpretedFunction) funObj).idata;
+                                for (int f = 0; f < idata.getFunctionCount(); f++) {
+                                    if (name.equals(idata.getFunction(f).getFunctionName())) {
+                                        define = false;
+                                        break;
+                                    }
+                                }
+                            }
+                            if (define) {
+                                ScriptableObject.defineProperty(
+                                        varScope, name, Undefined.instance,
+                                        ScriptableObject.PERMANENT);
+                            }
+                        }
                     } else {
                         varScope.put(name, varScope, Undefined.instance);
                     }
@@ -3450,32 +3446,13 @@ public class ScriptRuntime {
         }
     }
 
-    /**
-     * @deprecated Use {@link #createFunctionActivation(NativeFunction, Scriptable, Object[], boolean)} instead
-     */
-    @Deprecated
     public static Scriptable createFunctionActivation(NativeFunction funObj,
                                                       Scriptable scope,
                                                       Object[] args)
     {
-        return createFunctionActivation(funObj, scope, args, false);
+        return new NativeCall(funObj, scope, args);
     }
 
-    public static Scriptable createFunctionActivation(NativeFunction funObj,
-                                                      Scriptable scope,
-                                                      Object[] args,
-                                                      boolean isStrict)
-    {
-        return new NativeCall(funObj, scope, args, false, isStrict);
-    }
-
-    public static Scriptable createArrowFunctionActivation(NativeFunction funObj,
-                                                           Scriptable scope,
-                                                           Object[] args,
-                                                           boolean isStrict)
-    {
-        return new NativeCall(funObj, scope, args, true, isStrict);
-    }
 
     public static void enterActivationFunction(Context cx,
                                                Scriptable scope)
@@ -3485,7 +3462,6 @@ public class ScriptRuntime {
         NativeCall call = (NativeCall)scope;
         call.parentActivationCall = cx.currentActivationCall;
         cx.currentActivationCall = call;
-        call.defineAttributesForArguments();
     }
 
     public static void exitActivationFunction(Context cx)
@@ -3841,7 +3817,7 @@ public class ScriptRuntime {
                 ++skip;
                 continue;
             }
-            array.put(i, array, objects[j]);
+            ScriptableObject.putProperty(array, i, objects[j]);
             ++j;
         }
         return array;
@@ -4091,20 +4067,24 @@ public class ScriptRuntime {
 
     public static RuntimeException undefReadError(Object object, Object id)
     {
-        return typeError2("msg.undef.prop.read", toString(object), toString(id));
+        final String idStr = toString(id);
+        return typeError2("msg.undef.prop.read", toString(object), idStr);
     }
 
     public static RuntimeException undefCallError(Object object, Object id)
     {
-        return typeError2("msg.undef.method.call", toString(object), toString(id));
+        final String idStr = toString(id);
+        return typeError2("msg.undef.method.call", toString(object), idStr);
     }
 
     public static RuntimeException undefWriteError(Object object,
                                                    Object id,
                                                    Object value)
     {
-        return typeError3("msg.undef.prop.write", toString(object), toString(id),
-                          toString(value));
+        final String idStr = toString(id);
+        final String valueStr = toString(value);
+        return typeError3("msg.undef.prop.write", toString(object), idStr,
+                          valueStr);
     }
 
     private static RuntimeException undefDeleteError(Object object, Object id)
@@ -4372,4 +4352,12 @@ public class ScriptRuntime {
     public static final String[] emptyStrings = new String[0];
 
 
+    public static Scriptable requireObjectCoercible(Scriptable val, IdFunctionObject idFuncObj) {
+        Scriptable val1 = val.getParentScope() != null ? val : null;
+        if (val1 == null || val1 == Undefined.instance)
+            throw ScriptRuntime.typeError2("msg.called.null.or.undefined", idFuncObj.getTag(), idFuncObj.getFunctionName());
+
+        return val1;
+    }
+
 }
diff --git a/src/org/mozilla/javascript/ScriptRuntimeES6.java b/src/org/mozilla/javascript/ScriptRuntimeES6.java
deleted file mode 100644
index c7614e6..0000000
--- a/src/org/mozilla/javascript/ScriptRuntimeES6.java
+++ /dev/null
@@ -1,17 +0,0 @@
-/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- *
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript;
-
-public class ScriptRuntimeES6 {
-
-    public static Scriptable requireObjectCoercible(Context cx, Scriptable val, IdFunctionObject idFuncObj) {
-        if (val == null || Undefined.isUndefined(val)) {
-            throw ScriptRuntime.typeError2("msg.called.null.or.undefined", idFuncObj.getTag(), idFuncObj.getFunctionName());
-        }
-        return val;
-    }
-}
diff --git a/src/org/mozilla/javascript/ScriptableObject.java b/src/org/mozilla/javascript/ScriptableObject.java
index 46fe810..5218a68 100644
--- a/src/org/mozilla/javascript/ScriptableObject.java
+++ b/src/org/mozilla/javascript/ScriptableObject.java
@@ -19,8 +19,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.Arrays;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -176,10 +174,6 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
 
         boolean setValue(Object value, Scriptable owner, Scriptable start) {
             if ((attributes & READONLY) != 0) {
-                Context cx = Context.getContext();
-                if (cx.isStrictMode()) {
-                    throw ScriptRuntime.typeError1("msg.modify.readonly", name);
-                }
                 return true;
             }
             if (owner == start) {
@@ -248,9 +242,6 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
             ScriptRuntime.setBuiltinProtoAndParent(desc, scope, TopLevel.Builtins.Object);
             desc.defineProperty("enumerable", (attr & DONTENUM) == 0, EMPTY);
             desc.defineProperty("configurable", (attr & PERMANENT) == 0, EMPTY);
-            if (getter == null && setter == null) {
-                desc.defineProperty("writable", (attr & READONLY) == 0, EMPTY);
-            }
             if (getter != null) desc.defineProperty("get", getter, EMPTY);
             if (setter != null) desc.defineProperty("set", setter, EMPTY);
             return desc;
@@ -260,16 +251,33 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
         boolean setValue(Object value, Scriptable owner, Scriptable start) {
             if (setter == null) {
                 if (getter != null) {
-                    Context cx = Context.getContext();
-                    if (cx.isStrictMode() ||
+                    if (Context.getContext().hasFeature(Context.FEATURE_STRICT_MODE)) {
                         // Based on TC39 ES3.1 Draft of 9-Feb-2009, 8.12.4, step 2,
                         // we should throw a TypeError in this case.
-                        cx.hasFeature(Context.FEATURE_STRICT_MODE)) {
-                        throw ScriptRuntime.typeError1("msg.set.prop.no.setter", name);
+                        throw ScriptRuntime.typeError3("msg.set.prop.no.setter", name, start.getClassName(), Context.toString(value));
+                    }
+                    if (Context.getContext().hasFeature(Context.FEATURE_HTMLUNIT_ASK_OBJECT_TO_WRITE_READONLY)) {
+                        Scriptable scriptable = start;
+
+                        if (scriptable instanceof Delegator) {
+                            scriptable = ((Delegator) scriptable).getDelegee();
+                        }
+
+                        if (scriptable instanceof ScriptableObject) {
+                            boolean allowSetting = ((ScriptableObject) scriptable).isReadOnlySettable(name, value);
+                            if (!allowSetting) {
+                                return true;
+                            }
+                        }
+                        if (owner == start) {
+                            getter = null;
+                        }
+                    }
+                    else {
+                        // Based on TC39 ES3.1 Draft of 9-Feb-2009, 8.12.4, step 2,
+                        // we should throw a TypeError in this case.
+                        throw ScriptRuntime.typeError3("msg.set.prop.no.setter", name, start.getClassName(), Context.toString(value));
                     }
-                    // Assignment to a property with only a getter defined. The
-                    // assignment is ignored. See bug 478047.
-                    return true;
                 }
             } else {
                 Context cx = Context.getContext();
@@ -2274,6 +2282,10 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
      */
     public static Object getProperty(Scriptable obj, String name)
     {
+        if ("constructor".equals(name) && !(obj instanceof IdScriptableObject)
+                && !Context.getContext().hasFeature(Context.FEATURE_HTMLUNIT_CONSTRUCTOR)) {
+            return NOT_FOUND;
+        }
         Scriptable start = obj;
         Object result;
         do {
@@ -2720,12 +2732,6 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
     {
         // This method is very hot (basically called on each assignment)
         // so we inline the extensible/sealed checks below.
-        if (!isExtensible) {
-            Context cx = Context.getContext();
-            if (cx.isStrictMode()) {
-                throw ScriptRuntime.typeError0("msg.not.extensible");
-            }
-        }
         Slot slot;
         if (this != start) {
             slot = getSlot(name, index, SLOT_QUERY);
@@ -2760,12 +2766,6 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
                                  Object value, int constFlag)
     {
         assert (constFlag != EMPTY);
-        if (!isExtensible) {
-            Context cx = Context.getContext();
-            if (cx.isStrictMode()) {
-                throw ScriptRuntime.typeError0("msg.not.extensible");
-            }
-        }
         Slot slot;
         if (this != start) {
             slot = getSlot(name, index, SLOT_QUERY);
@@ -2977,15 +2977,7 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
                 prev = slot;
                 slot = slot.next;
             }
-            if (slot != null) {
-                // non-configurable
-                if ((slot.getAttributes() & PERMANENT) != 0) {
-                    Context cx = Context.getContext();
-                    if (cx.isStrictMode()) {
-                        throw ScriptRuntime.typeError1("msg.delete.property.with.configurable.false", name);
-                    }
-                    return;
-                }
+            if (slot != null && (slot.getAttributes() & PERMANENT) == 0) {
                 count--;
                 // remove slot from hash table
                 if (prev == slot) {
@@ -3120,13 +3112,6 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
         }
         Object[] result = new Object[c];
         System.arraycopy(a, 0, result, 0, c);
-
-        Context cx = Context.getCurrentContext();
-        if ((cx != null) && cx.hasFeature(Context.FEATURE_ENUMERATE_IDS_FIRST)) {
-            // Move all the numeric IDs to the front in numeric order
-            Arrays.sort(result, KEY_COMPARATOR);
-        }
-
         return result;
     }
 
@@ -3245,38 +3230,20 @@ public abstract class ScriptableObject implements Scriptable, Serializable,
         }
     }
 
-    private static final Comparator<Object> KEY_COMPARATOR = new KeyComparator();
-
     /**
-     * This comparator sorts property fields in spec-compliant order. Numeric ids first, in numeric
-     * order, folowed by string ids, in insertion order. Since this class already keeps string keys
-     * in insertion-time order, we treat all as equal. The "Arrays.sort" method will then not
-     * change their order, but simply move all the numeric properties to the front.
+     * Special to HtmlUnit's Rhino fork.
+     *
+     * Decides what to do when setting a ReadOnly property.
+     * The SimpleScriptable can return <tt>true<tt> for allowing to value to be set, <tt>false<tt> for not allowing (ignoring),
+     * or can simply throw {@link ScriptRuntime#typeError3(String, String, String, String)} with
+     * "msg.set.prop.no.setter", name, this.getClassName() and Context.toString(value).
+     *
+     * By default, this method returns <tt>true</tt>
+     * @param name the property name
+     * @param value the value
+     * @return <tt>true<tt> for allowing setting the value, <tt>false</tt> for ignoring the setting, or we can throw an exception
      */
-    private static final class KeyComparator
-        implements Comparator<Object>
-    {
-        @Override
-        public int compare(Object o1, Object o2)
-        {
-            if (o1 instanceof Integer) {
-                if (o2 instanceof Integer) {
-                    int i1 = (Integer) o1;
-                    int i2 = (Integer) o2;
-                    if (i1 < i2) {
-                        return -1;
-                    }
-                    if (i1 > i2) {
-                        return 1;
-                    }
-                    return 0;
-                }
-                return -1;
-            }
-            if (o2 instanceof Integer) {
-                return 1;
-            }
-            return 0;
-        }
+    protected boolean isReadOnlySettable(final String name, final Object value) {
+        return true;
     }
 }
diff --git a/src/org/mozilla/javascript/Token.java b/src/org/mozilla/javascript/Token.java
index 4559262..3dbfd49 100644
--- a/src/org/mozilla/javascript/Token.java
+++ b/src/org/mozilla/javascript/Token.java
@@ -102,136 +102,133 @@ public class Token
         ENUM_INIT_KEYS = 58,
         ENUM_INIT_VALUES = 59,
         ENUM_INIT_ARRAY= 60,
-        ENUM_INIT_VALUES_IN_ORDER = 61,
-        ENUM_NEXT      = 62,
-        ENUM_ID        = 63,
-        THISFN         = 64,
-        RETURN_RESULT  = 65, // to return previously stored return result
-        ARRAYLIT       = 66, // array literal
-        OBJECTLIT      = 67, // object literal
-        GET_REF        = 68, // *reference
-        SET_REF        = 69, // *reference    = something
-        DEL_REF        = 70, // delete reference
-        REF_CALL       = 71, // f(args)    = something or f(args)++
-        REF_SPECIAL    = 72, // reference for special properties like __proto
-        YIELD          = 73,  // JS 1.7 yield pseudo keyword
-        STRICT_SETNAME = 74,
+        ENUM_NEXT      = 61,
+        ENUM_ID        = 62,
+        THISFN         = 63,
+        RETURN_RESULT  = 64, // to return previously stored return result
+        ARRAYLIT       = 65, // array literal
+        OBJECTLIT      = 66, // object literal
+        GET_REF        = 67, // *reference
+        SET_REF        = 68, // *reference    = something
+        DEL_REF        = 69, // delete reference
+        REF_CALL       = 70, // f(args)    = something or f(args)++
+        REF_SPECIAL    = 71, // reference for special properties like __proto
+        YIELD          = 72,  // JS 1.7 yield pseudo keyword
+        STRICT_SETNAME = 73,
 
         // For XML support:
-        DEFAULTNAMESPACE = 75, // default xml namespace =
-        ESCXMLATTR     = 76,
-        ESCXMLTEXT     = 77,
-        REF_MEMBER     = 78, // Reference for x.@y, x..y etc.
-        REF_NS_MEMBER  = 79, // Reference for x.ns::y, x..ns::y etc.
-        REF_NAME       = 80, // Reference for @y, @[y] etc.
-        REF_NS_NAME    = 81; // Reference for ns::y, @ns::y@[y] etc.
+        DEFAULTNAMESPACE = 74, // default xml namespace =
+        ESCXMLATTR     = 75,
+        ESCXMLTEXT     = 76,
+        REF_MEMBER     = 77, // Reference for x.@y, x..y etc.
+        REF_NS_MEMBER  = 78, // Reference for x.ns::y, x..ns::y etc.
+        REF_NAME       = 79, // Reference for @y, @[y] etc.
+        REF_NS_NAME    = 80; // Reference for ns::y, @ns::y@[y] etc.
 
         // End of interpreter bytecodes
     public final static int
         LAST_BYTECODE_TOKEN    = REF_NS_NAME,
 
-        TRY            = 82,
-        SEMI           = 83,  // semicolon
-        LB             = 84,  // left and right brackets
-        RB             = 85,
-        LC             = 86,  // left and right curlies (braces)
-        RC             = 87,
-        LP             = 88,  // left and right parentheses
-        RP             = 89,
-        COMMA          = 90,  // comma operator
+        TRY            = 81,
+        SEMI           = 82,  // semicolon
+        LB             = 83,  // left and right brackets
+        RB             = 84,
+        LC             = 85,  // left and right curlies (braces)
+        RC             = 86,
+        LP             = 87,  // left and right parentheses
+        RP             = 88,
+        COMMA          = 89,  // comma operator
 
-        ASSIGN         = 91,  // simple assignment  (=)
-        ASSIGN_BITOR   = 92,  // |=
-        ASSIGN_BITXOR  = 93,  // ^=
-        ASSIGN_BITAND  = 94,  // |=
-        ASSIGN_LSH     = 95,  // <<=
-        ASSIGN_RSH     = 96,  // >>=
-        ASSIGN_URSH    = 97,  // >>>=
-        ASSIGN_ADD     = 98,  // +=
-        ASSIGN_SUB     = 99,  // -=
-        ASSIGN_MUL     = 100,  // *=
-        ASSIGN_DIV     = 101,  // /=
-        ASSIGN_MOD     = 102;  // %=
+        ASSIGN         = 90,  // simple assignment  (=)
+        ASSIGN_BITOR   = 91,  // |=
+        ASSIGN_BITXOR  = 92,  // ^=
+        ASSIGN_BITAND  = 93,  // |=
+        ASSIGN_LSH     = 94,  // <<=
+        ASSIGN_RSH     = 95,  // >>=
+        ASSIGN_URSH    = 96,  // >>>=
+        ASSIGN_ADD     = 97,  // +=
+        ASSIGN_SUB     = 98,  // -=
+        ASSIGN_MUL     = 99,  // *=
+        ASSIGN_DIV     = 100,  // /=
+        ASSIGN_MOD     = 101;  // %=
 
     public final static int
         FIRST_ASSIGN   = ASSIGN,
         LAST_ASSIGN    = ASSIGN_MOD,
 
-        HOOK           = 103, // conditional (?:)
-        COLON          = 104,
-        OR             = 105, // logical or (||)
-        AND            = 106, // logical and (&&)
-        INC            = 107, // increment/decrement (++ --)
-        DEC            = 108,
-        DOT            = 109, // member operator (.)
-        FUNCTION       = 110, // function keyword
-        EXPORT         = 111, // export keyword
-        IMPORT         = 112, // import keyword
-        IF             = 113, // if keyword
-        ELSE           = 114, // else keyword
-        SWITCH         = 115, // switch keyword
-        CASE           = 116, // case keyword
-        DEFAULT        = 117, // default keyword
-        WHILE          = 118, // while keyword
-        DO             = 119, // do keyword
-        FOR            = 120, // for keyword
-        BREAK          = 121, // break keyword
-        CONTINUE       = 122, // continue keyword
-        VAR            = 123, // var keyword
-        WITH           = 124, // with keyword
-        CATCH          = 125, // catch keyword
-        FINALLY        = 126, // finally keyword
-        VOID           = 127, // void keyword
-        RESERVED       = 128, // reserved keywords
+        HOOK           = 102, // conditional (?:)
+        COLON          = 103,
+        OR             = 104, // logical or (||)
+        AND            = 105, // logical and (&&)
+        INC            = 106, // increment/decrement (++ --)
+        DEC            = 107,
+        DOT            = 108, // member operator (.)
+        FUNCTION       = 109, // function keyword
+        EXPORT         = 110, // export keyword
+        IMPORT         = 111, // import keyword
+        IF             = 112, // if keyword
+        ELSE           = 113, // else keyword
+        SWITCH         = 114, // switch keyword
+        CASE           = 115, // case keyword
+        DEFAULT        = 116, // default keyword
+        WHILE          = 117, // while keyword
+        DO             = 118, // do keyword
+        FOR            = 119, // for keyword
+        BREAK          = 120, // break keyword
+        CONTINUE       = 121, // continue keyword
+        VAR            = 122, // var keyword
+        WITH           = 123, // with keyword
+        CATCH          = 124, // catch keyword
+        FINALLY        = 125, // finally keyword
+        VOID           = 126, // void keyword
+        RESERVED       = 127, // reserved keywords
 
-        EMPTY          = 129,
+        EMPTY          = 128,
 
         /* types used for the parse tree - these never get returned
          * by the scanner.
          */
 
-        BLOCK          = 130, // statement block
-        LABEL          = 131, // label
-        TARGET         = 132,
-        LOOP           = 133,
-        EXPR_VOID      = 134, // expression statement in functions
-        EXPR_RESULT    = 135, // expression statement in scripts
-        JSR            = 136,
-        SCRIPT         = 137, // top-level node for entire script
-        TYPEOFNAME     = 138, // for typeof(simple-name)
-        USE_STACK      = 139,
-        SETPROP_OP     = 140, // x.y op= something
-        SETELEM_OP     = 141, // x[y] op= something
-        LOCAL_BLOCK    = 142,
-        SET_REF_OP     = 143, // *reference op= something
+        BLOCK          = 129, // statement block
+        LABEL          = 130, // label
+        TARGET         = 131,
+        LOOP           = 132,
+        EXPR_VOID      = 133, // expression statement in functions
+        EXPR_RESULT    = 134, // expression statement in scripts
+        JSR            = 135,
+        SCRIPT         = 136, // top-level node for entire script
+        TYPEOFNAME     = 137, // for typeof(simple-name)
+        USE_STACK      = 138,
+        SETPROP_OP     = 139, // x.y op= something
+        SETELEM_OP     = 140, // x[y] op= something
+        LOCAL_BLOCK    = 141,
+        SET_REF_OP     = 142, // *reference op= something
 
         // For XML support:
-        DOTDOT         = 144,  // member operator (..)
-        COLONCOLON     = 145,  // namespace::name
-        XML            = 146,  // XML type
-        DOTQUERY       = 147,  // .() -- e.g., x.emps.emp.(name == "terry")
-        XMLATTR        = 148,  // @
-        XMLEND         = 149,
+        DOTDOT         = 143,  // member operator (..)
+        COLONCOLON     = 144,  // namespace::name
+        XML            = 145,  // XML type
+        DOTQUERY       = 146,  // .() -- e.g., x.emps.emp.(name == "terry")
+        XMLATTR        = 147,  // @
+        XMLEND         = 148,
 
         // Optimizer-only-tokens
-        TO_OBJECT      = 150,
-        TO_DOUBLE      = 151,
+        TO_OBJECT      = 149,
+        TO_DOUBLE      = 150,
 
-        GET            = 152,  // JS 1.5 get pseudo keyword
-        SET            = 153,  // JS 1.5 set pseudo keyword
-        LET            = 154,  // JS 1.7 let pseudo keyword
-        CONST          = 155,
-        SETCONST       = 156,
-        SETCONSTVAR    = 157,
-        ARRAYCOMP      = 158,  // array comprehension
-        LETEXPR        = 159,
-        WITHEXPR       = 160,
-        DEBUGGER       = 161,
-        COMMENT        = 162,
-        GENEXPR        = 163,
-        METHOD         = 164,  // ES6 MethodDefinition
-        ARROW          = 165,  // ES6 ArrowFunction
-        LAST_TOKEN     = 166;
+        GET            = 151,  // JS 1.5 get pseudo keyword
+        SET            = 152,  // JS 1.5 set pseudo keyword
+        LET            = 153,  // JS 1.7 let pseudo keyword
+        CONST          = 154,
+        SETCONST       = 155,
+        SETCONSTVAR    = 156,
+        ARRAYCOMP      = 157,  // array comprehension
+        LETEXPR        = 158,
+        WITHEXPR       = 159,
+        DEBUGGER       = 160,
+        COMMENT        = 161,
+        GENEXPR        = 162,
+        LAST_TOKEN     = 163;
 
     /**
      * Returns a name for the token.  If Rhino is compiled with certain
@@ -316,7 +313,6 @@ public class Token
           case ENUM_INIT_KEYS:  return "ENUM_INIT_KEYS";
           case ENUM_INIT_VALUES:return "ENUM_INIT_VALUES";
           case ENUM_INIT_ARRAY: return "ENUM_INIT_ARRAY";
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ScriptRuntime.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ScriptableObject.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Token.java.
The file will have its original line endings in your working directory.
-          case ENUM_INIT_VALUES_IN_ORDER: return "ENUM_INIT_VALUES_IN_ORDER";
           case ENUM_NEXT:       return "ENUM_NEXT";
           case ENUM_ID:         return "ENUM_ID";
           case THISFN:          return "THISFN";
@@ -417,8 +413,6 @@ public class Token
           case DEBUGGER:        return "DEBUGGER";
           case COMMENT:         return "COMMENT";
           case GENEXPR:         return "GENEXPR";
-          case METHOD:          return "METHOD";
-          case ARROW:           return "ARROW";
         }
 
         // Token without name
diff --git a/src/org/mozilla/javascript/TokenStream.java b/src/org/mozilla/javascript/TokenStream.java
index 259325b..b0fd002 100644
--- a/src/org/mozilla/javascript/TokenStream.java
+++ b/src/org/mozilla/javascript/TokenStream.java
@@ -74,24 +74,12 @@ class TokenStream
         return "";
     }
 
-    static boolean isKeyword(String s, int version, boolean isStrict)
+    static boolean isKeyword(String s)
     {
-        return Token.EOF != stringToKeyword(s, version, isStrict);
+        return Token.EOF != stringToKeyword(s);
     }
 
-    private static int stringToKeyword(String name, int version, boolean isStrict)
-    {
-        if (version < Context.VERSION_ES6) {
-            return stringToKeywordForJS(name);
-        } else {
-            return stringToKeywordForES(name, isStrict);
-        }
-    }
-
-    /**
-     * JavaScript 1.8 and earlier
-     */
-    private static int stringToKeywordForJS(String name)
+    private static int stringToKeyword(String name)
     {
 // #string_id_map#
 // The following assumes that Token.EOF == 0
@@ -267,161 +255,6 @@ class TokenStream
         return id & 0xff;
     }
 
-    /**
-     * ECMAScript 6.
-     */
-    private static int stringToKeywordForES(String name, boolean isStrict)
-    {
-// #string_id_map#
-// The following assumes that Token.EOF == 0
-        final int
-            // 11.6.2.1 Keywords (ECMAScript2015)
-            Id_break         = Token.BREAK,
-            Id_case          = Token.CASE,
-            Id_catch         = Token.CATCH,
-            Id_class         = Token.RESERVED,
-            Id_const         = Token.CONST,
-            Id_continue      = Token.CONTINUE,
-            Id_debugger      = Token.DEBUGGER,
-            Id_default       = Token.DEFAULT,
-            Id_delete        = Token.DELPROP,
-            Id_do            = Token.DO,
-            Id_else          = Token.ELSE,
-            Id_export        = Token.RESERVED,
-            Id_extends       = Token.RESERVED,
-            Id_finally       = Token.FINALLY,
-            Id_for           = Token.FOR,
-            Id_function      = Token.FUNCTION,
-            Id_if            = Token.IF,
-            Id_import        = Token.RESERVED,
-            Id_in            = Token.IN,
-            Id_instanceof    = Token.INSTANCEOF,
-            Id_new           = Token.NEW,
-            Id_return        = Token.RETURN,
-            Id_super         = Token.RESERVED,
-            Id_switch        = Token.SWITCH,
-            Id_this          = Token.THIS,
-            Id_throw         = Token.THROW,
-            Id_try           = Token.TRY,
-            Id_typeof        = Token.TYPEOF,
-            Id_var           = Token.VAR,
-            Id_void          = Token.VOID,
-            Id_while         = Token.WHILE,
-            Id_with          = Token.WITH,
-            Id_yield         = Token.YIELD,
-
-            // 11.6.2.2 Future Reserved Words
-            Id_await         = Token.RESERVED,
-            Id_enum          = Token.RESERVED,
-
-            // 11.6.2.2 NOTE Strict Future Reserved Words
-            Id_implements    = Token.RESERVED,
-            Id_interface     = Token.RESERVED,
-            Id_package       = Token.RESERVED,
-            Id_private       = Token.RESERVED,
-            Id_protected     = Token.RESERVED,
-            Id_public        = Token.RESERVED,
-
-            // 11.8 Literals
-            Id_false         = Token.FALSE,
-            Id_null          = Token.NULL,
-            Id_true          = Token.TRUE,
-
-            // Non ReservedWord, but Non IdentifierName in strict mode code.
-            // 12.1.1 Static Semantics: Early Errors
-            Id_let           = Token.LET,   // TODO : Valid IdentifierName in non-strict mode.
-            Id_static        = Token.RESERVED; 
-
-        int id;
-        String s = name;
-// #generated# Last update: 2007-04-18 13:53:30 PDT
-        L0: { id = 0; String X = null; int c;
-            L: switch (s.length()) {
-            case 2: c=s.charAt(1);
-                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }
-                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }
-                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }
-                break L;
-            case 3: switch (s.charAt(0)) {
-                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;
-                case 'l': if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_let; break L0;} break L;
-                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;
-                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;
-                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;
-                } break L;
-            case 4: switch (s.charAt(0)) {
-                case 'c': c=s.charAt(3);
-                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {id=Id_case; break L0;} }
-                    break L;
-                case 'e': c=s.charAt(3);
-                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {id=Id_else; break L0;} }
-                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {id=Id_enum; break L0;} }
-                    break L;
-                case 'n': X="null";id=Id_null; break L;
-                case 't': c=s.charAt(3);
-                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {id=Id_true; break L0;} }
-                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {id=Id_this; break L0;} }
-                    break L;
-                case 'v': X="void";id=Id_void; break L;
-                case 'w': X="with";id=Id_with; break L;
-                } break L;
-            case 5: switch (s.charAt(2)) {
-                case 'a': c=s.charAt(0);
-                    if (c=='c') { X="class";id=Id_class; }
-                    else if (c=='a') { X="await";id=Id_await; }
-                    break L;
-                case 'e': c=s.charAt(0);
-                    if (c=='b') { X="break";id=Id_break; }
-                    else if (c=='y') { X="yield";id=Id_yield; }
-                    break L;
-                case 'i': X="while";id=Id_while; break L;
-                case 'l': X="false";id=Id_false; break L;
-                case 'n': X="const";id=Id_const; break L;
-                case 'p': X="super";id=Id_super; break L;
-                case 'r': X="throw";id=Id_throw; break L;
-                case 't': X="catch";id=Id_catch; break L;
-                } break L;
-            case 6: switch (s.charAt(1)) {
-                case 'e': c=s.charAt(0);
-                    if (c=='d') { X="delete";id=Id_delete; }
-                    else if (c=='r') { X="return";id=Id_return; }
-                    break L;
-                case 'm': X="import";id=Id_import; break L;
-                case 't': if (isStrict) { X="static";id=Id_static; break L; }
-                case 'u': if (isStrict) { X="public";id=Id_public; break L; }
-                case 'w': X="switch";id=Id_switch; break L;
-                case 'x': X="export";id=Id_export; break L;
-                case 'y': X="typeof";id=Id_typeof; break L;
-                } break L;
-            case 7: switch (s.charAt(1)) {
-                case 'a': if (isStrict) { X="package";id=Id_package; break L; }
-                case 'e': X="default";id=Id_default; break L;
-                case 'i': X="finally";id=Id_finally; break L;
-                case 'r': if (isStrict) { X="private";id=Id_private; break L; }
-                case 'x': X="extends";id=Id_extends; break L;
-                } break L;
-            case 8: switch (s.charAt(0)) {
-                case 'c': X="continue";id=Id_continue; break L;
-                case 'd': X="debugger";id=Id_debugger; break L;
-                case 'f': X="function";id=Id_function; break L;
-                } break L;
-            case 9: c=s.charAt(0);
-                if (c=='i' && isStrict) { X="interface";id=Id_interface; }
-                else if (c=='p' && isStrict) { X="protected";id=Id_protected; }
-                break L;
-            case 10: c=s.charAt(1);
-                if (c=='m' && isStrict) { X="implements";id=Id_implements; }
-                else if (c=='n') { X="instanceof";id=Id_instanceof; }
-                break L;
-            }
-            if (X!=null && X!=s && !X.equals(s)) id = 0;
-        }
-// #/generated#
-// #/string_id_map#
-        if (id == 0) { return Token.EOF; }
-        return id & 0xff;
-    }
-
     final String getSourceString() { return sourceString; }
 
     final int getLineno() { return lineno; }
@@ -433,8 +266,6 @@ class TokenStream
     }
 
     final double getNumber() { return number; }
-    final boolean isNumberBinary() { return isBinary; }
-    final boolean isNumberOldOctal() { return isOldOctal; }
     final boolean isNumberOctal() { return isOctal; }
     final boolean isNumberHex() { return isHex; }
 
@@ -547,7 +378,7 @@ class TokenStream
                     // check if it's a keyword.
 
                     // Return the corresponding token if it's a keyword
-                    int result = stringToKeyword(str, parser.compilerEnv.getLanguageVersion(), parser.inUseStrictDirective());
+                    int result = stringToKeyword(str);
                     if (result != Token.EOF) {
                         if ((result == Token.LET || result == Token.YIELD) &&
                             parser.compilerEnv.getLanguageVersion()
@@ -562,13 +393,13 @@ class TokenStream
                         this.string = (String)allStrings.intern(str);
                         if (result != Token.RESERVED) {
                             return result;
-                        } else if (parser.compilerEnv.getLanguageVersion() >= Context.VERSION_ES6) {
-                            return result;
-                        } else if (!parser.compilerEnv.isReservedKeywordAsIdentifier()) {
+                        } else if (!parser.compilerEnv.
+                                        isReservedKeywordAsIdentifier())
+                        {
                             return result;
                         }
                     }
-                } else if (isKeyword(str, parser.compilerEnv.getLanguageVersion(), parser.inUseStrictDirective())) {
+                } else if (isKeyword(str)) {
                     // If a string contains unicodes, and converted to a keyword,
                     // we convert the last character back to unicode
                     str = convertLastCharToHex(str);
@@ -579,10 +410,10 @@ class TokenStream
 
             // is it a number?
             if (isDigit(c) || (c == '.' && isDigit(peekChar()))) {
+                isOctal = false;
                 stringBufferTop = 0;
                 int base = 10;
-                isHex = isOldOctal = isOctal = isBinary = false;
-                boolean es6 = parser.compilerEnv.getLanguageVersion() >= Context.VERSION_ES6;
+                isHex = isOctal = false;
 
                 if (c == '0') {
                     c = getChar();
@@ -590,59 +421,36 @@ class TokenStream
                         base = 16;
                         isHex = true;
                         c = getChar();
-                    } else if (es6 && (c == 'o' || c == 'O')) {
-                        base = 8;
-                        isOctal = true;
-                        c = getChar();
-                    } else if (es6 && (c == 'b' || c == 'B')) {
-                        base = 2;
-                        isBinary = true;
-                        c = getChar();
                     } else if (isDigit(c)) {
                         base = 8;
-                        isOldOctal = true;
+                        isOctal = true;
                     } else {
                         addToString('0');
                     }
                 }
 
-                boolean isEmpty = true;
                 if (base == 16) {
                     while (0 <= Kit.xDigitToInt(c, 0)) {
                         addToString(c);
                         c = getChar();
-                        isEmpty = false;
                     }
                 } else {
                     while ('0' <= c && c <= '9') {
+                        /*
+                         * We permit 08 and 09 as decimal numbers, which
+                         * makes our behavior a superset of the ECMA
+                         * numeric grammar.  We might not always be so
+                         * permissive, so we warn about it.
+                         */
                         if (base == 8 && c >= '8') {
-                            if (isOldOctal) {
-                                /*
-                                 * We permit 08 and 09 as decimal numbers, which
-                                 * makes our behavior a superset of the ECMA
-                                 * numeric grammar.  We might not always be so
-                                 * permissive, so we warn about it.
-                                 */
-                                parser.addWarning("msg.bad.octal.literal",
-                                                  c == '8' ? "8" : "9");
-                                base = 10;
-                            } else {
-                                parser.addError("msg.caught.nfe");
-                                return Token.ERROR;
-                            }
-                        } else if (base == 2 && c >= '2') {
-                            parser.addError("msg.caught.nfe");
-                            return Token.ERROR;
+                            parser.addWarning("msg.bad.octal.literal",
+                                              c == '8' ? "8" : "9");
+                            base = 10;
                         }
                         addToString(c);
                         c = getChar();
-                        isEmpty = false;
                     }
                 }
-                if (isEmpty && (isBinary || isOctal || isHex)) {
-                    parser.addError("msg.caught.nfe");
-                    return Token.ERROR;
-                }
 
                 boolean isInteger = true;
 
@@ -862,8 +670,6 @@ class TokenStream
                     } else {
                         return Token.EQ;
                     }
-                } else if (matchChar('>')) {
-                    return Token.ARROW;
                 } else {
                     return Token.ASSIGN;
                 }
@@ -1807,8 +1613,6 @@ class TokenStream
     // code.
     private String string = "";
     private double number;
-    private boolean isBinary;
-    private boolean isOldOctal;
     private boolean isOctal;
     private boolean isHex;
 
diff --git a/src/org/mozilla/javascript/Undefined.java b/src/org/mozilla/javascript/Undefined.java
index 07cf6e9..f652bd8 100644
--- a/src/org/mozilla/javascript/Undefined.java
+++ b/src/org/mozilla/javascript/Undefined.java
@@ -7,9 +7,6 @@
 package org.mozilla.javascript;
 
 import java.io.Serializable;
-import java.lang.reflect.InvocationHandler;
-import java.lang.reflect.Method;
-import java.lang.reflect.Proxy;
 
 /**
  * This class implements the Undefined value in JavaScript.
@@ -28,29 +25,4 @@ public class Undefined implements Serializable
     {
         return instance;
     }
-
-    @Override
-    public boolean equals(Object obj) {
-        return isUndefined(obj) || super.equals(obj);
-    }
-
-    public static final Scriptable SCRIPTABLE_UNDEFINED;
-
-    static {
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/TokenStream.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/Undefined.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/AstRoot.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/ForInLoop.java.
The file will have its original line endings in your working directory.
-        SCRIPTABLE_UNDEFINED = (Scriptable) Proxy.newProxyInstance(Undefined.class.getClassLoader(), new Class[]{Scriptable.class}, new InvocationHandler() {
-            @Override
-            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                if (method.getName().equals("toString")) return "undefined";
-                if (method.getName().equals("equals")) {
-                    return args.length > 0 && isUndefined(args[0]);
-                }
-                throw new UnsupportedOperationException("undefined doesn't support " + method.getName());
-            }
-        });
-    }
-
-    public static boolean isUndefined(Object obj)
-    {
-        return Undefined.instance == obj || Undefined.SCRIPTABLE_UNDEFINED == obj;
-    }
 }
diff --git a/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java b/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java
index c57c9d7..bb54180 100644
--- a/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java
+++ b/src/org/mozilla/javascript/ast/ArrayComprehensionLoop.java
@@ -53,7 +53,7 @@ public class ArrayComprehensionLoop extends ForInLoop {
                 + (isForEach()?"each ":"")
                 + "("
                 + iterator.toSource(0)
-                + (isForOf()?" of ":" in ")
+                + " in "
                 + iteratedObject.toSource(0)
                 + ")";
     }
diff --git a/src/org/mozilla/javascript/ast/AstRoot.java b/src/org/mozilla/javascript/ast/AstRoot.java
index bb09040..9a3e1d6 100644
--- a/src/org/mozilla/javascript/ast/AstRoot.java
+++ b/src/org/mozilla/javascript/ast/AstRoot.java
@@ -25,6 +25,7 @@ import java.util.TreeSet;
 public class AstRoot extends ScriptNode {
 
     private SortedSet<Comment> comments;
+    private boolean inStrictMode;
 
     {
         type = Token.SCRIPT;
@@ -75,6 +76,14 @@ public class AstRoot extends ScriptNode {
         comment.setParent(this);
     }
 
+    public void setInStrictMode(boolean inStrictMode) {
+        this.inStrictMode = inStrictMode;
+    }
+
+    public boolean isInStrictMode() {
+        return inStrictMode;
+    }
+
     /**
      * Visits the comment nodes in the order they appear in the source code.
      * The comments are not visited by the {@link #visit} function - you must
diff --git a/src/org/mozilla/javascript/ast/ForInLoop.java b/src/org/mozilla/javascript/ast/ForInLoop.java
index e557745..e5e98a6 100644
--- a/src/org/mozilla/javascript/ast/ForInLoop.java
+++ b/src/org/mozilla/javascript/ast/ForInLoop.java
@@ -9,12 +9,10 @@ package org.mozilla.javascript.ast;
 import org.mozilla.javascript.Token;
 
 /**
- * For-in or for-each-in or for-of statement.  Node type is {@link Token#FOR}.<p>
+ * For-in or for-each-in statement.  Node type is {@link Token#FOR}.<p>
  *
  * <pre><b>for</b> [<b>each</b>] ( LeftHandSideExpression <b>in</b> Expression ) Statement</pre>
  * <pre><b>for</b> [<b>each</b>] ( <b>var</b> VariableDeclarationNoIn <b>in</b> Expression ) Statement</pre>
- * <pre><b>for</b> ( LeftHandSideExpression <b>of</b> Expression ) Statement</pre>
- * <pre><b>for</b> ( ForDeclaration <b>of</b> Expression ) Statement</pre>
  */
 public class ForInLoop extends Loop {
 
@@ -23,7 +21,6 @@ public class ForInLoop extends Loop {
     protected int inPosition = -1;
     protected int eachPosition = -1;
     protected boolean isForEach;
-    protected boolean isForOf;
 
     {
         type = Token.FOR;
@@ -48,7 +45,7 @@ public class ForInLoop extends Loop {
     }
 
     /**
-     * Sets loop iterator expression:  the part before the "in" or "of" keyword.
+     * Sets loop iterator expression:  the part before the "in" keyword.
      * Also sets its parent to this node.
      * @throws IllegalArgumentException if {@code iterator} is {@code null}
      */
@@ -90,29 +87,15 @@ public class ForInLoop extends Loop {
     }
 
     /**
-     * Returns whether the loop is a for-of loop
-     */
-    public boolean isForOf() {
-        return isForOf;
-    }
-
-    /**
-     * Sets whether the loop is a for-each loop
-     */
-    public void setIsForOf(boolean isForOf) {
-        this.isForOf = isForOf;
-    }
-
-    /**
-     * Returns position of "in" or "of" keyword
+     * Returns position of "in" keyword
      */
     public int getInPosition() {
         return inPosition;
     }
 
     /**
-     * Sets position of "in" or "of" keyword
-     * @param inPosition position of "in" or "of" keyword,
+     * Sets position of "in" keyword
+     * @param inPosition position of "in" keyword,
      * or -1 if not present (e.g. in presence of a syntax error)
      */
     public void setInPosition(int inPosition) {
@@ -145,11 +128,7 @@ public class ForInLoop extends Loop {
         }
         sb.append("(");
         sb.append(iterator.toSource(0));
-        if (isForOf) {
-            sb.append(" of ");
-        } else {
-            sb.append(" in ");
-        }
+        sb.append(" in ");
         sb.append(iteratedObject.toSource(0));
         sb.append(") ");
         if (body.getType() == Token.BLOCK) {
diff --git a/src/org/mozilla/javascript/ast/FunctionNode.java b/src/org/mozilla/javascript/ast/FunctionNode.java
index 6dd58c0..315b0f1 100644
--- a/src/org/mozilla/javascript/ast/FunctionNode.java
+++ b/src/org/mozilla/javascript/ast/FunctionNode.java
@@ -63,9 +63,8 @@ public class FunctionNode extends ScriptNode {
     public static final int FUNCTION_STATEMENT            = 1;
     public static final int FUNCTION_EXPRESSION           = 2;
     public static final int FUNCTION_EXPRESSION_STATEMENT = 3;
-    public static final int ARROW_FUNCTION                = 4;
 
-    public static enum Form { FUNCTION, GETTER, SETTER, METHOD }
+    public static enum Form { FUNCTION, GETTER, SETTER }
 
     private static final List<AstNode> NO_PARAMS =
         Collections.unmodifiableList(new ArrayList<AstNode>());
@@ -271,7 +270,7 @@ public class FunctionNode extends ScriptNode {
      * if there is a lexical closure, or in a number of other situations.
      */
     public boolean requiresActivation() {
-        return needsActivation;
+    	return true;
     }
 
     public void setRequiresActivation() {
@@ -326,34 +325,26 @@ public class FunctionNode extends ScriptNode {
         functionType = type;
     }
 
-    public boolean isMethod() {
-        return functionForm == Form.GETTER || functionForm == Form.SETTER || functionForm == Form.METHOD;
+    public boolean isGetterOrSetter() {
+        return functionForm == Form.GETTER || functionForm == Form.SETTER;
     }
 
-    public boolean isGetterMethod() {
+    public boolean isGetter() {
         return functionForm == Form.GETTER;
     }
 
-    public boolean isSetterMethod() {
+    public boolean isSetter() {
         return functionForm == Form.SETTER;
     }
 
-    public boolean isNormalMethod() {
-        return functionForm == Form.METHOD;
-    }
-
-    public void setFunctionIsGetterMethod() {
+    public void setFunctionIsGetter() {
         functionForm = Form.GETTER;
     }
 
-    public void setFunctionIsSetterMethod() {
+    public void setFunctionIsSetter() {
         functionForm = Form.SETTER;
     }
 
-    public void setFunctionIsNormalMethod() {
-        functionForm = Form.METHOD;
-    }
-
     /**
      * Rhino supports a nonstandard Ecma extension that allows you to
      * say, for instance, function a.b.c(arg1, arg) {...}, and it will
@@ -377,12 +368,9 @@ public class FunctionNode extends ScriptNode {
     @Override
     public String toSource(int depth) {
         StringBuilder sb = new StringBuilder();
-        boolean isArrow = functionType == ARROW_FUNCTION;
-        if (!isMethod()) {
+        if (!isGetterOrSetter()) {
             sb.append(makeIndent(depth));
-            if (!isArrow) {
-                sb.append("function");
-            }
+            sb.append("function");
         }
         if (functionName != null) {
             sb.append(" ");
@@ -390,18 +378,11 @@ public class FunctionNode extends ScriptNode {
         }
         if (params == null) {
             sb.append("() ");
-        } else if (isArrow && lp == -1) {
-            // no paren
-            printList(params, sb);
-            sb.append(" ");
         } else {
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/FunctionNode.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/GeneratorExpressionLoop.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/ObjectProperty.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/ast/ScriptNode.java.
The file will have its original line endings in your working directory.
             sb.append("(");
             printList(params, sb);
             sb.append(") ");
         }
-        if (isArrow) {
-            sb.append("=> ");
-        }
         if (isExpressionClosure) {
             AstNode body = getBody();
             if (body.getLastChild() instanceof ReturnStatement) {
@@ -419,7 +400,7 @@ public class FunctionNode extends ScriptNode {
         } else {
             sb.append(getBody().toSource(depth).trim());
         }
-        if (functionType == FUNCTION_STATEMENT || isMethod()) {
+        if (functionType == FUNCTION_STATEMENT || isGetterOrSetter()) {
             sb.append("\n");
         }
         return sb.toString();
diff --git a/src/org/mozilla/javascript/ast/GeneratorExpressionLoop.java b/src/org/mozilla/javascript/ast/GeneratorExpressionLoop.java
index 04190bf..def55f2 100644
--- a/src/org/mozilla/javascript/ast/GeneratorExpressionLoop.java
+++ b/src/org/mozilla/javascript/ast/GeneratorExpressionLoop.java
@@ -44,7 +44,7 @@ public class GeneratorExpressionLoop extends ForInLoop {
                 + (isForEach()?"each ":"")
                 + "("
                 + iterator.toSource(0)
-                + (isForOf()?" of ":" in ")
+                + " in "
                 + iteratedObject.toSource(0)
                 + ")";
     }
diff --git a/src/org/mozilla/javascript/ast/ObjectProperty.java b/src/org/mozilla/javascript/ast/ObjectProperty.java
index 7fc347b..b01338f 100644
--- a/src/org/mozilla/javascript/ast/ObjectProperty.java
+++ b/src/org/mozilla/javascript/ast/ObjectProperty.java
@@ -44,8 +44,7 @@ public class ObjectProperty extends InfixExpression {
     public void setNodeType(int nodeType) {
         if (nodeType != Token.COLON
             && nodeType != Token.GET
-            && nodeType != Token.SET
-            && nodeType != Token.METHOD)
+            && nodeType != Token.SET)
             throw new IllegalArgumentException("invalid node type: "
                                                + nodeType);
         setType(nodeType);
@@ -65,51 +64,39 @@ public class ObjectProperty extends InfixExpression {
     /**
      * Marks this node as a "getter" property.
      */
-    public void setIsGetterMethod() {
+    public void setIsGetter() {
         type = Token.GET;
     }
 
     /**
      * Returns true if this is a getter function.
      */
-    public boolean isGetterMethod() {
+    public boolean isGetter() {
         return type == Token.GET;
     }
 
     /**
      * Marks this node as a "setter" property.
      */
-    public void setIsSetterMethod() {
+    public void setIsSetter() {
         type = Token.SET;
     }
 
     /**
      * Returns true if this is a setter function.
      */
-    public boolean isSetterMethod() {
+    public boolean isSetter() {
         return type == Token.SET;
     }
 
-    public void setIsNormalMethod() {
-        type = Token.METHOD;
-    }
-
-    public boolean isNormalMethod() {
-        return type == Token.METHOD;
-    }
-
-    public boolean isMethod() {
-        return isGetterMethod() || isSetterMethod() || isNormalMethod();
-    }
-
     @Override
     public String toSource(int depth) {
         StringBuilder sb = new StringBuilder();
         sb.append("\n");
         sb.append(makeIndent(depth+1));
-        if (isGetterMethod()) {
+        if (isGetter()) {
             sb.append("get ");
-        } else if (isSetterMethod()) {
+        } else if (isSetter()) {
             sb.append("set ");
         }
         sb.append(left.toSource(getType()==Token.COLON ? 0 : depth));
diff --git a/src/org/mozilla/javascript/ast/ScriptNode.java b/src/org/mozilla/javascript/ast/ScriptNode.java
index 5841bb9..0788d62 100644
--- a/src/org/mozilla/javascript/ast/ScriptNode.java
+++ b/src/org/mozilla/javascript/ast/ScriptNode.java
@@ -36,7 +36,6 @@ public class ScriptNode extends Scope {
 
     private Object compilerData;
     private int tempNumber = 0;
-    private boolean inStrictMode;
 
     {
         // during parsing, a ScriptNode or FunctionNode's top scope is itself
@@ -306,14 +305,6 @@ public class ScriptNode extends Scope {
         return "$" + tempNumber++;
     }
 
-    public void setInStrictMode(boolean inStrictMode) {
-        this.inStrictMode = inStrictMode;
-    }
-
-    public boolean isInStrictMode() {
-        return inStrictMode;
-    }
-
     @Override
     public void visit(NodeVisitor v) {
         if (v.visit(this)) {
diff --git a/src/org/mozilla/javascript/optimizer/Codegen.java b/src/org/mozilla/javascript/optimizer/Codegen.java
index 9ecceda..9d4a94a 100644
--- a/src/org/mozilla/javascript/optimizer/Codegen.java
+++ b/src/org/mozilla/javascript/optimizer/Codegen.java
@@ -264,7 +264,6 @@ public class Codegen implements Evaluator
     {
         boolean hasScript = (scriptOrFnNodes[0].getType() == Token.SCRIPT);
         boolean hasFunctions = (scriptOrFnNodes.length > 1 || !hasScript);
-        boolean isStrictMode = scriptOrFnNodes[0].isInStrictMode();
 
         String sourceFile = null;
         if (compilerEnv.isGenerateDebugInfo()) {
@@ -287,7 +286,7 @@ public class Codegen implements Evaluator
             generateExecute(cfw);
         }
 
-        generateCallMethod(cfw, isStrictMode);
+        generateCallMethod(cfw);
         generateResumeGenerator(cfw);
 
         generateNativeFunctionOverrides(cfw, encodedSource);
@@ -466,7 +465,7 @@ public class Codegen implements Evaluator
         cfw.stopMethod((short)6);
     }
 
-    private void generateCallMethod(ClassFileWriter cfw, boolean isStrictMode)
+    private void generateCallMethod(ClassFileWriter cfw)
     {
         cfw.startMethod("call",
                         "(Lorg/mozilla/javascript/Context;" +
@@ -493,7 +492,6 @@ public class Codegen implements Evaluator
         cfw.addALoad(2);
         cfw.addALoad(3);
         cfw.addALoad(4);
-        cfw.addPush(isStrictMode);
         cfw.addInvoke(ByteCode.INVOKESTATIC,
                       "org/mozilla/javascript/ScriptRuntime",
                       "doTopCall",
@@ -502,7 +500,6 @@ public class Codegen implements Evaluator
                       +"Lorg/mozilla/javascript/Scriptable;"
                       +"Lorg/mozilla/javascript/Scriptable;"
                       +"[Ljava/lang/Object;"
-                      +"Z"
                       +")Ljava/lang/Object;");
         cfw.add(ByteCode.ARETURN);
         cfw.markLabel(nonTopCallLabel);
@@ -1349,12 +1346,10 @@ class BodyCodegen
         cfw.addALoad(funObjLocal);
         cfw.addALoad(variableObjectLocal);
         cfw.addALoad(argsLocal);
-        cfw.addPush(scriptOrFn.isInStrictMode());
         addScriptRuntimeInvoke("createFunctionActivation",
                                "(Lorg/mozilla/javascript/NativeFunction;"
                                +"Lorg/mozilla/javascript/Scriptable;"
                                +"[Ljava/lang/Object;"
-                               +"Z"
                                +")Lorg/mozilla/javascript/Scriptable;");
         cfw.addAStore(variableObjectLocal);
 
@@ -1622,22 +1617,15 @@ class BodyCodegen
 
 
         String debugVariableName;
-        boolean isArrow = false;
-        if (scriptOrFn instanceof FunctionNode) {
-            isArrow = ((FunctionNode)scriptOrFn).getFunctionType() == FunctionNode.ARROW_FUNCTION;
-        }
         if (fnCurrent != null) {
             debugVariableName = "activation";
             cfw.addALoad(funObjLocal);
             cfw.addALoad(variableObjectLocal);
             cfw.addALoad(argsLocal);
-            String methodName = isArrow ? "createArrowFunctionActivation" : "createFunctionActivation";
-            cfw.addPush(scriptOrFn.isInStrictMode());
-            addScriptRuntimeInvoke(methodName,
+            addScriptRuntimeInvoke("createFunctionActivation",
                                    "(Lorg/mozilla/javascript/NativeFunction;"
                                    +"Lorg/mozilla/javascript/Scriptable;"
                                    +"[Ljava/lang/Object;"
-                                   +"Z"
                                    +")Lorg/mozilla/javascript/Scriptable;");
             cfw.addAStore(variableObjectLocal);
             cfw.addALoad(contextLocal);
@@ -2011,7 +1999,6 @@ class BodyCodegen
               case Token.ENUM_INIT_KEYS:
               case Token.ENUM_INIT_VALUES:
               case Token.ENUM_INIT_ARRAY:
-              case Token.ENUM_INIT_VALUES_IN_ORDER:
                 generateExpression(child, node);
                 cfw.addALoad(contextLocal);
                 cfw.addALoad(variableObjectLocal);
@@ -2019,8 +2006,6 @@ class BodyCodegen
                                    ? ScriptRuntime.ENUMERATE_KEYS :
                                type == Token.ENUM_INIT_VALUES
                                    ? ScriptRuntime.ENUMERATE_VALUES :
-                               type == Token.ENUM_INIT_VALUES_IN_ORDER
-                                   ? ScriptRuntime.ENUMERATE_VALUES_IN_ORDER :
                                ScriptRuntime.ENUMERATE_ARRAY;
                 cfw.addPush(enumType);
                 addScriptRuntimeInvoke("enumInit",
@@ -2187,8 +2172,7 @@ class BodyCodegen
                     OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn,
                                                              fnIndex);
                     int t = ofn.fnode.getFunctionType();
-                    if (t != FunctionNode.FUNCTION_EXPRESSION &&
-                        t != FunctionNode.ARROW_FUNCTION) {
+                    if (t != FunctionNode.FUNCTION_EXPRESSION) {
                         throw Codegen.badTree();
                     }
                     visitFunction(ofn, t);
@@ -2976,20 +2960,7 @@ class BodyCodegen
         cfw.addInvoke(ByteCode.INVOKESPECIAL, codegen.mainClassName,
                       "<init>", Codegen.FUNCTION_CONSTRUCTOR_SIGNATURE);
 
-        if (functionType == FunctionNode.ARROW_FUNCTION) {
-            cfw.addALoad(contextLocal);           // load 'cx'
-            cfw.addALoad(variableObjectLocal);
-            cfw.addALoad(thisObjLocal);
-            addOptRuntimeInvoke("bindThis",
-                                "(Lorg/mozilla/javascript/NativeFunction;"
-                                +"Lorg/mozilla/javascript/Context;"
-                                +"Lorg/mozilla/javascript/Scriptable;"
-                                +"Lorg/mozilla/javascript/Scriptable;"
-                                +")Lorg/mozilla/javascript/Function;");
-        }
-
-        if (functionType == FunctionNode.FUNCTION_EXPRESSION ||
-            functionType == FunctionNode.ARROW_FUNCTION) {
+        if (functionType == FunctionNode.FUNCTION_EXPRESSION) {
             // Leave closure object on stack and do not pass it to
             // initFunction which suppose to connect statements to scope
             return;
@@ -3180,7 +3151,7 @@ class BodyCodegen
             // see bug 757410 for an explanation why we need to split this
             for (int i = 0; i != count; ++i) {
                 int childType = child.getType();
-                if (childType == Token.GET || childType == Token.SET || childType == Token.METHOD) {
+                if (childType == Token.GET || childType == Token.SET) {
                     generateExpression(child.getFirstChild(), node);
                 } else {
                     generateExpression(child, node);
@@ -3202,7 +3173,7 @@ class BodyCodegen
                 cfw.add(ByteCode.DUP);
                 cfw.addPush(i);
                 int childType = child2.getType();
-                if (childType == Token.GET || childType == Token.SET || childType == Token.METHOD) {
+                if (childType == Token.GET || childType == Token.SET) {
                     generateExpression(child2.getFirstChild(), node);
                 } else {
                     generateExpression(child2, node);
@@ -4465,10 +4436,10 @@ Else pass the JS object in the aReg and 0.0 in the dReg.
                 } else {
                     cfw.addALoad(reg);
                 }
-                addObjectToDouble();
                 if (post) {
-                    cfw.add(ByteCode.DUP2);
+                    cfw.add(ByteCode.DUP);
                 }
+                addObjectToDouble();
                 cfw.addPush(1.0);
                 if ((incrDecrMask & Node.DECR_FLAG) == 0) {
                     cfw.add(ByteCode.DADD);
@@ -4480,9 +4451,6 @@ Else pass the JS object in the aReg and 0.0 in the dReg.
                     cfw.add(ByteCode.DUP);
                 }
                 cfw.addAStore(reg);
-                if (post) {
-                    addDoubleWrap();
-                }
             }
             break;
           case Token.NAME:
diff --git a/src/org/mozilla/javascript/optimizer/OptRuntime.java b/src/org/mozilla/javascript/optimizer/OptRuntime.java
index 78b8072..ef5856f 100644
--- a/src/org/mozilla/javascript/optimizer/OptRuntime.java
+++ b/src/org/mozilla/javascript/optimizer/OptRuntime.java
@@ -133,11 +133,6 @@ public final class OptRuntime extends ScriptRuntime
         ScriptRuntime.initFunction(cx, scope, fn, functionType, false);
     }
 
-    public static Function bindThis(NativeFunction fn, Context cx, Scriptable scope, Scriptable thisObj)
-    {
-        return new ArrowFunction(cx, scope, fn, thisObj);
-    }
-
     public static Object callSpecial(Context cx, Callable fun,
                                      Scriptable thisObj, Object[] args,
                                      Scriptable scope,
diff --git a/src/org/mozilla/javascript/regexp/NativeRegExp.java b/src/org/mozilla/javascript/regexp/NativeRegExp.java
index 5689a07..cc02af5 100644
--- a/src/org/mozilla/javascript/regexp/NativeRegExp.java
+++ b/src/org/mozilla/javascript/regexp/NativeRegExp.java
@@ -39,7 +39,8 @@ public class NativeRegExp extends IdScriptableObject implements Function
 {
     static final long serialVersionUID = 4965263491464903264L;
 
-    private static final Object REGEXP_TAG = new Object();
+    private static final Object REGEXP_TAG = new Serializable() {
+    };
 
     public static final int JSREG_GLOB = 0x1;       // 'g' flag: global
     public static final int JSREG_FOLD = 0x2;       // 'i' flag: fold
diff --git a/src/org/mozilla/javascript/resources/Messages.properties b/src/org/mozilla/javascript/resources/Messages.properties
index 2d65514..9943d49 100644
--- a/src/org/mozilla/javascript/resources/Messages.properties
+++ b/src/org/mozilla/javascript/resources/Messages.properties
@@ -498,8 +498,8 @@ msg.var.hides.arg =\
 msg.destruct.assign.no.init =\
     Missing = in destructuring declaration
 
-msg.no.old.octal.strict =\
-    Old octal numbers prohibited in strict mode.
+msg.no.octal.strict =\
+    Octal numbers prohibited in strict mode.
 
 msg.dup.obj.lit.prop.strict =\
     Property "{0}" already defined in this object literal.
@@ -526,12 +526,6 @@ msg.invalid.iterator =\
 msg.iterator.primitive =\
     __iterator__ returned a primitive value
 
-msg.not.iterable = \
-    {0} is not iterable
-
-msg.invalid.for.each = \
-    invalid for each loop
-
 msg.assn.create.strict =\
     Assignment to undeclared variable {0}
 
@@ -542,7 +536,7 @@ msg.prop.not.found =\
     Property {0} not found.
 
 msg.set.prop.no.setter =\
-    Cannot set property {0} that has only a getter.
+    Cannot set property [{1}].{0} that has only a getter to {2}.
 
 msg.invalid.type =\
     Invalid JavaScript value of type {0}
@@ -707,9 +701,6 @@ msg.change.property.accessor.to.data.with.configurable.false =\
 msg.not.extensible =\
     Cannot add properties to this object because extensible is false.
 
-msg.delete.property.with.configurable.false =\
-    Cannot delete "{0}" property because configurable is false.
-
 # TokenStream
 msg.missing.exponent =\
     missing exponent
@@ -852,10 +843,3 @@ msg.called.null.or.undefined=\
 
 msg.first.arg.not.regexp=\
   First argument to {0}.prototype.{1} must not be a regular expression
-
-msg.arrowfunction.generator =\
-  arrow function can not become generator
-
-# Arguments
-msg.arguments.not.access.strict =\
-  Cannot access "{0}" property of the arguments object in strict mode.
diff --git a/src/org/mozilla/javascript/typedarrays/NativeTypedArrayView.java b/src/org/mozilla/javascript/typedarrays/NativeTypedArrayView.java
index d6f7bc4..c676a8a 100644
--- a/src/org/mozilla/javascript/typedarrays/NativeTypedArrayView.java
+++ b/src/org/mozilla/javascript/typedarrays/NativeTypedArrayView.java
@@ -10,7 +10,6 @@ import org.mozilla.javascript.Context;
 import org.mozilla.javascript.ExternalArrayData;
 import org.mozilla.javascript.IdFunctionObject;
 import org.mozilla.javascript.NativeArray;
-import org.mozilla.javascript.NativeArrayIterator;
 import org.mozilla.javascript.ScriptRuntime;
 import org.mozilla.javascript.Scriptable;
 import org.mozilla.javascript.Undefined;
@@ -22,8 +21,6 @@ import java.util.List;
 import java.util.ListIterator;
 import java.util.RandomAccess;
 
-import static org.mozilla.javascript.NativeSymbol.ITERATOR_PROPERTY;
-
 /**
  * This class is the abstract parent for all of the various typed arrays. Each one
  * shows a view of a specific NativeArrayBuffer, and modifications here will affect the rest.
@@ -284,9 +281,6 @@ public abstract class NativeTypedArrayView<T>
             } else {
                 throw ScriptRuntime.constructError("Error", "invalid arguments");
             }
-
-        case Id_iterator:
-            return new NativeArrayIterator(scope, thisObj);
         }
         throw new IllegalArgumentException(String.valueOf(id));
     }
@@ -294,17 +288,16 @@ public abstract class NativeTypedArrayView<T>
     @Override
     protected void initPrototypeId(int id)
     {
-        String s, fnName = null;;
+        String s;
         int arity;
         switch (id) {
         case Id_constructor:        arity = 1; s = "constructor"; break;
         case Id_get:                arity = 1; s = "get"; break;
         case Id_set:                arity = 2; s = "set"; break;
         case Id_subarray:           arity = 2; s = "subarray"; break;
-        case Id_iterator:           arity = 0; s = ITERATOR_PROPERTY; fnName="[Symbol.iterator]"; break;
         default: throw new IllegalArgumentException(String.valueOf(id));
         }
-        initPrototypeMethod(getClassName(), id, s, fnName, arity);
+        initPrototypeMethod(getClassName(), id, s, arity);
     }
 
     // #string_id_map#
@@ -322,7 +315,6 @@ public abstract class NativeTypedArrayView<T>
                 else if (c=='s') { if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_set; break L0;} }
             }
             else if (s_length==8) { X="subarray";id=Id_subarray; }
-            else if (s_length==10) { X="@@iterator";id=Id_iterator; }
             else if (s_length==11) { X="constructor";id=Id_constructor; }
             if (X!=null && X!=s && !X.equals(s)) id = 0;
             break L0;
@@ -336,11 +328,10 @@ public abstract class NativeTypedArrayView<T>
         Id_constructor          = 1,
         Id_get                  = 2,
         Id_set                  = 3,
-        Id_subarray             = 4,
-        Id_iterator             = 5;
+        Id_subarray             = 4;
 
     protected static final int
-        MAX_PROTOTYPE_ID        = Id_iterator;
+        MAX_PROTOTYPE_ID        = Id_subarray;
 
 // #/string_id_map#
 
diff --git a/test262 b/test262
deleted file mode 160000
index acf2d0c..0000000
--- a/test262
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit acf2d0cb11659139e6821edc0aa971a160b15562
diff --git a/testsrc/benchmarks/caliper/fieldTests.js b/testsrc/benchmarks/caliper/fieldTests.js
deleted file mode 100644
index 4b84eb7..0000000
--- a/testsrc/benchmarks/caliper/fieldTests.js
+++ /dev/null
@@ -1,75 +0,0 @@
-function createObject(iterations, strings, ints) {
-  var o;
-  for (var ct = 0; ct < iterations; ct++) {
-    o = {};
-    var s = 0;
-    var i = 0;
-
-    while ((s < strings.length) && (i < ints.length)) {
-      if (s < strings.length) {
-        o[strings[s]] = strings[s];
-        s++;
-      }
-      if (i < ints.length) {
-        o[ints[i]] = ints[i];
-        i++;
-      }
-    }
-  }
-  return o;
-}
-
-function iterateObject(iterations, o) {
-  var x;
-  for (var ct = 0; ct < iterations; ct++) {
-    for (var k in o) {
-      x = o[k];
-    }
-  }
-  return x;
-}
-
-function iterateOwnKeysObject(iterations, o) {
-  var pn;
-  for (var ct = 0; ct < iterations; ct++) {
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/optimizer/Codegen.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/optimizer/OptRuntime.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/regexp/NativeRegExp.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/resources/Messages.properties.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in src/org/mozilla/javascript/typedarrays/NativeTypedArrayView.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/build.xml.
The file will have its original line endings in your working directory.
-    pn = Object.getOwnPropertyNames(o);
-  }
-  return pn;
-}
-
-function accessObject(iterations, o, strings, ints) {
-  var s = 0;
-  var i = 0;
-  for (var ct = 0; ct < iterations; ct++) {
-    if (strings.length > 0) {
-      var x = o[strings[s]];
-      s++;
-      if (s === strings.length) {
-        s = 0;
-      }
-    }
-    if (ints.length > 0) {
-      var x = o[ints[i]];
-      i++;
-      if (i === ints.length) {
-        i = 0;
-      }
-    }
-  }
-}
-
-function deleteObject(iterations, o, strings, ints) {
-  var s = 0;
-  var i = 0;
-
-  for (var ct = 0; ct < iterations; ct++) {
-    if (s < strings.length) {
-      delete o[strings[s]];
-      s++;
-    }
-    if (i < ints.length) {
-      delete o[ints[i]];
-      i++;
-    }
-  }
-}
\ No newline at end of file
diff --git a/testsrc/build.xml b/testsrc/build.xml
index bc50d94..769ccf6 100644
--- a/testsrc/build.xml
+++ b/testsrc/build.xml
@@ -15,7 +15,6 @@
   -->
   <property name="test.junit.url" value="http://repo1.maven.org/maven2/junit/junit/4.12/junit-4.12.jar"/>
   <property name="test.hamcrest.url" value="http://central.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar"/>
-  <property name="test.snakeyaml.url" value="http://central.maven.org/maven2/org/yaml/snakeyaml/1.15/snakeyaml-1.15.jar"/>
 
   <!--
     URL from which emma.jar can be retrieved
@@ -51,7 +50,6 @@
     <mkdir dir="lib"/>
     <get src="${test.junit.url}" dest="lib/junit.jar" usetimestamp="true"/>
     <get src="${test.hamcrest.url}" dest="lib/hamcrest.jar" usetimestamp="true"/>
-    <get src="${test.snakeyaml.url}" dest="lib/snakeyaml.jar" usetimestamp="true"/>
   </target>
 
   <target name="junit-compile">
@@ -66,7 +64,6 @@
       <classpath>
         <pathelement path="lib/junit.jar" />
         <pathelement path="lib/hamcrest.jar" />
-        <pathelement path="lib/snakeyaml.jar" />
         <pathelement path="${classes}" />
       </classpath>
       <src path="testsrc"/>
@@ -88,7 +85,6 @@
       <classpath>
         <pathelement path="lib/junit.jar" />
         <pathelement path="lib/hamcrest.jar" />
-        <pathelement path="lib/snakeyaml.jar" />
         <pathelement path="${classes}" />
       </classpath>
       <sourcepath path="testsrc" />
@@ -162,7 +158,6 @@
         <pathelement path="lib/emma.jar"/>
         <pathelement path="lib/junit.jar" />
         <pathelement path="lib/hamcrest.jar" />
-        <pathelement path="lib/snakeyaml.jar" />
         <pathelement location="${test.jstests.jar}"/>
       </classpath>
       <batchtest todir="build/test">
@@ -195,7 +190,6 @@
         <pathelement path="${test.classes}" />
         <pathelement path="lib/junit.jar" />
         <pathelement path="lib/hamcrest.jar" />
-        <pathelement path="lib/snakeyaml.jar" />
         <pathelement location="${test.jstests.jar}"/>
       </classpath>
 
@@ -217,7 +211,6 @@
         <pathelement path="${test.classes}" />
         <pathelement path="lib/junit.jar" />
         <pathelement path="lib/hamcrest.jar" />
-        <pathelement path="lib/snakeyaml.jar" />
         <pathelement location="${test.jstests.jar}"/>
       </classpath>
       <batchtest todir="build/test/benchmark">
diff --git a/testsrc/doctests/467396.doctest b/testsrc/doctests/467396.doctest
index e1519d3..543d554 100644
--- a/testsrc/doctests/467396.doctest
+++ b/testsrc/doctests/467396.doctest
@@ -2,17 +2,17 @@
 // License, v. 2.0. If a copy of the MPL was not distributed with this
 // file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-js> var a = java.lang.reflect.Array.newInstance(java.lang.Integer, [17,4]);
-js> a
-[[Ljava.lang.Integer;@1543c88
-js> a.length
-17
-js> a[0].length
-4
-js> var a = java.lang.reflect.Array.newInstance(java.lang.Integer, 17, 4);
-js> a
-[[Ljava.lang.Integer;@f11404
-js> a.length
-17
-js> a[0].length
-4
+js> var a = java.lang.reflect.Array.newInstance(java.lang.Integer, [17,4]);
+js> a
+[[Ljava.lang.Integer;@1543c88
+js> a.length
+17
+js> a[0].length
+4
+js> var a = java.lang.reflect.Array.newInstance(java.lang.Integer, 17, 4);
+js> a
+[[Ljava.lang.Integer;@f11404
+js> a.length
+17
+js> a[0].length
+4
diff --git a/testsrc/doctests/480758.doctest b/testsrc/doctests/480758.doctest
index 68ebe18..9a50bb0 100644
--- a/testsrc/doctests/480758.doctest
+++ b/testsrc/doctests/480758.doctest
@@ -2,20 +2,20 @@
 // License, v. 2.0. If a copy of the MPL was not distributed with this
 // file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-js> function primBeget(proto) {
-  >   if (proto === null) { fail("Cannot beget from null."); }
-  >   if (proto === (void 0)) { fail("Cannot beget from undefined."); }
-  >   function F() {}
-  >   F.prototype = proto;
-  >   var result = new F();
-  >   return result;
-  > }
-js> var x = [1].concat(primBeget(Array.prototype));
-js> x
-1,
-js> x[1]
-
-js> typeof x[1]
-object
-js> x[1] instanceof Array
+js> function primBeget(proto) {
+  >   if (proto === null) { fail("Cannot beget from null."); }
+  >   if (proto === (void 0)) { fail("Cannot beget from undefined."); }
+  >   function F() {}
+  >   F.prototype = proto;
+  >   var result = new F();
+  >   return result;
+  > }
+js> var x = [1].concat(primBeget(Array.prototype));
+js> x
+1,
+js> x[1]
+
+js> typeof x[1]
+object
+js> x[1] instanceof Array
 true
\ No newline at end of file
diff --git a/testsrc/doctests/iteratorKeys.doctest b/testsrc/doctests/iteratorKeys.doctest
index d623cd6..0558ba4 100644
--- a/testsrc/doctests/iteratorKeys.doctest
+++ b/testsrc/doctests/iteratorKeys.doctest
@@ -2,15 +2,15 @@
 // License, v. 2.0. If a copy of the MPL was not distributed with this
 // file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-js> version(170)
-0
-js> var foo = {
-  >   __iterator__ : function(onlyKeys) {
-  >     print(onlyKeys);
-  >     yield [0, "a"];
-  >   }
-  > };
warning: LF will be replaced by CRLF in testsrc/doctests/object.getownpropertydescriptor.doctest.-js> for each (let f in foo) {}
-false
-js> for (let f in foo) {}
+js> version(170)
+0

+js> var foo = {
+  >   __iterator__ : function(onlyKeys) {The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/jstests/extensions/stack-traces.js.
The file will have its original line endings in your working directory.

+  >     print(onlyKeys);
+  >     yield [0, "a"];
+  >   }
+  > };
+js> for each (let f in foo) {}
+false
+js> for (let f in foo) {}
 true
\ No newline at end of file
diff --git a/testsrc/doctests/object.getownpropertydescriptor.doctest b/testsrc/doctests/object.getownpropertydescriptor.doctest
index b0cac1b..b0eaff8 100644
--- a/testsrc/doctests/object.getownpropertydescriptor.doctest
+++ b/testsrc/doctests/object.getownpropertydescriptor.doctest
@@ -32,7 +32,8 @@ true
 js> var desc = Object.getOwnPropertyDescriptor({ get p() {}, set p() {} }, 'p');
 js> desc.value === undefined;
 true
-js> desc.writable
+js> desc.writable === undefined;
+true
 js> desc.get.toSource()
 (function () {})
 js> desc.set.toSource()
diff --git a/testsrc/jstests/arrowfn.jstest b/testsrc/jstests/arrowfn.jstest
deleted file mode 100644
index 635989f..0000000
--- a/testsrc/jstests/arrowfn.jstest
+++ /dev/null
@@ -1,182 +0,0 @@
-function assertEq(actual, expected) {
-  if (expected !== actual) {
-    throw "Expected '" + expected + "' but was '" + actual + "'";
-  }
-}
-
-function assertException(exception, fn) {
-  try {
-    fn();
-  } catch (e if e instanceof exception) {
-    return;
-  }
-  throw "Expected to throw '" + exception + "' but not thrown";
-}
-
-var f = a => a * a;
-assertEq(f(2), 4);
-assertEq(f.toString(), '\na => a * a\n');
-
-var f = (a) => a * a;
-assertEq(f(2), 4);
-assertEq(f.toString(), '\n(a) => a * a\n');
-
-var f = (a, b) => a * b;
-assertEq(f(2, 3), 6);
-
-var f = (a, b, c) => a * b + c;
-assertEq(f(2, 3, 4), 10);
-
-var f = () => 10;
-assertEq(f(), 10);
-
-var f = () => 10 * 2;
-assertEq(f(), 20);
-
-assertException(SyntaxError, function() {
-  eval('var f = ) => a * b;');
-});
-
-assertException(SyntaxError, function() {
-  eval('var f = ();');
-});
-
-var f = ([a, b]) => a * b;
-assertEq(f([2, 3]), 6);
-
-var f = ({ a: a, b: b}) => a * b;
-assertEq(f({ a: 10, b: 20 }), 200);
-
-var f = a => {
-  return a * a;
-};
-assertEq(f(10), 100);
-assertEq(f.toString(), '\na => {\n    return a * a;\n}\n');
-
-var f = a => {
-  a * a;
-};
-assertEq(f(10), undefined);
-
-var f = (a) => {
-  return a * a;
-};
-assertEq(f(10), 100);
-
-var f = (a) => {
-  a * a;
-};
-assertEq(f(10), undefined);
-
-var f = () => {
-  return 10;
-};
-assertEq(f(), 10);
-
-var f = () => {
-  10;
-};
-assertEq(f(), undefined);
-
-assertException(SyntaxError, function() {
-  eval("function() { 'use strict'; var f = (a, a) => {} }");
-});
-
-assertException(SyntaxError, function() {
-  eval("function() { 'use strict'; var f = (eval) => {} }");
-});
-
-assertException(SyntaxError, function() {
-  eval("function() { 'use strict'; var f = (arguments) => {} }");
-});
-
-assertException(SyntaxError, function() {
-  eval("function() { 'use strict'; var f = (123) => {} }");
-});
-
-assertException(SyntaxError, function() {
-  eval("var f = () => { yield 10; };");
-});
-
-var o = {
-  a: 1
-};
-(function() {
-  var f = () => this;
-  assertEq(f(), o);
-  assertEq(f().a, 1);
-}).call(o);
-
-var o = {
-  a: 1
-};
-var f = (function() {
-  return () => this;
-}).call(o);
-assertEq(f(), o);
-assertEq(f().a, 1);
-
-var o = {};
-(function() {
-  var f = () => () => this;
-  assertEq(f()(), o);
-}).call(o);
-
-var o1 = {}, o2 = {};
-(function() {
-  (function() {
-    var f = () => this;
-    assertEq(f(), o2);
-  }).call(o2);
-}).call(o1);
-
-var o = {};
-(function() {
-  var f;
-  if (String) {
-    f = () => this;
-  }
-  assertEq(f(), o);
-}).call(o);
-
-var o = {};
-(function() {
-  var f;
-  with (String) {
-    f = () => this;
-  }
-  assertEq(f(), o);
-}).call(o);
-
-var f = (function() {
-  return () => this.a + 3;
-}).call({ a: 1 });
-assertEq(f(), 4);
-
-assertException(TypeError, function() {
-  var f = () => 10;
-  new f();
-});
-
-assertException(TypeError, function() {
-  var f = () => 10, g = f.bind();
-  new g();
-});
-
-var f = (function() {
-  return () => arguments[0] + arguments[1];
-})(1, 2);
-assertEq(f(3, 4), 3);
-
-var f = () => 10;
-assertEq(f.prototype, undefined);
-
-var f = () => {
-  var n = 0;
-  return () => n++;
-};
-var g = f();
-assertEq(g(), 0);
-assertEq(g(), 1);
-
-"success";
diff --git a/testsrc/jstests/extensions/stack-traces.js b/testsrc/jstests/extensions/stack-traces.js
index f99602f..532dfa7 100644
--- a/testsrc/jstests/extensions/stack-traces.js
+++ b/testsrc/jstests/extensions/stack-traces.js
@@ -180,48 +180,4 @@ try {
   assertTrue(/Custom 2/.test(e.stack));
   assertTrue(/nestedThrower/.test(e.stack));
   assertTrue(/parentThrower/.test(e.stack));
-}
-
-// test that all the functions on a stack frame work
-
-function printFrame(l, f) {
-  var o =
-    {typeofThis: typeof f.getThis(),
-     typeName: f.getTypeName(),
-     function: f.getFunction(),
-    functionName: f.getFunctionName(),
-    methodName: f.getMethodName(),
-    fileName: f.getFileName(),
-    lineNumber: f.getLineNumber(),
-    columnNumber: f.getColumnNumber(),
-    evalOrigin: f.getEvalOrigin(),
-    topLevel: f.isToplevel(),
-    eval: f.isEval(),
-    native: f.isNative(),
-    constructor: f.isConstructor()
-    };
-
-  l.push(o);
-  return l;
-}
-
-Error.prepareStackTrace = function (e, frames) {
-  return frames.reduce(printFrame, []);
-};
-
-try {
-  grandparentThrower('testing stack');
-} catch (e) {
-  e.stack.forEach(function (f) {
-    verifyFrame(f);
-  });
-}
-
-function verifyFrame(f) {
-  assertEquals(typeof f.fileName, 'string');
-  assertEquals(typeof f.lineNumber, 'number');
-  assertEquals(typeof f.topLevel, 'boolean');
-  assertEquals(typeof f.eval, 'boolean');
-  assertEquals(typeof f.native, 'boolean');
-  assertEquals(typeof f.constructor, 'boolean');
-}
+}
\ No newline at end of file
diff --git a/testsrc/jstests/harmony/array-find.js b/testsrc/jstests/harmony/array-find.js
index c45924f..bebb193 100644
--- a/testsrc/jstests/harmony/array-find.js
+++ b/testsrc/jstests/harmony/array-find.js
@@ -4,307 +4,216 @@
 
 load("testsrc/assert.js");
 
-//
-// Test The length of 'Array.prototype.find' is 1
-// (22.1.3.8)
-(function () {
-    assertEquals(1, Array.prototype.find.length);
-})();
+assertEquals(1, Array.prototype.find.length);
 
-//
-// Quick check for base cases
-//
-(function () {
-    var a = [21, 22, 23, 24];
+var a = [21, 22, 23, 24];
+assertEquals(undefined, a.find(function() { return false; }));
+assertEquals(21, a.find(function() { return true; }));
+assertEquals(undefined, a.find(function(val) { return 121 === val; }));
+assertEquals(24, a.find(function(val) { return 24 === val; }));
+assertEquals(23, a.find(function(val) { return 23 === val; }), null);
+assertEquals(22, a.find(function(val) { return 22 === val; }), undefined);
 
-    // well, it works
-    assertEquals(a[0], a.find(function () { return true; }));
-
-    // predicate is called with current value, index and object on which `find()` was called
-    assertEquals(a[3], a.find(function (val, i, array) { return array === a && i === 3; }));
-
-    // 'this' can be augmented by second optional parameter
-    var thisArg = {};
-    assertEquals(a[0], a.find(function () { return this === thisArg; }, thisArg));
-
-    // when nothing found, `undefined` is returned
-    assertEquals(undefined, a.find(function () { return false; }));
-
-    // it is not required to return Boolean, it will be automatically casted
-    assertEquals(a[2], a.find(function (val) { return (val === a[2] ? "true" : null); }));
-})();
-
-//
-// Test predicate is anything that has [[Call]] internal method
-//
-(function () {
-    var a = [21, 22, 23, 24];
-
-    // `InterpretedFunction` or `? extends NativeFunction`
-    assertEquals(a[0], a.find(function () { return true; }));
-    // `IdScriptableObject`
-    assertEquals(a[0], a.find(Object.prototype.toString));
-    assertEquals(a[0], a.find(String));
-    // `BoundFunction`
-    assertEquals(a[0], a.find((function () { return true; }).bind({})))
-})();
 
 //
 // Test predicate is not called when array is empty
 //
-(function () {
-    var l = -1;
-    var o = -1;
-    var v = -1;
-    var k = -1;
+(function() {
+  var a = [];
+  var l = -1;
+  var o = -1;
+  var v = -1;
+  var k = -1;
 
-    [].find(function (val, key, obj) {
-        o = obj;
-        l = obj.length;
-        v = val;
-        k = key;
+  a.find(function(val, key, obj) {
+    o = obj;
+    l = obj.length;
+    v = val;
+    k = key;
 
-        return false;
-    });
+    return false;
+  });
 
-    assertEquals(-1, l);
-    assertEquals(-1, o);
-    assertEquals(-1, v);
-    assertEquals(-1, k);
+  assertEquals(-1, l);
+  assertEquals(-1, o);
+  assertEquals(-1, v);
+  assertEquals(-1, k);
 })();
 
+
 //
-// Test predicate is called with correct arguments
+// Test predicate is called with correct argumetns
 //
-(function () {
-    var a = ["b"];
-    var l = -1;
-    var o = -1;
-    var v = -1;
-    var k = -1;
+(function() {
+  var a = ["b"];
+  var l = -1;
+  var o = -1;
+  var v = -1;
+  var k = -1;
 
-    var found = a.find(function (val, key, obj) {
-        o = obj;
-        l = obj.length;
-        v = val;
-        k = key;
+  var found = a.find(function(val, key, obj) {
+    o = obj;
+    l = obj.length;
+    v = val;
+    k = key;
 
-        return false;
-    });
+    return false;
+  });
 
-    assertArrayEquals(a, o);
-    assertEquals(a.length, l);
-    assertEquals("b", v);
-    assertEquals(0, k);
-    assertEquals(undefined, found);
+  assertArrayEquals(a, o);
+  assertEquals(a.length, l);
+  assertEquals("b", v);
+  assertEquals(0, k);
+  assertEquals(undefined, found);
 })();
 
+
 //
 // Test predicate is called array.length times
 //
-(function () {
-    var a = [1, 2, 3, 4, 5];
-    var l = 0;
-    var sawUndefined = false;
-    var predicate = function p(v) {
-        l++;
-        sawUndefined = sawUndefined || (v === undefined);
-    };
+(function() {
+  var a = [1, 2, 3, 4, 5];
+  var l = 0;
+  var found = a.find(function() {
+    l++;
+    return false;
+  });
 
-    a.find(predicate);
-    assertEquals(a.length, l);
-    assertFalse(sawUndefined);
-
-    // even for sparse arrays
-    a = new Array(10);
-    l = 0;
-    a.find(predicate);
-    assertEquals(a.length, l);
-    assertTrue(sawUndefined);
-
-    a = [];
-    a[10] = 1;
-    l = 0;
-    sawUndefined = false;
-    a.find(predicate);
-    assertEquals(a.length, l);
-    assertTrue(sawUndefined);
+  assertEquals(a.length, l);
+  assertEquals(undefined, found);
 })();
 
 
 //
-// Test Array.prototype.find is generic and works with String
+// Test Array.prototype.find works with String
 //
-(function () {
-    var a = "abcd";
-    var l = -1;
-    var o = -1;
-    var v = -1;
-    var k = -1;
-    var found = Array.prototype.find.call(a, function (val, key, obj) {
-        o = obj.toString();
-        l = obj.length;
-        v = val;
-        k = key;
+(function() {
+  var a = "abcd";
+  var l = -1;
+  var o = -1;
+  var v = -1;
+  var k = -1;
+  var found = Array.prototype.find.call(a, function(val, key, obj) {
+    o = obj.toString();
+    l = obj.length;
+    v = val;
+    k = key;
 
-        return false;
-    });
+    return false;
+  });
 
-    assertEquals(a, o);
-    assertEquals(a.length, l);
-    assertEquals("d", v);
-    assertEquals(3, k);
-    assertEquals(undefined, found);
+  assertEquals(a, o);
+  assertEquals(a.length, l);
+  assertEquals("d", v);
+  assertEquals(3, k);
+  assertEquals(undefined, found);
 
-    found = Array.prototype.find.apply(a, [function (val, key, obj) {
-        o = obj.toString();
-        l = obj.length;
-        v = val;
-        k = key;
+  found = Array.prototype.find.apply(a, [function(val, key, obj) {
+    o = obj.toString();
+    l = obj.length;
+    v = val;
+    k = key;
 
-        return true;
-    }]);
+    return true;
+  }]);
 
-    assertEquals(a, o);
-    assertEquals(a.length, l);
-    assertEquals("a", v);
-    assertEquals(0, k);
-    assertEquals("a", found);
+  assertEquals(a, o);
+  assertEquals(a.length, l);
+  assertEquals("a", v);
+  assertEquals(0, k);
+  assertEquals("a", found);
 })();
 
-//
-// Test Array.prototype.find works with simple arraylike objects
-//
-(function () {
-    var o = {0: 0, 1: 1, 2: 2, length: 3};
-    assertEquals(o[2], Array.prototype.find.call(o, function (v) { return v == o[2]; }));
-    assertEquals(o[1], Array.prototype.find.apply(o, [function (v) { return v == o[1]; }]));
 
-    // object without `length` property defined,
-    // behaves as if it has `length` set 0
-    var empty = {0: 0, 1: 1, 2: 2};
-    var called = false;
-    Array.prototype.find.call(empty, function () { called = true; });
-    assertEquals(false, called);
+//
+// Test Array.prototype.find works with exotic object
+//
+(function() {
+  var l = -1;
+  var o = -1;
+  var v = -1;
+  var k = -1;
+  var a = {
+    prop1: "val1",
+    prop2: "val2",
+    isValid: function() {
+      return this.prop1 === "val1" && this.prop2 === "val2";
+    }
+  };
+
+  Array.prototype.push.apply(a, [30, 31, 32]);
+  var found = Array.prototype.find.call(a, function(val, key, obj) {
+    o = obj;
+    l = obj.length;
+    v = val;
+    k = key;
+
+    return !obj.isValid();
+  });
+
+  assertArrayEquals(a, o);
+  assertEquals(3, l);
+  assertEquals(32, v);
+  assertEquals(2, k);
+  assertEquals(undefined, found);
 })();
 
-//
-// Test Array.prototype.find works with mixed arraylike objects
-//
-(function () {
-    var l = -1;
-    var o = -1;
-    var v = -1;
-    var k = -1;
-    var a = {
-        prop1: "val1",
-        prop2: "val2",
-        isValid: function () {
-            return this.prop1 === "val1" && this.prop2 === "val2";
-        },
-        length: 0
-    };
-
-    Array.prototype.push.apply(a, [30, 31, 32]);
-    var found = Array.prototype.find.call(a, function (val, key, obj) {
-        o = obj;
-        l = obj.length;
-        v = val;
-        k = key;
-
-        return !obj.isValid();
-    });
-
-    assertArrayEquals(a, o);
-    assertEquals(3, l);
-    assertEquals(32, v);
-    assertEquals(2, k);
-    assertEquals(undefined, found);
-})();
-
-//
-// Test Array.prototype.find works with arraylike object with getters
-//
-(function () {
-    var count = 0;
-    var a = {get 0() { return count++; }, length: 1};
-    // FIXME: right now, Rhino will get raw getter function
-    //        during iteration and use it as a value passed to predicate
-    //Array.prototype.find.call(a, (function () { return true; }));
-    //assertEquals(1, count);
-})();
-
-//
-// Test Array.prototype.find iteration includes inherited properties
-//
-(function () {
-    var o1 = {0: 0, 1: 1};
-    var o2 = {2: 2, length: 3};
-    // FIXME: use Object.setPrototypeOf instead
-    o2.__proto__ = o1;
-    var a = [];
-    Array.prototype.find.call(o2, function (v) { a.push(v); });
-    assertEquals([0, 1, 2], a);
-    assertEquals(o1[0], Array.prototype.find.call(o2, function () { return true; }));
-})();
 
 //
 // Test array modifications
 //
-(function () {
-    var a = [1, 2, 3];
-    var found = a.find(function (val) {
-        a.push(val);
-        return false;
-    });
-    assertArrayEquals([1, 2, 3, 1, 2, 3], a);
-    assertEquals(6, a.length);
-    assertEquals(undefined, found);
+(function() {
+  var a = [1, 2, 3];
+  var found = a.find(function(val) { a.push(val); return false; });
+  assertArrayEquals([1, 2, 3, 1, 2, 3], a);
+  assertEquals(6, a.length);
+  assertEquals(undefined, found);
 
-    a = [1, 2, 3];
-    found = a.find(function (val, key) {
-        a[key] = ++val;
-        return false;
-    });
-    assertArrayEquals([2, 3, 4], a);
-    assertEquals(3, a.length);
-    assertEquals(undefined, found);
+  a = [1, 2, 3];
+  found = a.find(function(val, key) { a[key] = ++val; return false; });
+  assertArrayEquals([2, 3, 4], a);
+  assertEquals(3, a.length);
+  assertEquals(undefined, found);
 })();
 
+
+//
+// Test predicate is only called for existing elements
+//
+(function() {
+  var a = new Array(30);
+  a[11] = 21;
+  a[7] = 10;
+  a[29] = 31;
+
+  var count = 0;
+  a.find(function() { count++; return false; });
+  assertEquals(3, count);
+})();
+
+
 //
 // Test thisArg
 //
-(function () {
-    // If thisArg is not provided, predicate is invoked with this set to `undefined`
-    // FIXME:
-    // var o = -1;
-    //[1,2].find(function () { o = this; });
-    //assertEquals(undefined, o);
+(function() {
+  // Test String as a thisArg
+  var found = [1, 2, 3].find(function(val, key) {
+    return this.charAt(Number(key)) === String(val);
+  }, "321");
+  assertEquals(2, found);
 
-    // Test String as a thisArg
-    var found = [1, 2, 3].find(function (val, key) {
-        return this.charAt(Number(key)) === String(val);
-    }, "321");
-    assertEquals(2, found);
+  // Test object as a thisArg
+  var thisArg = {
+    elementAt: function(key) {
+      return this[key];
+    }
+  };
+  Array.prototype.push.apply(thisArg, ["c", "b", "a"]);
 
-    // Test object as a thisArg
-    var thisArg = {
-        elementAt: function (key) {
-            return this[key];
-        }
-    };
-    Array.prototype.push.apply(thisArg, ["c", "b", "a"]);
-
-    found = ["a", "b", "c"].find(function (val, key) {
-        return this.elementAt(key) === val;
-    }, thisArg);
-    assertEquals("b", found);
-
-    // Test array itself as thisArg
-    var o;
-    var a = [1, 2];
-    a.find(function () { o = this; }, a);
-    assertEquals(a, o);
+  found = ["a", "b", "c"].find(function(val, key) {
+    return this.elementAt(key) === val;
+  }, thisArg);
+  assertEquals("b", found);
 })();
 
 // Test exceptions
diff --git a/testsrc/jstests/harmony/array-findIndex.js b/testsrc/jstests/harmony/array-findIndex.js
index 6a7ce28..000e3db 100644
--- a/testsrc/jstests/harmony/array-findIndex.js
+++ b/testsrc/jstests/harmony/array-findIndex.js
@@ -1,64 +1,27 @@
-// This Source Code Form is subject to the terms of the Mozilla Public
-// License, v. 2.0. If a copy of the MPL was not distributed with this
-// file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
 load("testsrc/assert.js");
 
-//
-// Test The length of 'Array.prototype.findIndex' is 1
-// (22.1.3.9)
-(function () {
-    assertEquals(1, Array.prototype.findIndex.length);
-})();
+assertEquals(1, Array.prototype.findIndex.length);
 
-//
-// Quick check for base cases
-//
-(function () {
-    var a = [21, 22, 23, 24];
+var a = [21, 22, 23, 24];
+assertEquals(-1, a.findIndex(function() { return false; }));
+assertEquals(-1, a.findIndex(function(val) { return 121 === val; }));
+assertEquals(0, a.findIndex(function() { return true; }));
+assertEquals(1, a.findIndex(function(val) { return 22 === val; }), undefined);
+assertEquals(2, a.findIndex(function(val) { return 23 === val; }), null);
+assertEquals(3, a.findIndex(function(val) { return 24 === val; }));
 
-    // well, it works
-    assertEquals(0, a.findIndex(function () { return true; }));
-
-    // predicate is called with current value, index and object on which `findIndex()` was called
-    assertEquals(3, a.findIndex(function (val, i, array) { return array === a && i === 3; }));
-
-    // 'this' can be augmented by second optional parameter
-    var thisArg = {};
-    assertEquals(0, a.findIndex(function () { return this === thisArg; }, thisArg));
-
-    // when nothing found, `-1` is returned
-    assertEquals(-1, a.findIndex(function () { return false; }));
-
-    // it is not required to return Boolean, it will be automatically casted
-    assertEquals(2, a.findIndex(function (val) { return (val === a[2] ? "true" : null); }));
-})();
-
-//
-// Test predicate is anything that has [[Call]] internal method
-//
-(function () {
-    var a = [21, 22, 23, 24];
-
-    // `InterpretedFunction` or `? extends NativeFunction`
-    assertEquals(0, a.findIndex(function () { return true; }));
-    // `IdScriptableObject`
-    assertEquals(0, a.findIndex(Object.prototype.toString));
-    assertEquals(0, a.findIndex(String));
-    // `BoundFunction`
-    assertEquals(0, a.findIndex((function () { return true; }).bind({})))
-})();
 
 //
 // Test predicate is not called when array is empty
 //
-(function () {
+(function() {
+    var a = [];
     var l = -1;
     var o = -1;
     var v = -1;
     var k = -1;
 
-    [].findIndex(function (val, key, obj) {
+    a.findIndex(function(val, key, obj) {
         o = obj;
         l = obj.length;
         v = val;
@@ -73,17 +36,18 @@ load("testsrc/assert.js");
     assertEquals(-1, k);
 })();
 
+
 //
-// Test predicate is called with correct arguments
+// Test predicate is called with correct argumetns
 //
-(function () {
+(function() {
     var a = ["b"];
     var l = -1;
     var o = -1;
     var v = -1;
     var k = -1;
 
-    var found = a.findIndex(function (val, key, obj) {
+    var index = a.findIndex(function(val, key, obj) {
         o = obj;
         l = obj.length;
         v = val;
@@ -96,52 +60,37 @@ load("testsrc/assert.js");
     assertEquals(a.length, l);
     assertEquals("b", v);
     assertEquals(0, k);
-    assertEquals(-1, found);
+    assertEquals(-1, index);
 })();
 
+
 //
 // Test predicate is called array.length times
 //
-(function () {
+(function() {
     var a = [1, 2, 3, 4, 5];
     var l = 0;
-    var sawUndefined = false;
-    var predicate = function p(v) {
+
+    a.findIndex(function() {
         l++;
-        sawUndefined = sawUndefined || (v === undefined);
-    };
+        return false;
+    });
 
-    a.findIndex(predicate);
     assertEquals(a.length, l);
-    assertFalse(sawUndefined);
-
-    // even for sparse arrays
-    a = new Array(10);
-    l = 0;
-    a.findIndex(predicate);
-    assertEquals(a.length, l);
-    assertTrue(sawUndefined);
-
-    a = [];
-    a[10] = 1;
-    l = 0;
-    sawUndefined = false;
-    a.findIndex(predicate);
-    assertEquals(a.length, l);
-    assertTrue(sawUndefined);
 })();
 
 
 //
-// Test Array.prototype.findIndex is generic and works with String
+// Test Array.prototype.findIndex works with String
 //
-(function () {
+(function() {
     var a = "abcd";
     var l = -1;
     var o = -1;
     var v = -1;
     var k = -1;
-    var found = Array.prototype.findIndex.call(a, function (val, key, obj) {
+
+    var index = Array.prototype.findIndex.call(a, function(val, key, obj) {
         o = obj.toString();
         l = obj.length;
         v = val;
@@ -154,9 +103,9 @@ load("testsrc/assert.js");
     assertEquals(a.length, l);
     assertEquals("d", v);
     assertEquals(3, k);
-    assertEquals(-1, found);
+    assertEquals(-1, index);
 
-    found = Array.prototype.findIndex.apply(a, [function (val, key, obj) {
+    index = Array.prototype.findIndex.apply(a, [function(val, key, obj) {
         o = obj.toString();
         l = obj.length;
         v = val;
@@ -169,29 +118,14 @@ load("testsrc/assert.js");
     assertEquals(a.length, l);
     assertEquals("a", v);
     assertEquals(0, k);
-    assertEquals(0, found);
+    assertEquals(0, index);
 })();
 
-//
-// Test Array.prototype.findIndex works with simple arraylike objects
-//
-(function () {
-    var o = {0: 0, 1: 1, 2: 2, length: 3};
-    assertEquals(2, Array.prototype.findIndex.call(o, function (v) { return v == o[2]; }));
-    assertEquals(1, Array.prototype.findIndex.apply(o, [function (v) { return v == o[1]; }]));
-
-    // object without `length` property defined,
-    // behaves as if it has `length` set 0
-    var empty = {0: 0, 1: 1, 2: 2};
-    var called = false;
-    Array.prototype.findIndex.call(empty, function () { called = true; });
-    assertEquals(false, called);
-})();
 
 //
-// Test Array.prototype.findIndex works with mixed arraylike objects
+// Test Array.prototype.findIndex works with exotic object
 //
-(function () {
+(function() {
     var l = -1;
     var o = -1;
     var v = -1;
@@ -199,14 +133,14 @@ load("testsrc/assert.js");
     var a = {
         prop1: "val1",
         prop2: "val2",
-        isValid: function () {
+        isValid: function() {
             return this.prop1 === "val1" && this.prop2 === "val2";
-        },
-        length: 0
+        }
     };
 
     Array.prototype.push.apply(a, [30, 31, 32]);
-    var found = Array.prototype.findIndex.call(a, function (val, key, obj) {
+
+    var index = Array.prototype.findIndex.call(a, function(val, key, obj) {
         o = obj;
         l = obj.length;
         v = val;
@@ -219,92 +153,63 @@ load("testsrc/assert.js");
     assertEquals(3, l);
     assertEquals(32, v);
     assertEquals(2, k);
-    assertEquals(-1, found);
+    assertEquals(-1, index);
 })();
 
-//
-// Test Array.prototype.findIndex works with arraylike object with getters
-//
-(function () {
-    var count = 0;
-    var a = {get 0() { return count++; }, length: 1};
-    // FIXME: right now, Rhino will get raw getter function
-    //        during iteration and use it as a value passed to predicate
-    //Array.prototype.findIndex.call(a, (function () { return true; }));
-    //assertEquals(1, count);
-})();
-
-//
-// Test Array.prototype.findIndex iteration includes inherited properties
-//
-(function () {
-    var o1 = {0: 0, 1: 1};
-    var o2 = {2: 2, length: 3};
-    // FIXME: use Object.setPrototypeOf instead
-    o2.__proto__ = o1;
-    var a = [];
-    Array.prototype.findIndex.call(o2, function (v) { a.push(v); });
-    assertEquals([0, 1, 2], a);
-    assertEquals(0, Array.prototype.findIndex.call(o2, function () { return true; }));
-})();
 
 //
 // Test array modifications
 //
-(function () {
+(function() {
     var a = [1, 2, 3];
-    var found = a.findIndex(function (val) {
-        a.push(val);
-        return false;
-    });
+    a.findIndex(function(val) { a.push(val); return false; });
     assertArrayEquals([1, 2, 3, 1, 2, 3], a);
     assertEquals(6, a.length);
-    assertEquals(-1, found);
 
     a = [1, 2, 3];
-    found = a.findIndex(function (val, key) {
-        a[key] = ++val;
-        return false;
-    });
+    a.findIndex(function(val, key) { a[key] = ++val; return false; });
     assertArrayEquals([2, 3, 4], a);
     assertEquals(3, a.length);
-    assertEquals(-1, found);
 })();
 
+
+//
+// Test predicate is only called for existing elements
+//
+(function() {
+    var a = new Array(30);
+    a[11] = 21;
+    a[7] = 10;
+    a[29] = 31;
+
+    var count = 0;
+    a.findIndex(function() { count++; return false; });
+    assertEquals(3, count);
+})();
+
+
 //
 // Test thisArg
 //
-(function () {
-    // If thisArg is not provided, predicate is invoked with this set to `undefined`
-    // FIXME:
-    // var o = -1;
-    //[1,2].findIndex(function () { o = this; });
-    //assertEquals(undefined, o);
-
-    // Test String as a thisArg
-    var found = [1, 2, 3].findIndex(function (val, key) {
+(function() {
+//    Test String as a thisArg
+    var index = [1, 2, 3].findIndex(function(val, key) {
         return this.charAt(Number(key)) === String(val);
     }, "321");
-    assertEquals(1, found);
+    assertEquals(1, index);
 
-    // Test object as a thisArg
+//    Test object as a thisArg
     var thisArg = {
-        elementAt: function (key) {
+        elementAt: function(key) {
             return this[key];
         }
     };
     Array.prototype.push.apply(thisArg, ["c", "b", "a"]);
 
-    found = ["a", "b", "c"].findIndex(function (val, key) {
+    index = ["a", "b", "c"].findIndex(function(val, key) {
         return this.elementAt(key) === val;
     }, thisArg);
-    assertEquals(1, found);
-
-    // Test array itself as thisArg
-    var o;
-    var a = [1, 2];
-    a.findIndex(function () { o = this; }, a);
-    assertEquals(a, o);
+    assertEquals(1, index);
 })();
 
 // Test exceptions
@@ -343,4 +248,4 @@ assertThrows('Array.prototype.findIndex.apply({}, {}, [])', TypeError);
 assertThrows('Array.prototype.findIndex.apply({}, [], [])', TypeError);
 assertThrows('Array.prototype.findIndex.apply({}, /\d+/, [])', TypeError);
 
-"success";
+"success";
\ No newline at end of file
diff --git a/testsrc/jstests/harmony/for-of.js b/testsrc/jstests/harmony/for-of.js
deleted file mode 100644
index af51d6f..0000000
--- a/testsrc/jstests/harmony/for-of.js
+++ /dev/null
@@ -1,162 +0,0 @@
-
-load("testsrc/assert.js");
-
-// Array
-var r = [];
-for (var n of [1, 2, 3]) {
-  r.push(n*2);
-}
-assertEquals('2,4,6', r.join());
-
-var r = [];
-for (var n of [1, 2, 3]) {
-  for (var m of [4, 5, 6]) {
-    r.push(n + m);
-  }
-}
-assertEquals('5,6,7,6,7,8,7,8,9', r.join());
-
-var a = [0];
-var r = [];
-var i = 0;
-for (var n of a) {
-  i++;
-  if (i < 3) {
-    a[i] = i;
-  }
-  r.push(n);
-}
-assertEquals('0,1,2', r.join());
-
-var a = [0, 1, 2];
-var r = [];
-var i = 0;
-for (var n of a) {
-  a.length = 0;
-  r.push(n);
-}
-assertEquals('0', r.join());
-
-// Array like
-var a = {
-  '0': 'foo',
-  '1': 'bar',
-  length: 2
-};
-var ite = Array.prototype[Symbol.iterator].call(a);
-var r;
-r = ite.next();
-assertEquals('foo', r.value);
-assertFalse(r.done);
-r = ite.next();
-assertEquals('bar', r.value);
-assertFalse(r.done);
-r = ite.next();
-assertTrue(r.done);
-
-// Other
-var a = {};
-a[Symbol.iterator] = function() {
-  var n = 0;
-  return {
-    next: function() {
-      if (n >= 3) {
-        return {
-          done: true
-        };
-      }
-      return {
-        value: n++,
-        done: false
-      };
-    }
-  };
-};
-var r = [];
-for (var n of a) {
-  r.push(n);
-}
-assertEquals('0,1,2', r.join());
-
-var a = [12];
-Object.defineProperty(a, 0, {
-  enumerable: false
-});
-for (var n of a) {
-  assertEquals(12, n);
-}
-
-// String
-var a = 'abc';
-var r = '';
-for (var c of a) {
-  r += c.toUpperCase();
-}
-assertEquals('ABC', r);
-
-// No iterable
-assertThrows(function() {
-  for (var n of null) {}
-}, TypeError);
-
-assertThrows(function() {
-  for (var n of 0) {}
-}, TypeError);
-
-assertThrows(function() {
-  var a = {};
-  a[Symbol.iterator] = function() {
-    return 0;
-  };
-  for (var n of 1) {}
-}, TypeError);
-
-// Array comprehension
-assertEquals('1,4,9', [n*n for (n of [1, 2, 3])].join());
-assertEquals('5,6,7,6,7,8,7,8,9', [n+m for (n of [1, 2, 3]) for (m of [4, 5, 6])].join());
-
-// 'of' is not ECMAScript keywords.
-var of = 10;
-assertEquals(10, of);
-
-(function() {
-  function of() { return 12; }
-  assertEquals(12, of());
-})();
-
-function f(of) { return of*2; }
-assertEquals(24, f(12));
-
-// for each-of is SyntaxError
-assertThrows('for each (n of [1,2]) {}', SyntaxError);
-
-assertThrows('[n*n for each (n of [1,2])]', SyntaxError);
-
-assertEquals('[Symbol.iterator]', Array.prototype[Symbol.iterator].name);
-assertEquals('[Symbol.iterator]', String.prototype[Symbol.iterator].name);
-
-// should have `value` and `done` property.
-var a = {};
-a[Symbol.iterator] = function() {
-  return {
-    next() {
-      return null;
-    }
-  };
-};
-assertThrows(function() {
-  for (var b of a);
-}, TypeError);
-
-var string = '';
-var first = '';
-var second = '';
-var third = '';
-for (var c of string) {
-  assertEquals(c, first);
-  first = second;
-  second = third;
-  third = null;
-}
-
-"success"
diff --git a/testsrc/jstests/harmony/math-functions.js b/testsrc/jstests/harmony/math-functions.js
deleted file mode 100644
index 5b0eabe..0000000
--- a/testsrc/jstests/harmony/math-functions.js
+++ /dev/null
@@ -1,57 +0,0 @@
-load("testsrc/assert.js");
-
-assertEquals(Math.cbrt(-1), -1);
-assertEquals(Math.cbrt(0), 0);
-assertEquals(Math.cbrt(1), 1);
-assertEquals(Math.cbrt(2), 1.2599210498948732);
-
-assertEquals(Math.cosh(0), 1);
-assertEquals(Math.cosh(1), 1.543080634815244);
-assertEquals(Math.cosh(-1), 1.543080634815244);
-
-assertEquals(Math.expm1(-1), -0.6321205588285577);
-assertEquals(Math.expm1(0), 0);
-assertEquals(Math.expm1(1), 1.718281828459045);
-
-assertEquals(Math.hypot(3, 4), 5);
-assertEquals(Math.hypot(3, 4, 5), 7.0710678118654755);
-assertEquals(Math.hypot(), 0);
-assertEquals(Math.hypot(NaN), NaN);
-assertEquals(Math.hypot(3, 4, 'foo'), NaN);
-assertEquals(Math.hypot(3, 4, '5'), 7.0710678118654755);
-assertEquals(Math.hypot(-3), 3);
-
-assertEquals(Math.log1p(1), 0.6931471805599453);
-assertEquals(Math.log1p(0), 0);
-assertEquals(Math.log1p(-1), -Infinity);
-assertEquals(Math.log1p(-2), NaN);
-
-assertEquals(Math.log10(2), 0.3010299956639812);
-assertEquals(Math.log10(1), 0);
-assertEquals(Math.log10(0), -Infinity);
-assertEquals(Math.log10(-2), NaN);
-assertEquals(Math.log10(100000), 5);
-
-assertEquals(Math.sinh(0), 0);
-assertEquals(Math.sinh(1), 1.1752011936438014);
-
-assertEquals(Math.tanh(0), 0);
-assertEquals(Math.tanh(Infinity), 1);
-assertEquals(Math.tanh(1), 0.7615941559557649);
-
-assertEquals(Math.trunc(13.37), 13);
-assertEquals(Math.trunc(42.84), 42);
-assertEquals(Math.trunc(0.123), 0);
-assertEquals(Math.trunc(-0.123), -0);
-assertEquals(Math.trunc('-1.123'), -1);
-assertEquals(Math.trunc(NaN), NaN);
-assertEquals(Math.trunc('foo'), NaN);
-assertEquals(Math.trunc(), NaN);
-
-assertEquals(Math.imul(2, 4), 8);
-assertEquals(Math.imul(-1, 8), -8);
-assertEquals(Math.imul(-2, -2), 4);
-assertEquals(Math.imul(0xffffffff, 5), -5);
-assertEquals(Math.imul(0xfffffffe, 5), -10);
-
-"success";
diff --git a/testsrc/jstests/harmony/method-definition.js b/testsrc/jstests/harmony/method-definition.js
deleted file mode 100644
index 77f2581..0000000
--- a/testsrc/jstests/harmony/method-definition.js
+++ /dev/null
@@ -1,82 +0,0 @@
-// This Source Code Form is subject to the terms of the Mozilla Public
-// License, v. 2.0. If a copy of the MPL was not distributed with this
-// file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-load("testsrc/assert.js");
-
-var obj;
-
-obj = {
-  a() {
-    return 123;
-  }
-};
-assertEquals(123, obj.a());
-// assertEquals("a", obj.a.name);
-
-assertEquals("abcefg", {
-  abc() {
-    return "abc";
-  },
-  efg() {
-    return this.abc() + "efg";
-  }
-}.efg());
-
-obj = {
-  get() {
-    return 123;
-  }
-};
-assertEquals(123, obj.get());
-// assertEquals("get", obj.get.name);
-
-obj = {
-  set() {
-    return 123;
-  }
-};
-assertEquals(123, obj.set());
-// assertEquals("set", obj.set.name);
-
-assertEquals("\n" +
-"function () {\n" +
-"    +{f() {\n" +
-"        print(1);\n" +
-"    }};\n" +
-"}\n", (function() { +{ f() { print(1); }}; }).toString());
-
-// Allow reserved word
-assertEquals(123, {
-  if() {
-    return 123;
-  }
-}.if());
-
-// Allow NumericLiteral
-assertEquals(123, {
-  123() {
-    return 123;
-  }
-}[123]());
-
-// Allow StringLiteral
-assertEquals(123, {
-  'abc'() {
-    return 123;
-  }
-}.abc());
-
-// Method is the kind of function, that is non-constructor.
-// assertThrows('new (({ a() {} }).a)', TypeError);
-
-var desc = Object.getOwnPropertyDescriptor({
-  a() {
-    return 123;
-  }
-}, 'a');
-assertEquals(true, desc.writable);
-assertEquals(true, desc.enumerable);
-assertEquals(true, desc.configurable);
-
-"success";
diff --git a/testsrc/jstests/harmony/number-is.js b/testsrc/jstests/harmony/number-is.js
deleted file mode 100644
index cca8193..0000000
--- a/testsrc/jstests/harmony/number-is.js
+++ /dev/null
@@ -1,131 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-//       notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-//       copyright notice, this list of conditions and the following
-//       disclaimer in the documentation and/or other materials provided
-//       with the distribution.
-//     * Neither the name of Google Inc. nor the names of its
-//       contributors may be used to endorse or promote products derived
-//       from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// Test number predicates that Harmony adds to the Number constructor:
-// isFinite(), isNaN(), isInteger(), isSafeInteger().
-
-load("testsrc/assert.js");
-
-assertTrue(Number.isFinite(0));
-assertTrue(Number.isFinite(Number.MIN_VALUE));
-assertTrue(Number.isFinite(Number.MAX_VALUE));
-assertTrue(Number.isFinite(Number.MIN_SAFE_INTEGER));
-assertTrue(Number.isFinite(Number.MIN_SAFE_INTEGER - 13));
-assertTrue(Number.isFinite(Number.MAX_SAFE_INTEGER));
-assertTrue(Number.isFinite(Number.MAX_SAFE_INTEGER + 23));
-assertFalse(Number.isFinite(Number.NaN));
-assertFalse(Number.isFinite(Number.POSITIVE_INFINITY));
-assertFalse(Number.isFinite(Number.NEGATIVE_INFINITY));
-assertFalse(Number.isFinite(new Number(0)));
-assertFalse(Number.isFinite(1/0));
-assertFalse(Number.isFinite(-1/0));
-assertFalse(Number.isFinite({}));
-assertFalse(Number.isFinite([]));
-assertFalse(Number.isFinite("s"));
-assertFalse(Number.isFinite(null));
-assertFalse(Number.isFinite(undefined));
-
-assertFalse(Number.isNaN(0));
-assertFalse(Number.isNaN(Number.MIN_VALUE));
-assertFalse(Number.isNaN(Number.MAX_VALUE));
-assertFalse(Number.isNaN(Number.MIN_SAFE_INTEGER - 13));
-assertFalse(Number.isNaN(Number.MAX_SAFE_INTEGER + 23));
-assertTrue(Number.isNaN(Number.NaN));
-assertFalse(Number.isNaN(Number.POSITIVE_INFINITY));
-assertFalse(Number.isNaN(Number.NEGATIVE_INFINITY));
-assertFalse(Number.isNaN(Number.EPSILON));
-assertFalse(Number.isNaN(new Number(0)));
-assertFalse(Number.isNaN(1/0));
-assertFalse(Number.isNaN(-1/0));
-assertFalse(Number.isNaN({}));
-assertFalse(Number.isNaN([]));
-assertFalse(Number.isNaN("s"));
-assertFalse(Number.isNaN(null));
-assertFalse(Number.isNaN(undefined));
-
-assertFalse(Number.isInteger({}));
-assertFalse(Number.isInteger([]));
-assertFalse(Number.isInteger("s"));
-assertFalse(Number.isInteger(null));
-assertFalse(Number.isInteger(undefined));
-assertFalse(Number.isInteger(new Number(2)));
-assertTrue(Number.isInteger(0));
-assertFalse(Number.isInteger(Number.MIN_VALUE));
-assertTrue(Number.isInteger(Number.MAX_VALUE));
-assertTrue(Number.isInteger(Number.MIN_SAFE_INTEGER));
-assertTrue(Number.isInteger(Number.MIN_SAFE_INTEGER - 13));
-assertTrue(Number.isInteger(Number.MAX_SAFE_INTEGER));
-assertTrue(Number.isInteger(Number.MAX_SAFE_INTEGER + 23));
-assertFalse(Number.isInteger(Number.NaN));
-assertFalse(Number.isInteger(Number.POSITIVE_INFINITY));
-assertFalse(Number.isInteger(Number.NEGATIVE_INFINITY));
-assertFalse(Number.isInteger(1/0));
-assertFalse(Number.isInteger(-1/0));
-assertFalse(Number.isInteger(Number.EPSILON));
-
-assertFalse(Number.isSafeInteger({}));
-assertFalse(Number.isSafeInteger([]));
-assertFalse(Number.isSafeInteger("s"));
-assertFalse(Number.isSafeInteger(null));
-assertFalse(Number.isSafeInteger(undefined));
-assertFalse(Number.isSafeInteger(new Number(2)));
-assertTrue(Number.isSafeInteger(0));
-assertTrue(Number.isSafeInteger(Number.MIN_SAFE_INTEGER));
-assertFalse(Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 13));
-assertTrue(Number.isSafeInteger(Number.MIN_SAFE_INTEGER + 13));
-assertTrue(Number.isSafeInteger(Number.MAX_SAFE_INTEGER));
-assertFalse(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 23));
-assertTrue(Number.isSafeInteger(Number.MAX_SAFE_INTEGER - 23));
-assertFalse(Number.isSafeInteger(Number.MIN_VALUE));
-assertFalse(Number.isSafeInteger(Number.MAX_VALUE));
-assertFalse(Number.isSafeInteger(Number.NaN));
-assertFalse(Number.isSafeInteger(Number.POSITIVE_INFINITY));
-assertFalse(Number.isSafeInteger(Number.NEGATIVE_INFINITY));
-assertFalse(Number.isSafeInteger(1/0));
-assertFalse(Number.isSafeInteger(-1/0));
-assertFalse(Number.isSafeInteger(Number.EPSILON));
-
-var near_upper = Math.pow(2, 52);
-assertTrue(Number.isSafeInteger(near_upper));
-assertFalse(Number.isSafeInteger(2 * near_upper));
-assertTrue(Number.isSafeInteger(2 * near_upper - 1));
-assertTrue(Number.isSafeInteger(2 * near_upper - 2));
-assertFalse(Number.isSafeInteger(2 * near_upper + 1));
-assertFalse(Number.isSafeInteger(2 * near_upper + 2));
-assertFalse(Number.isSafeInteger(2 * near_upper + 7));
-
-var near_lower = -near_upper;
-assertTrue(Number.isSafeInteger(near_lower));
-assertFalse(Number.isSafeInteger(2 * near_lower));
-assertTrue(Number.isSafeInteger(2 * near_lower + 1));
-assertTrue(Number.isSafeInteger(2 * near_lower + 2));
-assertFalse(Number.isSafeInteger(2 * near_lower - 1));
-assertFalse(Number.isSafeInteger(2 * near_lower - 2));
-assertFalse(Number.isSafeInteger(2 * near_lower - 7));
-
-"success";
-
diff --git a/testsrc/jstests/harmony/parse-int-float.js b/testsrc/jstests/harmony/parse-int-float.js
deleted file mode 100644
index f07b23f..0000000
--- a/testsrc/jstests/harmony/parse-int-float.js
+++ /dev/null
@@ -1,134 +0,0 @@
-// Copyright 2008 the V8 project authors. All rights reserved.
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-//       notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-//       copyright notice, this list of conditions and the following
-//       disclaimer in the documentation and/or other materials provided
-//       with the distribution.
-//     * Neither the name of Google Inc. nor the names of its
-//       contributors may be used to endorse or promote products derived
-//       from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-load("testsrc/assert.js");
-
-assertEquals(0, parseInt('0'));
-assertEquals(0, parseInt(' 0'));
-assertEquals(0, parseInt(' 0 '));
-
-// Not yet supported in Rhino
-/*
-assertEquals(77, parseInt('077'));
-assertEquals(77, parseInt('  077'));
-assertEquals(77, parseInt('  077   '));
-assertEquals(-77, parseInt('  -077'));
-*/
-
-assertEquals(3, parseInt('11', 2));
-assertEquals(4, parseInt('11', 3));
-assertEquals(4, parseInt('11', 3.8));
-
-assertEquals(0x12, parseInt('0x12'));
-assertEquals(0x12, parseInt('0x12', 16));
-assertEquals(0x12, parseInt('0x12', 16.1));
-assertEquals(0x12, parseInt('0x12', NaN));
-assertTrue(isNaN(parseInt('0x  ')));
-assertTrue(isNaN(parseInt('0x')));
-assertTrue(isNaN(parseInt('0x  ', 16)));
-assertTrue(isNaN(parseInt('0x', 16)));
-assertEquals(12, parseInt('12aaa'));
-
-assertEquals(0.1, parseFloat('0.1'));
-assertEquals(0.1, parseFloat('0.1aaa'));
-assertEquals(0, parseFloat('0aaa'));
-assertEquals(0, parseFloat('0x12'));
-assertEquals(77, parseFloat('077'));
-
-assertEquals(Infinity, parseInt('1000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '0000000000000'));
-
-assertEquals(Infinity, parseInt('0x10000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '000000000000000000000000000000000000000000000000000000000000000000000000'
-    + '0000000000000'));
-
-
-var i;
-var y = 10;
-
-for (i = 1; i < 21; i++) {
-  var x = eval("1.2e" + i);
-  assertEquals(Math.floor(x), parseInt(x));
-  x = eval("1e" + i);
-  assertEquals(x, y);
-  y *= 10;
-  assertEquals(Math.floor(x), parseInt(x));
-  x = eval("-1e" + i);
-  assertEquals(Math.ceil(x), parseInt(x));
-  x = eval("-1.2e" + i);
-  assertEquals(Math.ceil(x), parseInt(x));
-}
-
-for (i = 21; i < 53; i++) {
-  var x = eval("1e" + i);
-  assertEquals(1, parseInt(x));
-  x = eval("-1e" + i);
-  assertEquals(-1, parseInt(x));
-}
-
-assertTrue(isNaN(parseInt(0/0)));
-assertTrue(isNaN(parseInt(1/0)), "parseInt Infinity");
-assertTrue(isNaN(parseInt(-1/0)), "parseInt -Infinity");
-
-assertTrue(isNaN(parseFloat(0/0)));
-assertEquals(Infinity, parseFloat(1/0), "parseFloat Infinity");
-assertEquals(-Infinity, parseFloat(-1/0), "parseFloat -Infinity");
-
-var state;
-var throwingRadix = { valueOf: function() { state = "throwingRadix"; throw null; } };
-var throwingString = { toString: function() { state = "throwingString"; throw null; } };
-state = null;
-try { parseInt('123', throwingRadix); } catch (e) {}
-assertEquals(state, "throwingRadix");
-
-state = null;
-try { parseInt(throwingString, 10); } catch (e) {}
-assertEquals(state, "throwingString");
-
-state = null;
-try { parseInt(throwingString, throwingRadix); } catch (e) {}
-assertEquals(state, "throwingString");
-
-// And finally, check that the Harmony additions to the Number
-// constructor is available:
-assertTrue("parseInt" in Number);
-assertTrue("parseFloat" in Number);
-// V8 makes these the same function -- no reason to do that (or way) in Rhino.
-//assertSame( Number.parseInt, parseInt);
-//assertSame(Number.parseFloat, parseFloat);
-assertEquals(Number.parseFloat('0.1'), parseFloat('0.1'));
-assertEquals(Number.parseInt('0xea'), parseInt('0xEA'));
-
-"success";
-
diff --git a/testsrc/jstests/harmony/property-ordering.js b/testsrc/jstests/harmony/property-ordering.js
deleted file mode 100644
index 096fe55..0000000
--- a/testsrc/jstests/harmony/property-ordering.js
+++ /dev/null
@@ -1,37 +0,0 @@
-load("testsrc/assert.js");
-
-function verifyOrder(o, a) {
-  assertArrayEquals(a, Object.keys(o));
-  n = [];
-  for (var k in o) {
-    n.push(k);
-  }
-  assertArrayEquals(a, n);
-}
-
-var o = {
-  "z": 1,
-  "b": 2,
-  "d": 3,
-};
-o.x = 4;
-verifyOrder(o, [ "z", "b", "d", "x" ]);
-
-o = {
-  10: 1,
-  2: 2,
-  9: 3,
-};
-o[3] = 4;
-verifyOrder(o, [ "2", "3", "9", "10" ]);
-
-o = {
-  "z": 1,
-  3: 2,
-  "c": 3,
-};
-o.b = 4;
-o[99] = 5;
-verifyOrder(o, [ "3", "99", "z", "c", "b" ]);
-
-"success";
diff --git a/testsrc/jstests/harmony/symbols.js b/testsrc/jstests/harmony/symbols.js
deleted file mode 100644
index 459336c..0000000
--- a/testsrc/jstests/harmony/symbols.js
+++ /dev/null
@@ -1,24 +0,0 @@
-load("testsrc/assert.js");
-
-assertTrue(Symbol.iterator !== undefined);
-let desc = Object.getOwnPropertyDescriptor(Symbol, "iterator");
-assertFalse(desc.writable);
-assertFalse(desc.configurable);
-assertFalse(desc.enumerable);
-
-assertTrue(Symbol.toStringTag !== undefined);
-desc = Object.getOwnPropertyDescriptor(Symbol, "toStringTag");
-assertFalse(desc.writable);
-assertFalse(desc.configurable);
-assertFalse(desc.enumerable);
-
-assertTrue(Symbol.species !== undefined);
-desc = Object.getOwnPropertyDescriptor(Symbol, "species");
-assertFalse(desc.writable);
-assertFalse(desc.configurable);
-assertFalse(desc.enumerable);
-
-assertEquals("symbol", typeof Symbol());
-assertEquals("symbol", typeof Symbol("qwe"));
-
-"success";
diff --git a/testsrc/jstests/inc-dec.js b/testsrc/jstests/inc-dec.js
deleted file mode 100644
index a64189a..0000000
--- a/testsrc/jstests/inc-dec.js
+++ /dev/null
@@ -1,61 +0,0 @@
-load("testsrc/assert.js");
-
-var v1, v2, v3, v4;
-
-assertEquals(NaN, ++v1);
-assertEquals(NaN, --v2);
-assertEquals(NaN, v3++);
-assertEquals(NaN, v4--);
-
-const c1 = undefined, c2 = undefined, c3 = undefined, c4 = undefined;
-
-assertEquals(NaN, ++c1);
-assertEquals(NaN, --c2);
-assertEquals(NaN, c3++);
-assertEquals(NaN, c4--);
-assertEquals(undefined, c1);
-assertEquals(undefined, c2);
-assertEquals(undefined, c3);
-assertEquals(undefined, c4);
-
-let l1, l2, l3, l4;
-
-assertEquals(NaN, ++l1);
-assertEquals(NaN, --l2);
-assertEquals(NaN, l3++);
-assertEquals(NaN, l4--);
-
-(function(a1, a2, a3, a4) {
-  var v1, v2, v3, v4;
-
-  assertEquals(NaN, ++v1);
-  assertEquals(NaN, --v2);
-  assertEquals(NaN, v3++);
-  assertEquals(NaN, v4--);
-
-  assertEquals(NaN, ++a1);
-  assertEquals(NaN, --a2);
-  assertEquals(NaN, a3++);
-  assertEquals(NaN, a4--);
-
-  // const c1 = undefined, c2 = undefined, c3 = undefined, c4 = undefined;
-
-  // assertThrows('++c1',TypeError);
-  // assertThrows('--c2',TypeError);
-  // assertThrows('c3++',TypeError);
-  // assertThrows('c4--',TypeError);
-  // assertEquals(undefined, c1);
-  // assertEquals(undefined, c2);
-  // assertEquals(undefined, c3);
-  // assertEquals(undefined, c4);
-
-  let l1, l2, l3, l4;
-
-  assertEquals(NaN, ++l1);
-  assertEquals(NaN, --l2);
-  assertEquals(NaN, l3++);
-  assertEquals(NaN, l4--);
-})();
-
-
-"success";
diff --git a/testsrc/jstests/inside-strict-mode.js b/testsrc/jstests/inside-strict-mode.js
deleted file mode 100644
index b8ff5e8..0000000
--- a/testsrc/jstests/inside-strict-mode.js
+++ /dev/null
@@ -1,30 +0,0 @@
-load("testsrc/assert.js");
-
-assertThrows(function() {
-  'use strict';
-  return arguments.caller;
-}, TypeError);
-
-assertThrows(function() {
-  'use strict';
-  return arguments.callee;
-}, TypeError);
-
-assertEquals(undefined, function() {
-  return arguments.caller;
-}());
-
-function f1() {
-  return arguments.callee;
-}
-
-assertEquals(f1, f1());
-
-// A simple function is not required activation.
-// But when it changes to strict mode, requires activation.
-assertThrows(function() {
-  'use strict';
-  delete Math.LN2;
-}, TypeError);
-
-"success";
diff --git a/testsrc/jstests/top-level-strict-mode.js b/testsrc/jstests/top-level-strict-mode.js
deleted file mode 100644
index 0f8402d..0000000
--- a/testsrc/jstests/top-level-strict-mode.js
+++ /dev/null
@@ -1,13 +0,0 @@
-'use strict';
-
-load("testsrc/assert.js");
-
-assertThrows(function() {
-  return arguments.caller;
-}, TypeError);
-
-assertThrows(function() {
-  return arguments.callee;
-}, TypeError);
-
-"success";
diff --git a/testsrc/org/mozilla/javascript/benchmarks/CaliperObjectBenchmark.java b/testsrc/org/mozilla/javascript/benchmarks/CaliperObjectBenchmark.java
deleted file mode 100644
index eb26928..0000000
--- a/testsrc/org/mozilla/javascript/benchmarks/CaliperObjectBenchmark.java
+++ /dev/null
@@ -1,131 +0,0 @@
-package org.mozilla.javascript.benchmarks;
-
-import com.google.caliper.AfterExperiment;
-import com.google.caliper.BeforeExperiment;
-import com.google.caliper.Benchmark;
-import com.google.caliper.Param;
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.Function;
-import org.mozilla.javascript.Scriptable;
-import org.mozilla.javascript.ScriptableObject;
-import org.mozilla.javascript.tools.shell.Global;
-
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.Random;
-
-@SuppressWarnings("unused")
-public class CaliperObjectBenchmark
-{
-    static final Random rand = new Random();
-
-    static void runCode(Context cx, Scriptable scope, String fileName)
-        throws IOException
-    {
-        FileReader rdr = new FileReader(fileName);
-        try {
-            cx.evaluateReader(scope, rdr, "test.js", 1, null);
-        } finally {
-            rdr.close();
-        }
-    }
-
-    @SuppressWarnings("unused")
-    public static class FieldAccess
-    {
-        @Param("10") int stringKeys;
-        @Param("10") int intKeys;
-        @Param("9") int optLevel;
-
-        private Context cx;
-        private Scriptable scope;
-
-        private Scriptable strings;
-        private Scriptable ints;
-
-        @BeforeExperiment
-        @SuppressWarnings("unused")
-        void create()
-            throws IOException
-        {
-            cx = Context.enter();
-            cx.setOptimizationLevel(optLevel);
-            cx.setLanguageVersion(Context.VERSION_ES6);
-
-            scope = new Global(cx);
-            runCode(cx, scope, "testsrc/benchmarks/caliper/fieldTests.js");
-
-            Object[] sarray = new Object[stringKeys];
-            for (int i = 0; i < stringKeys; i++) {
-                int len = rand.nextInt(49) + 1;
-                char[] c = new char[len];
-                for (int cc = 0; cc < len; cc++) {
-                    c[cc] = (char) ('a' + rand.nextInt(25));
-                }
-                sarray[i] = new String(c);
-            }
-            strings = cx.newArray(scope, sarray);
-
-            Object[] iarray = new Object[intKeys];
-            for (int i = 0; i < intKeys; i++) {
-                iarray[i] = rand.nextInt(10000);
-            }
-            ints = cx.newArray(scope, iarray);
-        }
-
-        @AfterExperiment
-        @SuppressWarnings("unused")
-        void close()
-        {
-            Context.exit();
-        }
-
-        @Benchmark
-        @SuppressWarnings("unused")
-        void createFields(int count)
-        {
-            Function create = (Function)ScriptableObject.getProperty(scope, "createObject");
-            create.call(cx, scope, null, new Object[]{count, strings, ints});
-        }
-
-        @Benchmark
-        @SuppressWarnings("unused")
-        void accessFields(int count)
-        {
-            Function create = (Function)ScriptableObject.getProperty(scope, "createObject");
-            Object o = create.call(cx, scope, null, new Object[]{1, strings, ints});
-            Function access = (Function)ScriptableObject.getProperty(scope, "accessObject");
-            access.call(cx, scope, null, new Object[] {count, o, strings, ints});
-        }
-
-        @Benchmark
-        @SuppressWarnings("unused")
-        void iterateFields(long count)
-        {
-            Function create = (Function)ScriptableObject.getProperty(scope, "createObject");
-            Object o = create.call(cx, scope, null, new Object[]{1, strings, ints});
-            Function iterate = (Function)ScriptableObject.getProperty(scope, "iterateObject");
-            iterate.call(cx, scope, null, new Object[] {count, o});
-        }
-
-        @Benchmark
-        @SuppressWarnings("unused")
-        void ownKeysFields(long count)
-        {
-            Function create = (Function)ScriptableObject.getProperty(scope, "createObject");
-            Object o = create.call(cx, scope, null, new Object[]{1, strings, ints});
-            Function iterate = (Function)ScriptableObject.getProperty(scope, "iterateOwnKeysObject");
-            iterate.call(cx, scope, null, new Object[] {count, o});
-        }
-
-        @Benchmark
-        @SuppressWarnings("unused")
-        void deleteFields(int count)
-        {
-            Function create = (Function)ScriptableObject.getProperty(scope, "createObject");
-            Object o = create.call(cx, scope, null, new Object[]{1, strings, ints});
-            Function delete = (Function)ScriptableObject.getProperty(scope, "deleteObject");
-            delete.call(cx, scope, null, new Object[] {count, o, strings, ints});
-        }
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/benchmarks/CaliperSpiderBenchmark.java b/testsrc/org/mozilla/javascript/benchmarks/CaliperSpiderBenchmark.java
deleted file mode 100644
index 6021b16..0000000
--- a/testsrc/org/mozilla/javascript/benchmarks/CaliperSpiderBenchmark.java
+++ /dev/null
@@ -1,269 +0,0 @@
-package org.mozilla.javascript.benchmarks;
-
-import com.google.caliper.AfterExperiment;
-import com.google.caliper.BeforeExperiment;
-import com.google.caliper.Benchmark;
-import com.google.caliper.Param;
-import com.google.caliper.api.Macrobenchmark;
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.Script;
-import org.mozilla.javascript.Scriptable;
-import org.mozilla.javascript.tools.shell.Global;
-
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.HashMap;
-
-@SuppressWarnings("unused")
-public class CaliperSpiderBenchmark
-{
-    public static final File FILE_BASE = new File("testsrc/benchmarks/sunspider-0.9.1");
-
-    static Script compileBenchmark(Context cx, String fileName)
-        throws IOException
-    {
-        File f = new File(FILE_BASE, fileName);
-        FileReader rdr = new FileReader(f);
-        try {
-            return cx.compileReader(rdr, fileName, 1, null);
-        } finally {
-            rdr.close();
-        }
-    }
-
-    @SuppressWarnings("unused")
-    public static class Spider
-    {
-        @Param("9") int optLevel;
-
-        private Context cx;
-        private Scriptable scope;
-
-        private final HashMap<String, Script> scripts = new HashMap<String, Script>();
-
-        private static final String[] BENCHMARKS = {
-            "3d-cube.js", "3d-morph.js", "3d-raytrace.js",
-            "access-binary-trees.js", "access-fannkuch.js", "access-nbody.js", "access-nsieve.js",
-            "bitops-3bit-bits-in-byte.js", "bitops-bits-in-byte.js", "bitops-bitwise-and.js", "bitops-nsieve-bits.js",
-            "controlflow-recursive.js", "crypto-aes.js", "crypto-md5.js", "crypto-sha1.js",
-            "date-format-tofte.js", "date-format-xparb.js",
-            "math-cordic.js", "math-partial-sums.js", "math-spectral-norm.js",
-            "regexp-dna.js",
-            "string-base64.js", "string-fasta.js", "string-tagcloud.js",
-            "string-unpack-code.js", "string-validate-input.js"
-        };
-
-        @BeforeExperiment
-        @SuppressWarnings("unused")
-        void create()
-            throws IOException
-        {
-            cx = Context.enter();
-            cx.setOptimizationLevel(optLevel);
-            cx.setLanguageVersion(Context.VERSION_ES6);
-            scope = new Global(cx);
-
-            for (String bn : BENCHMARKS) {
-                compileScript(cx, bn);
-            }
-        }
-
-        private void compileScript(Context cx, String fileName)
-            throws IOException
-        {
-            Script s = compileBenchmark(cx, fileName);
-            scripts.put(fileName, s);
-        }
-
-        @AfterExperiment
-        @SuppressWarnings("unused")
-        void close()
-        {
-            Context.exit();
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void threeDCube(int iterations)
-        {
-            runBenchmark("3d-cube.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void threeDMorph(int iterations)
-        {
-            runBenchmark("3d-morph.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void accessBinaryTrees(int iterations)
-        {
-            runBenchmark("access-binary-trees.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void accessFannkuch(int iterations)
-        {
-            runBenchmark("access-fannkuch.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void accessNBody(int iterations)
-        {
-            runBenchmark("access-nbody.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void accessNSieve(int iterations)
-        {
-            runBenchmark("access-nsieve.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void bitops3BitBitsInByte(int iterations)
-        {
-            runBenchmark("bitops-3bit-bits-in-byte.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void bitopsBitsInByte(int iterations)
-        {
-            runBenchmark("bitops-bits-in-byte.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void BitopsBitwiseAnd(int iterations)
-        {
-            runBenchmark("bitops-bitwise-and.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void bisopsNsieveBits(int iterations)
-        {
-            runBenchmark("bitops-nsieve-bits.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void controlFlowRecursive(int iterations)
-        {
-            runBenchmark("controlflow-recursive.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void cryptoAES(int iterations)
-        {
-            runBenchmark("crypto-aes.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void cryptoMD5(int iterations)
-        {
-            runBenchmark("crypto-md5.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void cryptoSHA1(int iterations)
-        {
-            runBenchmark("crypto-sha1.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void dateFormatToFTE(int iterations)
-        {
-            runBenchmark("date-format-tofte.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void dateFormatXparb(int iterations)
-        {
-            runBenchmark("date-format-xparb.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void mathCordic(int iterations)
-        {
-            runBenchmark("math-cordic.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void mathPartialSums(int iterations)
-        {
-            runBenchmark("math-partial-sums.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void mathSpectralNorm(int iterations)
-        {
-            runBenchmark("math-spectral-norm.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void regexpDNA(int iterations)
-        {
-            runBenchmark("regexp-dna.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void stringBase64(int iterations)
-        {
-            runBenchmark("string-base64.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void stringFasta(int iterations)
-        {
-            runBenchmark("string-fasta.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void stringTagCloud(int iterations)
-        {
-            runBenchmark("string-tagcloud.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void stringUnpackCode(int iterations)
-        {
-            runBenchmark("string-unpack-code.js", iterations);
-        }
-
-        @Macrobenchmark
-        @SuppressWarnings("unused")
-        public void stringValidateInput(int iterations)
-        {
-            runBenchmark("string-validate-input.js", iterations);
-        }
-
-        private void runBenchmark(String name, int iterations)
-        {
-            Script s = scripts.get(name);
-            for (int i = 0; i < iterations; i++) {
-                s.exec(cx, scope);
-            }
-        }
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/benchmarks/ResultPlotter.java b/testsrc/org/mozilla/javascript/benchmarks/ResultPlotter.java
deleted file mode 100644
index 6e05363..0000000
--- a/testsrc/org/mozilla/javascript/benchmarks/ResultPlotter.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package org.mozilla.javascript.benchmarks;
-
-import com.google.caliper.api.ResultProcessor;
-import com.google.caliper.model.Measurement;
-import com.google.caliper.model.Trial;
-import com.google.caliper.model.Value;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.HashMap;
-import java.util.Map;
-
-public class ResultPlotter
-    implements ResultProcessor
-
-{
-    private PrintWriter out;
-    private final HashMap<String, Double> results = new HashMap<String, Double>();
-
-    public ResultPlotter()
-        throws IOException
-    {
-        out = new PrintWriter(
-            new FileWriter(new File(System.getProperty("rhino.benchmark.report"), "caliper-spider.csv"))
-        );
-    }
-
-    @Override
-    public void close()
-    {
-        boolean once = false;
-        for (String n : results.keySet()) {
-            if (once) {
-                out.print(',');
-            } else {
-                once = true;
-            }
-            out.print(n);
-        }
-        out.println();
-
-        once = false;
-        for (Double v : results.values()) {
-            if (once) {
-                out.print(',');
-            } else {
-                once = true;
-            }
-            out.printf("%.2f", v);
-        }
-        out.println();
-
-        out.close();
-    }
-
-    @Override
-    public void processTrial(Trial trial)
-    {
-        if (trial.instrumentSpec().className().contains("RuntimeInstrument")) {
-            double runningAvg = 0.0;
-            for (Measurement m : trial.measurements()) {
-                runningAvg += (m.value().magnitude() / m.weight());
-            }
-            double avg = runningAvg / (double) trial.measurements().size();
-            results.put(trial.scenario().benchmarkSpec().methodName(), avg);
-        }
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/drivers/JsTestsBase.java b/testsrc/org/mozilla/javascript/drivers/JsTestsBase.java
index 2f6faac..f628e25 100644
--- a/testsrc/org/mozilla/javascript/drivers/JsTestsBase.java
+++ b/testsrc/org/mozilla/javascript/drivers/JsTestsBase.java
@@ -28,7 +28,7 @@ public abstract class JsTestsBase extends TestCase {
         System.out.print(name + ": ");
         Object result;
         try {
-            result = cx.evaluateString(scope, source, "jstest input: " + name, 1, null);
+            result = cx.evaluateString(scope, source, "jstest input", 1, null);
         } catch (RuntimeException e) {
             e.printStackTrace(System.err);
             System.out.println("FAILED");
diff --git a/testsrc/org/mozilla/javascript/drivers/ScriptTestsBase.java b/testsrc/org/mozilla/javascript/drivers/ScriptTestsBase.java
index d20edc4..7be6dec 100644
--- a/testsrc/org/mozilla/javascript/drivers/ScriptTestsBase.java
+++ b/testsrc/org/mozilla/javascript/drivers/ScriptTestsBase.java
@@ -12,7 +12,10 @@ import org.mozilla.javascript.JavaScriptException;
 import org.mozilla.javascript.Scriptable;
 import org.mozilla.javascript.tools.shell.Global;
 
-import java.io.*;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
 
 import static org.junit.Assert.*;
 
@@ -42,7 +45,7 @@ public abstract class ScriptTestsBase {
         Context cx = Context.enter();
         try {
             if (!"".equals(anno.value())) {
-                script = new InputStreamReader(new FileInputStream(anno.value()), "UTF-8");
+                script = new FileReader(anno.value());
                 suiteName = anno.value();
             } else if (!"".equals(anno.inline())) {
                 script = new StringReader("load('testsrc/assert.js');\n" + anno.inline() + "\n" + "'success';");
diff --git a/testsrc/org/mozilla/javascript/drivers/TestUtils.java b/testsrc/org/mozilla/javascript/drivers/TestUtils.java
index d251d83..e872d8f 100644
--- a/testsrc/org/mozilla/javascript/drivers/TestUtils.java
+++ b/testsrc/org/mozilla/javascript/drivers/TestUtils.java
@@ -80,12 +80,4 @@ public class TestUtils {
         }
         return false;
     }
-
-    public static final FileFilter JS_FILE_FILTER = new FileFilter() {
-        @Override
-        public boolean accept(File pathname) {
-            return pathname.getAbsolutePath().endsWith(".js");
-        }
-    };
-
 }
diff --git a/testsrc/org/mozilla/javascript/tests/Bug421071Test.java b/testsrc/org/mozilla/javascript/tests/Bug421071Test.java
index 1a9bc11..d74d667 100644
--- a/testsrc/org/mozilla/javascript/tests/Bug421071Test.java
+++ b/testsrc/org/mozilla/javascript/tests/Bug421071Test.java
@@ -2,120 +2,120 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-/*
- * @(#)Bug421071Test.java
- *
- */
-
-package org.mozilla.javascript.tests;
-
-import junit.framework.TestCase;
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.ContextFactory;
-import org.mozilla.javascript.ImporterTopLevel;
-import org.mozilla.javascript.Script;
-import org.mozilla.javascript.Scriptable;
-
-public class Bug421071Test extends TestCase {
-    private ContextFactory factory;
-    private TopLevelScope globalScope;
-    private Script testScript;
-
-    public void testProblemReplicator() throws Exception {
-        // before debugging please put the breakpoint in the
-        // NativeJavaPackage.getPkgProperty()
-        // and observe names passed in there
-        testScript = compileScript();
-        runTestScript(); // this one does not get to the
-                            // NativeJavaPackage.getPkgProperty() on my
-                            // variables
-        runTestScript(); // however this one does
-    }
-
-    private Script compileScript() {
-        String scriptSource = "importPackage(java.util);\n"
-                + "var searchmon = 3;\n"
-                + "var searchday = 10;\n"
-                + "var searchyear = 2008;\n"
-                + "var searchwkday = 0;\n"
-                + "\n"
-                + "var myDate = Calendar.getInstance();\n // this is a java.util.Calendar"
-                + "myDate.set(Calendar.MONTH, searchmon);\n"
-                + "myDate.set(Calendar.DATE, searchday);\n"
-                + "myDate.set(Calendar.YEAR, searchyear);\n"
-                + "searchwkday.value = myDate.get(Calendar.DAY_OF_WEEK);";
-        Script script;
-        Context context = factory.enterContext();
-        try {
-            script = context.compileString(scriptSource, "testScript", 1, null);
-            return script;
-        } finally {
-            Context.exit();
-        }
-    }
-
-    private void runTestScript() throws InterruptedException {
-        // will start new thread to get as close as possible to original
-        // environment, however the same behavior is exposed using new
-        // ScriptRunner(script).run();
-        Thread thread = new Thread(new ScriptRunner(testScript));
-        thread.start();
-        thread.join();
-    }
-
-    static class DynamicScopeContextFactory extends ContextFactory {
-        @Override
-        public boolean hasFeature(Context cx, int featureIndex) {
-            if (featureIndex == Context.FEATURE_DYNAMIC_SCOPE)
-                return true;
-            return super.hasFeature(cx, featureIndex);
-        }
-    }
-
-    private TopLevelScope createGlobalScope() {
-        factory = new DynamicScopeContextFactory();
-        Context context = factory.enterContext();
-        // noinspection deprecation
-        TopLevelScope globalScope = new TopLevelScope(context);
-        Context.exit();
-        return globalScope;
-    }
-
-    @Override
-    protected void setUp() throws Exception {
-        super.setUp();
-        globalScope = createGlobalScope();
-    }
-
-    private class TopLevelScope extends ImporterTopLevel {
-        private static final long serialVersionUID = 7831526694313927899L;
-
-        public TopLevelScope(Context context) {
-            super(context);
-        }
-    }
-
-    private class ScriptRunner implements Runnable {
-        private Script script;
-
-        public ScriptRunner(Script script) {
-            this.script = script;
-        }
-
-        public void run() {
-            Context context = factory.enterContext();
-            try {
-                // Run each script in its own scope, to keep global variables
-                // defined in each script separate
-                Scriptable threadScope = context.newObject(globalScope);
-                threadScope.setPrototype(globalScope);
-                threadScope.setParentScope(null);
-                script.exec(context, threadScope);
-            } catch (Exception ee) {
-                ee.printStackTrace();
-            } finally {
-                Context.exit();
-            }
-        }
-    }
-}
+/*
+ * @(#)Bug421071Test.java
+ *
+ */
+
+package org.mozilla.javascript.tests;
+
+import junit.framework.TestCase;
+import org.mozilla.javascript.Context;
+import org.mozilla.javascript.ContextFactory;
+import org.mozilla.javascript.ImporterTopLevel;
+import org.mozilla.javascript.Script;
+import org.mozilla.javascript.Scriptable;
+
+public class Bug421071Test extends TestCase {
+    private ContextFactory factory;
+    private TopLevelScope globalScope;
+    private Script testScript;
+
+    public void testProblemReplicator() throws Exception {
+        // before debugging please put the breakpoint in the
+        // NativeJavaPackage.getPkgProperty()
+        // and observe names passed in there
+        testScript = compileScript();
+        runTestScript(); // this one does not get to the
+                            // NativeJavaPackage.getPkgProperty() on my
+                            // variables
+        runTestScript(); // however this one does
+    }
+
+    private Script compileScript() {
+        String scriptSource = "importPackage(java.util);\n"
+                + "var searchmon = 3;\n"
+                + "var searchday = 10;\n"
+                + "var searchyear = 2008;\n"
+                + "var searchwkday = 0;\n"
+                + "\n"
+                + "var myDate = Calendar.getInstance();\n // this is a java.util.Calendar"
+                + "myDate.set(Calendar.MONTH, searchmon);\n"
+                + "myDate.set(Calendar.DATE, searchday);\n"
+                + "myDate.set(Calendar.YEAR, searchyear);\n"
+                + "searchwkday.value = myDate.get(Calendar.DAY_OF_WEEK);";
+        Script script;
+        Context context = factory.enterContext();
+        try {
+            script = context.compileString(scriptSource, "testScript", 1, null);
+            return script;
+        } finally {
+            Context.exit();
+        }
+    }
+
+    private void runTestScript() throws InterruptedException {
+        // will start new thread to get as close as possible to original
+        // environment, however the same behavior is exposed using new
+        // ScriptRunner(script).run();
+        Thread thread = new Thread(new ScriptRunner(testScript));
+        thread.start();
+        thread.join();
+    }
+
+    static class DynamicScopeContextFactory extends ContextFactory {
+        @Override
+        public boolean hasFeature(Context cx, int featureIndex) {
+            if (featureIndex == Context.FEATURE_DYNAMIC_SCOPE)
+                return true;
+            return super.hasFeature(cx, featureIndex);
+        }
+    }
+
+    private TopLevelScope createGlobalScope() {
+        factory = new DynamicScopeContextFactory();
+        Context context = factory.enterContext();
+        // noinspection deprecation
+        TopLevelScope globalScope = new TopLevelScope(context);
+        Context.exit();
+        return globalScope;
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        globalScope = createGlobalScope();
+    }
+
+    private class TopLevelScope extends ImporterTopLevel {
+        private static final long serialVersionUID = 7831526694313927899L;
+
+        public TopLevelScope(Context context) {
+            super(context);
+        }
+    }
+
+    private class ScriptRunner implements Runnable {
+        private Script script;
+
+        public ScriptRunner(Script script) {
+            this.script = script;
+        }
+
+        public void run() {
+            Context context = factory.enterContext();
+            try {
+                // Run each script in its own scope, to keep global variables
+                // defined in each script separate
+                Scriptable threadScope = context.newObject(globalScope);
+                threadScope.setPrototype(globalScope);
+                threadScope.setParentScope(null);
+                script.exec(context, threadScope);
+            } catch (Exception ee) {
+                ee.printStackTrace();
+            } finally {
+                Context.exit();
+            }
+        }
+    }
+}
diff --git a/testsrc/org/mozilla/javascript/tests/ConsStringTest.java b/testsrc/org/mozilla/javascript/tests/ConsStringTest.java
deleted file mode 100644
index 215b0c2..0000000
--- a/testsrc/org/mozilla/javascript/tests/ConsStringTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.mozilla.javascript.tests;
-
-import junit.framework.TestCase;
-import org.mozilla.javascript.ConsString;
-
-public class ConsStringTest extends TestCase {
-    public void testAppend() {
-        ConsString current = new ConsString("a", "b");
-        current = new ConsString(current, "c");
-        current = new ConsString(current, "d");
-
-        assertEquals("abcd", current.toString());
-    }
-
-    public void testAppendManyStrings() {
-        ConsString current = new ConsString("a", "a");
-        for(int i = 0; i < 1000000; i++) {
-            current = new ConsString(current, "a");
-        }
-        assertNotNull(current.toString());
-    }
-
-    public void testAppendManyStringsRecursive() {
-        recurseAndAppend(4000);
-    }
-
-    private void recurseAndAppend(int depth) {
-        if (depth == 0) {
-            ConsString current = new ConsString("a", "a");
-            for(int i = 0; i < 1000000; i++) {
-                current = new ConsString(current, "a");
-            }
-            assertNotNull(current.toString());
-        } else {
-            recurseAndAppend(depth-1);
-        }
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/tests/ContextFactoryTest.java b/testsrc/org/mozilla/javascript/tests/ContextFactoryTest.java
index f8ea0c9..a981d70 100644
--- a/testsrc/org/mozilla/javascript/tests/ContextFactoryTest.java
+++ b/testsrc/org/mozilla/javascript/tests/ContextFactoryTest.java
@@ -9,51 +9,45 @@ package org.mozilla.javascript.tests;
 
 import junit.framework.TestCase;
 
-import org.junit.*;
-import org.junit.runner.RunWith;
-import org.junit.runners.BlockJUnit4ClassRunner;
 import org.mozilla.javascript.Context;
 import org.mozilla.javascript.ContextFactory;
 import org.mozilla.javascript.Scriptable;
 import org.mozilla.javascript.RhinoException;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-@RunWith(BlockJUnit4ClassRunner.class)
-public class ContextFactoryTest {
-
-    private static Context CTX;
-    private static int LV;
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-        CTX = Context.enter();
-        LV = CTX.getLanguageVersion();
+/**
+ * @author Norris Boyd
+ */
+public class ContextFactoryTest extends TestCase {
+    static class MyFactory extends ContextFactory {
+        @Override
+        public boolean hasFeature(Context cx, int featureIndex)
+        {
+            switch (featureIndex) {
+                case Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME:
+                    return true;
+            }
+            return super.hasFeature(cx, featureIndex);
+        }
     }
 
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-        CTX.setLanguageVersion(LV);
-        CTX.exit();
+    public void testCustomContextFactory() {
+        ContextFactory factory = new MyFactory();
+        Context cx = factory.enterContext();
+        try {
+            Scriptable globalScope = cx.initStandardObjects();
+            // Test that FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME is enabled
+            /* TODO(stevey): fix this functionality in parser
+            Object result = cx.evaluateString(globalScope,
+                    "var obj = {};" +
+                    "function obj.foo() { return 'bar'; }" +
+                    "obj.foo();",
+                    "test source", 1, null);
+            assertEquals("bar", result);
+            */
+        } catch (RhinoException e) {
+            fail(e.toString());
+        } finally {
+            Context.exit();
+        }
     }
-
-    @Test
-    public void whenVersionLessEq17ThenOldUndefNullThis() throws Exception {
-        CTX.setLanguageVersion(Context.VERSION_1_7);
-        assertTrue(CTX.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS));
-
-        CTX.setLanguageVersion(Context.VERSION_1_6);
-        assertTrue(CTX.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS));
-    }
-
-    @Test
-    public void whenVersionGt17ThenNewUndefNullThis() throws Exception {
-        CTX.setLanguageVersion(Context.VERSION_1_8);
-        assertFalse(CTX.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS));
-
-        CTX.setLanguageVersion(Context.VERSION_ES6);
-        assertFalse(CTX.hasFeature(Context.FEATURE_OLD_UNDEF_NULL_THIS));
-    }
-
-}
+ }
diff --git a/testsrc/org/mozilla/javascript/tests/DoctestsTest.java b/testsrc/org/mozilla/javascript/tests/DoctestsTest.java
index 7de06aa..56c9427 100644
--- a/testsrc/org/mozilla/javascript/tests/DoctestsTest.java
+++ b/testsrc/org/mozilla/javascript/tests/DoctestsTest.java
@@ -60,7 +60,7 @@ public class DoctestsTest {
         return new String(buf);
     }
 
-    @Parameters(name = "{0}")
+    @Parameters
     public static Collection<Object[]> doctestValues() throws IOException {
         File[] doctests = getDoctestFiles();
         List<Object[]> result = new ArrayList<Object[]>();
diff --git a/testsrc/org/mozilla/javascript/tests/IncDecTest.java b/testsrc/org/mozilla/javascript/tests/IncDecTest.java
deleted file mode 100644
index b0a706f..0000000
--- a/testsrc/org/mozilla/javascript/tests/IncDecTest.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.mozilla.javascript.tests;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest(
-    value = "testsrc/jstests/inc-dec.js"
-)
-public class IncDecTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/InsideStrictModeTest.java b/testsrc/org/mozilla/javascript/tests/InsideStrictModeTest.java
deleted file mode 100644
index 0341c4d..0000000
--- a/testsrc/org/mozilla/javascript/tests/InsideStrictModeTest.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.mozilla.javascript.tests;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest(
-    value = "testsrc/jstests/inside-strict-mode.js"
-)
-public class InsideStrictModeTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/OverloadTest.java b/testsrc/org/mozilla/javascript/tests/OverloadTest.java
deleted file mode 100644
index de60f72..0000000
--- a/testsrc/org/mozilla/javascript/tests/OverloadTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/**
- *
- */
-package org.mozilla.javascript.tests;
-
-import org.junit.Test;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.util.Collection;
-import java.util.Map;
-
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.ContextAction;
-import org.mozilla.javascript.EvaluatorException;
-import org.mozilla.javascript.Scriptable;
-
-public class OverloadTest {
-
-    public static String x(Collection<String> x) {
-        return "collection";
-    }
-    public static String x(Map<String, String> x) {
-        return "map";
-    }
-    public static String x(Runnable r) {
-        return "runnable";
-    }
-
-
-    @Test
-    public void testJSObjectToMap() {
-        assertEvaluates("map", "String(org.mozilla.javascript.tests.OverloadTest.x({}));");
-        assertEvaluates("map", "String(org.mozilla.javascript.tests.OverloadTest.x({ run: function() {} }));");
-    }
-
-    @Test
-    public void testJSArrayToCollection() {
-        assertEvaluates("collection", "String(org.mozilla.javascript.tests.OverloadTest.x([]));");
-    }
-
-    @Test
-    public void testJSFunctionToInterface() {
-        assertThrows(EvaluatorException.class, "String(org.mozilla.javascript.tests.OverloadTest.x(function() {}));");
-    }
-
-    private void assertEvaluates(final Object expected, final String source) {
-        final ContextAction action = new ContextAction() {
-            public Object run(Context cx) {
-                final Scriptable scope = cx.initStandardObjects();
-                final Object rep = cx.evaluateString(scope, source, "test.js",
-                        0, null);
-                assertEquals(expected, rep);
-                return null;
-            }
-        };
-        Utils.runWithAllOptimizationLevels(action);
-    }
-
-    private void assertThrows(final Class<? extends Exception> exceptionClass, final String source) {
-        final ContextAction action = new ContextAction() {
-            public Object run(Context cx) {
-                final Scriptable scope = cx.initStandardObjects();
-                try {
-                    cx.evaluateString(scope, source, "test.js", 0, null);
-                    fail("Did not throw exception");
-                } catch (Exception e) {
-                    assertTrue(exceptionClass.isInstance(e));
-                }
-                return null;
-            }
-        };
-        Utils.runWithAllOptimizationLevels(action);
-    }
- }
diff --git a/testsrc/org/mozilla/javascript/tests/ParserTest.java b/testsrc/org/mozilla/javascript/tests/ParserTest.java
index 507e41f..b521eb1 100644
--- a/testsrc/org/mozilla/javascript/tests/ParserTest.java
+++ b/testsrc/org/mozilla/javascript/tests/ParserTest.java
@@ -1183,11 +1183,6 @@ public class ParserTest extends TestCase {
       parse("({import:1}).import;");
     }
 
-    public void testReportError() {
-      expectParseErrors("'use strict';(function(eval) {})();",
-                        new String[] { "\"eval\" is not a valid identifier for this use in strict mode." });
-    }
-
     private void expectParseErrors(String string, String [] errors) {
       parse(string, errors, null, false);
     }
diff --git a/testsrc/org/mozilla/javascript/tests/Test262SuiteTest.java b/testsrc/org/mozilla/javascript/tests/Test262SuiteTest.java
deleted file mode 100644
index 44b5fc5..0000000
--- a/testsrc/org/mozilla/javascript/tests/Test262SuiteTest.java
+++ /dev/null
@@ -1,260 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript.tests;
-
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.EvaluatorException;
-import org.mozilla.javascript.RhinoException;
-import org.mozilla.javascript.Script;
-import org.mozilla.javascript.Scriptable;
-import org.mozilla.javascript.drivers.TestUtils;
-import org.mozilla.javascript.tools.SourceReader;
-import org.mozilla.javascript.tools.shell.ShellContextFactory;
-import org.yaml.snakeyaml.Yaml;
-
-import java.io.*;
-import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mozilla.javascript.drivers.TestUtils.JS_FILE_FILTER;
-import static org.mozilla.javascript.drivers.TestUtils.recursiveListFilesHelper;
-
-@RunWith(Parameterized.class)
-public class Test262SuiteTest {
-
-    static final int[] OPT_LEVELS = {-1, 0, 9};
-
-    static Map<Integer, Map<String, Script>> HARNESS_SCRIPT_CACHE = new HashMap<Integer, Map<String, Script>>();
-
-    static ShellContextFactory CTX_FACTORY = new ShellContextFactory();
-
-    @BeforeClass
-    public static void setUpClass() throws Exception {
-        HARNESS_SCRIPT_CACHE.put(-1, new HashMap<String, Script>());
-        HARNESS_SCRIPT_CACHE.put(0, new HashMap<String, Script>());
-        HARNESS_SCRIPT_CACHE.put(9, new HashMap<String, Script>());
-
-        CTX_FACTORY.setLanguageVersion(Context.VERSION_ES6);
-        TestUtils.setGlobalContextFactory(CTX_FACTORY);
-    }
-
-    @AfterClass
-    public static void tearDownClass() throws Exception {
-        TestUtils.setGlobalContextFactory(null);
-    }
-
-    private static final Pattern EXCLUDE_PATTERN = Pattern.compile("\\s{1,4}!\\s*(.+)");
-
-    private final String jsFilePath;
-    private final String jsFileStr;
-    private final int optLevel;
-    private final boolean useStrict;
-    private List<String> harnessFiles;
-    private EcmaErrorType errorType;
-
-    public Test262SuiteTest(String jsFilePath, String jsFileStr, List<String> harnessFiles, int optLevel, boolean useStrict, EcmaErrorType errorType) {
-        this.jsFilePath = jsFilePath;
-        this.jsFileStr = jsFileStr;
-        this.optLevel = optLevel;
-        this.useStrict = useStrict;
-        this.harnessFiles = harnessFiles;
-        this.errorType = errorType;
-    }
-
-    private Object executeRhinoScript() {
-        Context cx = Context.enter();
-
-        try {
-            cx.setOptimizationLevel(optLevel);
-
-            Scriptable scope = cx.initStandardObjects();
-            for (String harnessFile : harnessFiles) {
-                if (!HARNESS_SCRIPT_CACHE.get(optLevel).containsKey(harnessFile)) {
-                    HARNESS_SCRIPT_CACHE.get(optLevel).put(
-                        harnessFile,
-                        cx.compileReader(new FileReader("test262/harness/" + harnessFile), "test262/harness/" + harnessFile, 1, null)
-                    );
-                }
-                HARNESS_SCRIPT_CACHE.get(optLevel).get(harnessFile).exec(cx, scope);
-            }
-
-            String str = jsFileStr;
-            if (useStrict) { // taken from test262.py
-                str = "\"use strict\";\nvar strict_mode = true;\n" + jsFileStr;
-            }
-
-            Object result = cx.evaluateString(scope, str, jsFilePath.replaceAll("\\\\", "/"), 1, null);
-
-            if (errorType != EcmaErrorType.NONE) {
-                fail(String.format("failed negative test. expected error: %s", errorType));
-                return null;
-            }
-
-            return result;
-        } catch (RhinoException ex) {
-            if (errorType == EcmaErrorType.NONE) {
-                fail(String.format("%s%n%s", ex.getMessage(), ex.getScriptStackTrace()));
-            } else {
-                if (errorType == EcmaErrorType.ANY) {
-                    // passed
-                } else {
-                    String exceptionName;
-                    if (ex instanceof EvaluatorException) {
-                        exceptionName = "SyntaxError";
-                    } else {
-                        exceptionName = ex.details();
-                        if (exceptionName.contains(":")) {
-                            exceptionName = exceptionName.substring(0, exceptionName.indexOf(":"));
-                        }
-                    }
-                    assertEquals(ex.details(), errorType.name(), exceptionName);
-                }
-            }
-            return null;
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        } finally {
-            Context.exit();
-        }
-    }
-
-    private static final Yaml YAML = new Yaml();
-
-    public static List<File> getTestFiles() throws IOException {
-        File testDir = new File("test262/test");
-
-        List<File> testFiles = new LinkedList<File>();
-
-        List<File> dirFiles = new LinkedList<File>();
-
-        Scanner scanner = new Scanner(new File("testsrc/test262.properties"));
-
-        String curLine = "", nxtLine = "";
-
-        while (true) {
-            curLine = nxtLine;
-            nxtLine = scanner.hasNextLine() ? scanner.nextLine() : null;
-
-            if (curLine == null) break;
-
-            if (curLine.isEmpty() || curLine.startsWith("#")) continue;
-
-            File file = new File(testDir, curLine);
-
-            if (file.isFile()) {
-                testFiles.add(file);
-            } else if (file.isDirectory()) {
-                recursiveListFilesHelper(file, JS_FILE_FILTER, dirFiles);
-
-                while (true) {
-                    curLine = nxtLine;
-                    nxtLine = scanner.hasNextLine() ? scanner.nextLine() : null;
-
-                    if (curLine == null) {
-                        testFiles.addAll(dirFiles);
-                        break;
-                    }
-
-                    if (curLine.isEmpty() || curLine.startsWith("#")) continue;
-
-                    Matcher m = EXCLUDE_PATTERN.matcher(curLine);
-                    if (m.matches()) {
-                        Iterator<File> it = dirFiles.iterator();
-                        while (it.hasNext()) {
-                            String path = it.next().getPath().replaceAll("\\\\", "/");
-                            if (path.contains(m.group(1))) it.remove();
-                        }
-                    } else {
-                        testFiles.addAll(dirFiles);
-                        dirFiles.clear();
-                        file = new File(testDir, curLine);
-                        if (file.isFile()) {
-                            testFiles.add(file);
-                            break;
-                        } else if (file.isDirectory()) {
-                            recursiveListFilesHelper(file, JS_FILE_FILTER, dirFiles);
-                        }
-                    }
-                }
-            }
-        }
-        scanner.close();
-
-        return testFiles;
-    }
-
-    @Parameters(name = "js={0}, opt={3}, strict={4}")
-    public static Collection<Object[]> test262SuiteValues() throws IOException {
-        List<Object[]> result = new ArrayList<Object[]>();
-        List<File> tests = getTestFiles();
-        for (File jsTest : tests) {
-            String jsFileStr = (String) SourceReader.readFileOrUrl(jsTest.getPath(), true, "UTF-8");
-            List<String> harnessFiles = new ArrayList<String>();
-            harnessFiles.add("sta.js");
-            harnessFiles.add("assert.js");
-
-            Map header = (Map) YAML.load(jsFileStr.substring(jsFileStr.indexOf("/*---") + 5, jsFileStr.lastIndexOf("---*/")));
-            if (header.containsKey("includes")) {
-                harnessFiles.addAll((Collection)header.get("includes"));
-            }
-
-            EcmaErrorType errorType = EcmaErrorType._valueOf((String)header.get("negative"));
-            List<String> flags = header.containsKey("flags") ? (List<String>) header.get("flags") : Collections.EMPTY_LIST;
-            for (int optLevel : OPT_LEVELS) {
-                if (!flags.contains("onlyStrict")) {
-                    result.add(new Object[]{jsTest.getPath(), jsFileStr, harnessFiles, optLevel, false, errorType});
-                }
-                if (!flags.contains("noStrict")) {
-                    result.add(new Object[]{jsTest.getPath(), jsFileStr, harnessFiles, optLevel, true, errorType});
-                }
-            }
-        }
-        return result;
-    }
-
-    @Test
-    public void test262() throws Exception {
-        executeRhinoScript();
-    }
-
-    static enum EcmaErrorType {
-        NONE,
-        ANY,
-        NotEarlyError,
-        ReferenceError,
-        SyntaxError,
-        Test262Error,
-        TypeError,
-        expected_message;
-
-        static EcmaErrorType _valueOf(String s) {
-            if (s == null || s.equals("")) {
-                return NONE;
-            } else if (s.equals("NotEarlyError")) {
-                return NotEarlyError;
-            } else if (s.equals("ReferenceError")) {
-                return ReferenceError;
-            } else if (s.equals("SyntaxError")) {
-                return SyntaxError;
-            } else if (s.equals("Test262Error")) {
-                return Test262Error;
-            } else if (s.equals("TypeError")) {
-                return TypeError;
-            } else if (s.equals("expected_message")) {
-                return expected_message;
-            }
-            return ANY;
-        }
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/tests/TopLevelStrictModeTest.java b/testsrc/org/mozilla/javascript/tests/TopLevelStrictModeTest.java
deleted file mode 100644
index 0f9d6d0..0000000
--- a/testsrc/org/mozilla/javascript/tests/TopLevelStrictModeTest.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.mozilla.javascript.tests;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest(
-    value = "testsrc/jstests/top-level-strict-mode.js"
-)
-public class TopLevelStrictModeTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/UndefinedOrNullThisInFunctionCallOrApplyTest.java b/testsrc/org/mozilla/javascript/tests/UndefinedOrNullThisInFunctionCallOrApplyTest.java
deleted file mode 100644
index 4d8b46d..0000000
--- a/testsrc/org/mozilla/javascript/tests/UndefinedOrNullThisInFunctionCallOrApplyTest.java
+++ /dev/null
@@ -1,189 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript.tests;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.mozilla.javascript.*;
-
-import java.util.HashMap;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-
-public class UndefinedOrNullThisInFunctionCallOrApplyTest {
-
-    private Context cx;
-
-    private BaseFunction function;
-
-    @Before
-    public void setUp() throws Exception {
-        cx = Context.enter();
-        function = new BaseFunction() {
-            @Override
-            public Object call(Context cx, Scriptable scope, Scriptable thisObj, Object[] args) {
-                System.out.println("QWE");
-                return thisObj;
-            }
-        };
-    }
-
-    @After
-    public void tearDown() throws Exception {
-        cx.setLanguageVersion(Context.VERSION_DEFAULT);
-        Context.exit();
-    }
-
-    @Test
-    @Ignore
-    public void whenVersionGt17ThenPassNullAsThisObjJavaFunc() {
-        HashMap<String, Scriptable> bindings = new HashMap<String, Scriptable>();
-        bindings.put("F2", function);
-
-        cx.setLanguageVersion(Context.VERSION_1_8);
-        NativeArray arr = (NativeArray) Evaluator.eval("[this, F2.apply(), F2.apply(undefined)];", bindings);
-
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("[this, F2.apply(), F2.apply(null)];", bindings);
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        cx.setLanguageVersion(Context.VERSION_ES6);
-        arr = (NativeArray) Evaluator.eval("[this, F2.apply(), F2.apply(undefined)];", bindings);
-
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("[this, F2.apply(), F2.apply(null)];", bindings);
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-    }
-
-    @Test
-    @Ignore
-    public void whenVersionLtEq17ThenPassGlobalThisObjJavaFunc() {
-        HashMap<String, Scriptable> bindings = new HashMap<String, Scriptable>();
-        bindings.put("F2", function);
-
-        cx.setLanguageVersion(Context.VERSION_1_7);
-        NativeArray arr = (NativeArray) Evaluator.eval("{return this;};[this, F2.apply(), F2.apply(undefined)];", bindings);
-
-        assertEquals(arr.get(0), arr.get(1));
-        assertEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("[this, F2.apply(), F2.apply(null)];", bindings);
-
-        assertEquals(arr.get(0), arr.get(1));
-        assertEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-    }
-
-    @Test
-    public void whenVersionGt17ThenPassNullAsThisObjForApplyJS() {
-        cx.setLanguageVersion(Context.VERSION_1_8);
-        NativeArray arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.apply(), F2.apply(undefined)];");
-
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertNotEquals(arr.get(1), arr.get(2));
-        assertEquals(Undefined.instance, arr.get(2));
-        assertEquals(Undefined.SCRIPTABLE_UNDEFINED, arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.apply(), F2.apply(null)];");
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        cx.setLanguageVersion(Context.VERSION_ES6);
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.apply(), F2.apply(undefined)];");
-
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertNotEquals(arr.get(1), arr.get(2));
-        assertEquals(Undefined.instance, arr.get(2));
-        assertEquals(Undefined.SCRIPTABLE_UNDEFINED, arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.apply(), F2.apply(null)];");
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-    }
-
-    @Test
-    public void whenVersionLtEq17ThenPassGlobalThisObjForApplyJS() {
-        cx.setLanguageVersion(Context.VERSION_1_7);
-        NativeArray arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.apply(), F2.apply(undefined)];");
-
-        assertEquals(arr.get(0), arr.get(1));
-        assertEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.apply(), F2.apply(null)];");
-
-        assertEquals(arr.get(0), arr.get(1));
-        assertEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-    }
-
-    @Test
-    public void whenVersionGt17ThenPassNullAsThisObjForCallJS() {
-        cx.setLanguageVersion(Context.VERSION_1_8);
-        NativeArray arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.call(), F2.call(undefined)];");
-
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertNotEquals(arr.get(1), arr.get(2));
-        assertEquals(Undefined.instance, arr.get(2));
-        assertEquals(Undefined.SCRIPTABLE_UNDEFINED, arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.call(), F2.call(null)];");
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        cx.setLanguageVersion(Context.VERSION_ES6);
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.call(), F2.call(undefined)];");
-
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertNotEquals(arr.get(1), arr.get(2));
-        assertEquals(Undefined.instance, arr.get(2));
-        assertEquals(Undefined.SCRIPTABLE_UNDEFINED, arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.call(), F2.call(null)];");
-        assertNotEquals(arr.get(0), arr.get(1));
-        assertNotEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-    }
-
-    @Test
-    public void whenVersionLtEq17ThenPassGlobalThisObjForCallJS() {
-        cx.setLanguageVersion(Context.VERSION_1_7);
-        NativeArray arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.call(), F2.call(undefined)];");
-
-        assertEquals(arr.get(0), arr.get(1));
-        assertEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-
-        arr = (NativeArray) Evaluator.eval("function F2() {return this;};[this, F2.call(), F2.call(null)];");
-
-        assertEquals(arr.get(0), arr.get(1));
-        assertEquals(arr.get(0), arr.get(2));
-        assertEquals(arr.get(1), arr.get(2));
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/tests/es5/ObjectToStringNullUndefinedTest.java b/testsrc/org/mozilla/javascript/tests/es5/ObjectToStringNullUndefinedTest.java
deleted file mode 100644
index 452e1fb..0000000
--- a/testsrc/org/mozilla/javascript/tests/es5/ObjectToStringNullUndefinedTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/*
- * Tests for Object.prototype.toString.call(...) on null & undefined
- */
-package org.mozilla.javascript.tests.es5;
-
-import org.junit.After;
-import org.junit.Before;
-import org.mozilla.javascript.*;
-
-import static org.mozilla.javascript.tests.Evaluator.eval;
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-
-public class ObjectToStringNullUndefinedTest {
-    private Context cx;
-    private ScriptableObject scope;
-
-    @Before
-    public void setUp() {
-        cx = Context.enter();
-        cx.setLanguageVersion(200);
-        scope = cx.initStandardObjects();
-    }
-
-    @After
-    public void tearDown() {
-        Context.exit();
-    }
-
-    @Test
-    public void testToStringNullUndefined() {
-        Object result0 = cx.evaluateString(
-                scope, "Object.prototype.toString.call(null)",
-                "15.2.4.2", 1, null
-        );
-        assertEquals("[object Null]", result0);
-
-        Object result1 = cx.evaluateString(
-                scope, "Object.prototype.toString.call(undefined)",
-                "15.2.4.2", 1, null
-        );
-        assertEquals("[object Undefined]", result1);
-    }
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindIndexTest.java b/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindIndexTest.java
index 02fe954..dd7583d 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindIndexTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindIndexTest.java
@@ -4,13 +4,10 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
 @RhinoTest("testsrc/jstests/harmony/array-findIndex.js")
-@LanguageVersion(Context.VERSION_ES6)
 public class ArrayFindIndexTest extends ScriptTestsBase
 {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindTest.java b/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindTest.java
index c053dff..f073854 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/ArrayFindTest.java
@@ -4,13 +4,10 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
 @RhinoTest("testsrc/jstests/harmony/array-find.js")
-@LanguageVersion(Context.VERSION_ES6)
 public class ArrayFindTest extends ScriptTestsBase
 {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/ForOfTest.java b/testsrc/org/mozilla/javascript/tests/harmony/ForOfTest.java
deleted file mode 100644
index ffc4a15..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/ForOfTest.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest("testsrc/jstests/harmony/for-of.js")
-@LanguageVersion(Context.VERSION_ES6)
-public class ForOfTest extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/MathFunctionsTest.java b/testsrc/org/mozilla/javascript/tests/harmony/MathFunctionsTest.java
deleted file mode 100644
index 7702dd9..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/MathFunctionsTest.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest(
-    value = "testsrc/jstests/harmony/math-functions.js"
-)
-public class MathFunctionsTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/MethodDefinitionTest.java b/testsrc/org/mozilla/javascript/tests/harmony/MethodDefinitionTest.java
deleted file mode 100644
index e0f36b0..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/MethodDefinitionTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest("testsrc/jstests/harmony/method-definition.js")
-public class MethodDefinitionTest extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/NumberIsTest.java b/testsrc/org/mozilla/javascript/tests/harmony/NumberIsTest.java
deleted file mode 100644
index 501f056..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/NumberIsTest.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
warning: LF will be replaced by CRLF in testsrc/jstests/harmony/array-find.js.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/jstests/harmony/array-findIndex.js.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/drivers/JsTestsBase.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/drivers/ScriptTestsBase.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/drivers/TestUtils.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/ContextFactoryTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/DoctestsTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/ParserTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/ArrayFindIndexTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/ArrayFindTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/StringCodePointAtTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/StringEndsWithTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/StringIncludesTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/StringNormalizeTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/StringRepeatTest.java.
The file will have its original line endings in your working directory.
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
- package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest(
-    value = "testsrc/jstests/harmony/number-is.js"
-)
-public class NumberIsTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/ParseIntFloatTest.java b/testsrc/org/mozilla/javascript/tests/harmony/ParseIntFloatTest.java
deleted file mode 100644
index 3fdffb4..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/ParseIntFloatTest.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest(
-    value = "testsrc/jstests/harmony/parse-int-float.js"
-)
-public class ParseIntFloatTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/PropertyOrderingTest.java b/testsrc/org/mozilla/javascript/tests/harmony/PropertyOrderingTest.java
deleted file mode 100644
index 15f2ce0..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/PropertyOrderingTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest("testsrc/jstests/harmony/property-ordering.js")
-@LanguageVersion(Context.VERSION_ES6)
-public class PropertyOrderingTest
-    extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/StringCodePointAtTest.java b/testsrc/org/mozilla/javascript/tests/harmony/StringCodePointAtTest.java
index 62d8f83..abacb55 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/StringCodePointAtTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/StringCodePointAtTest.java
@@ -4,13 +4,11 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
-@RhinoTest("testsrc/jstests/harmony/string-codePointAt.js")
-@LanguageVersion(Context.VERSION_ES6)
-public class StringCodePointAtTest extends ScriptTestsBase
-{
+@RhinoTest(
+    value = "testsrc/jstests/harmony/string-codePointAt.js"
+)
+public class StringCodePointAtTest extends ScriptTestsBase {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/StringEndsWithTest.java b/testsrc/org/mozilla/javascript/tests/harmony/StringEndsWithTest.java
index a1e3593..fb32556 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/StringEndsWithTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/StringEndsWithTest.java
@@ -4,13 +4,11 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
-@RhinoTest("testsrc/jstests/harmony/string-endsWith.js")
-@LanguageVersion(Context.VERSION_ES6)
-public class StringEndsWithTest extends ScriptTestsBase
-{
+@RhinoTest(
+    value = "testsrc/jstests/harmony/string-endsWith.js"
+)
+public class StringEndsWithTest extends ScriptTestsBase {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/StringIncludesTest.java b/testsrc/org/mozilla/javascript/tests/harmony/StringIncludesTest.java
index 64ae194..71e2641 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/StringIncludesTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/StringIncludesTest.java
@@ -4,13 +4,10 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
 @RhinoTest("testsrc/jstests/harmony/string-includes.js")
-@LanguageVersion(Context.VERSION_ES6)
 public class StringIncludesTest extends ScriptTestsBase
 {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/StringNormalizeTest.java b/testsrc/org/mozilla/javascript/tests/harmony/StringNormalizeTest.java
index 1b48274..ce2ad67 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/StringNormalizeTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/StringNormalizeTest.java
@@ -4,12 +4,11 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
-@RhinoTest("testsrc/jstests/harmony/string-normalize.js")
-@LanguageVersion(Context.VERSION_ES6)
+@RhinoTest(
+    value = "testsrc/jstests/harmony/string-normalize.js"
+)
 public class StringNormalizeTest extends ScriptTestsBase {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/StringRepeatTest.java b/testsrc/org/mozilla/javascript/tests/harmony/StringRepeatTest.java
index 09458b5..dd21401 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/StringRepeatTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/StringRepeatTest.java
@@ -4,12 +4,11 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
-@RhinoTest("testsrc/jstests/harmony/string-repeat.js")
-@LanguageVersion(Context.VERSION_ES6)
+@RhinoTest(
+    value = "testsrc/jstests/harmony/string-repeat.js"
+)
 public class StringRepeatTest extends ScriptTestsBase {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/StringStartsWithTest.java b/testsrc/org/mozilla/javascript/tests/harmony/StringStartsWithTest.java
index 4b696b5..b1c8c50 100644
--- a/testsrc/org/mozilla/javascript/tests/harmony/StringStartsWithTest.java
+++ b/testsrc/org/mozilla/javascript/tests/harmony/StringStartsWithTest.java
@@ -4,13 +4,11 @@
 
 package org.mozilla.javascript.tests.harmony;
 
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
 import org.mozilla.javascript.drivers.RhinoTest;
 import org.mozilla.javascript.drivers.ScriptTestsBase;
 
-@RhinoTest("testsrc/jstests/harmony/string-startsWith.js")
-@LanguageVersion(Context.VERSION_ES6)
-public class StringStartsWithTest extends ScriptTestsBase
-{
+@RhinoTest(
+    value = "testsrc/jstests/harmony/string-startsWith.js"
+)
+public class StringStartsWithTest extends ScriptTestsBase {
 }
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/SymbolTest.java b/testsrc/org/mozilla/javascript/tests/harmony/SymbolTest.java
deleted file mode 100644
index 7dc2d86..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/SymbolTest.java
+++ /dev/null
@@ -1,16 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript.tests.harmony;
-
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.drivers.LanguageVersion;
-import org.mozilla.javascript.drivers.RhinoTest;
-import org.mozilla.javascript.drivers.ScriptTestsBase;
-
-@RhinoTest("testsrc/jstests/harmony/symbols.js")
-@LanguageVersion(Context.VERSION_ES6)
-public class SymbolTest extends ScriptTestsBase
-{
-}
diff --git a/testsrc/org/mozilla/javascript/tests/harmony/ToSourceTest.java b/testsrc/org/mozilla/javascript/tests/harmony/ToSourceTest.java
deleted file mode 100644
index 542471c..0000000
--- a/testsrc/org/mozilla/javascript/tests/harmony/ToSourceTest.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-package org.mozilla.javascript.tests.harmony;
-
-import org.junit.Assert;
-import org.junit.Test;
-import org.mozilla.javascript.CompilerEnvirons;
-import org.mozilla.javascript.Context;
-import org.mozilla.javascript.Parser;
-import org.mozilla.javascript.ast.AstRoot;
-
-
-public class ToSourceTest {
-
-  private void assertSource(String source, String expectedOutput) {
-    CompilerEnvirons env = new CompilerEnvirons();
-    env.setLanguageVersion(Context.VERSION_ES6);
-    Parser parser = new Parser(env);
-    AstRoot root = parser.parse(source, null, 0);
-    Assert.assertEquals(expectedOutput, root.toSource());
-  }
-
-
-  /**
-   * Tests that var declaration AST nodes is properly decompiled.
-   */
-  @Test
-  public void testArrowFunctionToSource() {
-    assertSource("var a3 = a.map(s => s.length);", "var a3 = a.map(s => s.length);\n");
-  }
-
-}
diff --git a/testsrc/test262.properties b/testsrc/test262.properties
deleted file mode 100644
index 241b6dd..0000000
--- a/testsrc/test262.properties
+++ /dev/null
@@ -1,291 +0,0 @@
-built-ins/String
-    ! prototype/replace/15.5.4.11-1.js
-    ! prototype/replace/S15.5.4.11_A12.js
-    ! prototype/S15.5.4_A1.js
-    ! prototype/S15.5.4_A2.js
-    ! prototype/S15.5.4_A3.js
-    ! prototype/split/S15.5.4.14_A2_T37.js
-    ! prototype/substring/S15.5.4.15_A1_T5.js
-    ! raw
-    ! fromCodePoint
-    ! prototype/Symbol.iterator/this-val-non-obj-coercible.js
-    ! prototype/endsWith/return-abrupt-from-searchstring-regexp-test.js
-    ! prototype/includes/return-abrupt-from-searchstring-regexp-test.js
-    ! prototype/includes/return-true-if-searchstring-is-empty.js
-    ! prototype/normalize/return-normalized-string-using-default-parameter.js
-    ! prototype/replace/cstm-replace-get-err.js
-    ! prototype/replace/cstm-replace-invocation.js
-    ! prototype/startsWith/return-abrupt-from-searchstring-regexp-test.js
-    ! prototype/toLocaleLowerCase/special_casing_conditional.js
-    ! prototype/toLowerCase/special_casing_conditional.js
-
-built-ins/StringIteratorPrototype
-
-language/statements/for-of
-    ! Array.prototype.entries.js
-    ! Array.prototype.keys.js
-    ! body-dstr-assign-error.js
-    ! body-put-error.js
-    ! for-of/break
-    ! const-bound-names-fordecl-tdz-for-of.js
-    ! const-fresh-binding-per-iteration-for-of.js
-    ! for-of/continue
-    ! for-of/generator
-    ! generic-iterable.js
-    ! iterator-as-proxy.js
-    ! iterator-close-get-method-error.js
-    ! iterator-close-non-object.js
-    ! iterator-close-via-break.js
-    ! iterator-close-via-return.js
-    ! iterator-close-via-throw.js
-    ! iterator-next-result-type.js
-    ! let-bound-names-fordecl-tdz-for-of.js
-    ! let-fresh-binding-per-iteration-for-of.js
-    ! for-of/map
-    ! nested.js
-    ! for-of/return
-    ! for-of/set
-    ! for-of/throw
-    ! for-of/yield
-
-built-ins/Array
-# incorrect length handling
-    ! every/15.4.4.16-3-7
-    ! every/15.4.4.16-3-8
-    ! every/15.4.4.16-3-12
-    ! every/15.4.4.16-3-14
-    ! every/15.4.4.16-3-25
-    ! every/15.4.4.16-3-29
-    ! filter/15.4.4.20-3-7
-    ! filter/15.4.4.20-3-12
-    ! filter/15.4.4.20-3-25
-    ! forEach/15.4.4.18-3-7
-    ! forEach/15.4.4.18-3-12
-    ! forEach/15.4.4.18-3-25
-    ! indexOf/15.4.4.14-3-7
-    ! indexOf/15.4.4.14-3-8
-    ! indexOf/15.4.4.14-3-12
-    ! indexOf/15.4.4.14-3-14
-    ! indexOf/15.4.4.14-3-25
-    ! indexOf/15.4.4.14-3-28
-    ! indexOf/15.4.4.14-3-29
-    ! join/S15.4.4.5_A4_T3
-    ! lastIndexOf/15.4.4.15-3-7
-    ! lastIndexOf/15.4.4.15-3-12
-    ! lastIndexOf/15.4.4.15-3-25
-    ! lastIndexOf/15.4.4.15-3-28
-    ! map/15.4.4.19-3-7
-    ! map/15.4.4.19-3-8
-    ! map/15.4.4.19-3-12
-    ! map/15.4.4.19-3-14
-    ! map/15.4.4.19-3-25
-    ! map/15.4.4.19-3-28
-    ! map/15.4.4.19-3-29
-    ! pop/S15.4.4.6_A2_T2
-    ! pop/S15.4.4.6_A3_T1
-    ! pop/S15.4.4.6_A3_T2
-    ! pop/S15.4.4.6_A3_T3
-    ! push/S15.4.4.7_A2_T2
-    ! push/S15.4.4.7_A4_T1
-    ! push/S15.4.4.7_A4_T3
-    ! reduce/15.4.4.21-3-7
-    ! reduce/15.4.4.21-3-12
-    ! reduce/15.4.4.21-3-25
-    ! reduceRight/15.4.4.22-3-7
-    ! reduceRight/15.4.4.22-3-12
-    ! reduceRight/15.4.4.22-3-25
-    ! reverse/S15.4.4.8_A3_T3
-    ! shift/S15.4.4.9_A3_T3
-    ! slice/S15.4.4.10_A3_T1
-    ! slice/S15.4.4.10_A3_T2
-    ! slice/S15.4.4.10_A3_T3
-    ! some/15.4.4.17-3-7
-    ! some/15.4.4.17-3-8
-    ! some/15.4.4.17-3-12
-    ! some/15.4.4.17-3-14
-    ! some/15.4.4.17-3-25
-    ! some/15.4.4.17-3-28
-    ! some/15.4.4.17-3-29
-    ! sort/S15.4.4.11_A4_T3
-    ! splice/S15.4.4.12_A3_T1
-    ! splice/S15.4.4.12_A3_T3
-    ! splice/S15.4.4.12_A6.1_T2
-    ! unshift/S15.4.4.13_A3_T2
-# bugs?
-    ! splice/S15.4.4.12_A6.1_T3
-# 'this === null' or 'this === undefined'
-    ! every/15.4.4.16-1-1
-    ! every/15.4.4.16-1-2
-    ! filter/15.4.4.20-1-1
-    ! filter/15.4.4.20-1-2
-    ! forEach/15.4.4.18-1-1
-    ! forEach/15.4.4.18-1-2
-    ! indexOf/15.4.4.14-1-1
-    ! indexOf/15.4.4.14-1-2
-    ! indexOf/15.4.4.14-5-28
-    ! lastIndexOf/15.4.4.15-1-1
-    ! lastIndexOf/15.4.4.15-1-2
-    ! lastIndexOf/15.4.4.15-5-28
-    ! map/15.4.4.19-1-1
-    ! map/15.4.4.19-1-2
-    ! reduce/15.4.4.21-1-1
-    ! reduce/15.4.4.21-1-2
-    ! reduceRight/15.4.4.22-1-1
-    ! reduceRight/15.4.4.22-1-2
-    ! some/15.4.4.17-1-1
-    ! some/15.4.4.17-1-2
-# strictness issues
-    ! every/15.4.4.16-5-1-s
-    ! filter/15.4.4.20-5-1-s
-    ! find/Array.prototype.find_this-arg
-    ! find/Array.prototype.find_this-arg-receiver-primitive
-    ! find/Array.prototype.find_this-undefined
-    ! findIndex/Array.prototype.findIndex_this-arg
-    ! findIndex/Array.prototype.findIndex_this-arg-receiver-coercion
-    ! findIndex/Array.prototype.findIndex_this-arg-receiver-primitive
-    ! forEach/15.4.4.18-5-1-s
-    ! map/15.4.4.19-5-1-s
-    ! reduce/15.4.4.21-9-c-ii-4-s
-    ! reduceRight/15.4.4.22-9-c-ii-4-s
-    ! some/15.4.4.17-5-1-s
-    ! sort/S15.4.4.11_A8
-    ! prototype/findIndex/predicate-call-this-strict.js
-    ! prototype/find/predicate-call-this-strict.js
-    ! prototype/splice/set_length_no_args.js
-    ! prototype/toLocaleString/primitive_this_value.js
-    ! prototype/toLocaleString/primitive_this_value_getter.js
-
-# not implemented
-    ! Proxy
-    ! symbol
-    ! Symbol
-    ! from/
-    ! of/
-    ! fill/
-    ! concat/
-    ! entries/
-    ! keys/
-    ! copyWithin
-    ! values
-
-built-ins/ArrayIteratorPrototype
-
-language/expressions/arrow-function
-# not implemented
-## strict mode
-    ! ArrowFunction_restricted-properties.js
-## class syntax
-    ! lexical-new.target-closure-returned.js
-    ! lexical-new.target.js
-    ! lexical-super-call-from-within-constructor.js
-    ! lexical-super-property-from-within-constructor.js
-    ! lexical-super-property.js
-    ! lexical-supercall-from-immediately-invoked-arrow.js
-    ! syntax/early-errors/arrowparameters-bindingidentifier-no-yield.js
-## generator
-    ! syntax/arrowparameters-bindingidentifier-yield.js
-    ! syntax/arrowparameters-cover-formalparameters-yield.js
-    ! syntax/early-errors/arrowparameters-cover-no-yield.js
-## spread operator
-    ! syntax/arrowparameters-cover-includes-rest-concisebody-functionbody.js
-    ! syntax/arrowparameters-cover-rest-concisebody-functionbody.js
-    ! syntax/arrowparameters-cover-rest-lineterminator-concisebody-functionbody.js
-    ! syntax/early-errors/arrowparameters-bindingidentifier-rest.js
-## default parameter
-    ! syntax/arrowparameters-cover-initialize-1.js
-    ! syntax/arrowparameters-cover-initialize-2.js
-## destructuring assignment
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-array-1.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-array-2.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-array-3.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-object-1.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-object-2.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-object-3.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-object-4.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-object-5.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-binding-object-6.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates-rest.js
-    ! syntax/early-errors/arrowparameters-cover-no-duplicates.js
-
-language/arguments-object
-   ! arguments-object/mapped/Symbol.iterator.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-3.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-delete-1.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-delete-2.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-delete-3.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-delete-4.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-nonwritable-1.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-nonwritable-2.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-nonwritable-3.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-nonwritable-4.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-nonwritable-5.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-strict-delete-1.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-strict-delete-2.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-strict-delete-3.js
-   ! arguments-object/mapped/mapped-arguments-nonconfigurable-strict-delete-4.js
-   ! arguments-object/mapped/mapped-arguments-nonwritable-nonconfigurable-1.js
-   ! arguments-object/mapped/mapped-arguments-nonwritable-nonconfigurable-2.js
-   ! arguments-object/mapped/mapped-arguments-nonwritable-nonconfigurable-3.js
-   ! arguments-object/mapped/mapped-arguments-nonwritable-nonconfigurable-4.js
-   ! arguments-object/unmapped/Symbol.iterator.js
-
-language/types/reference
-    ! S8.7.2_A1_T1.js
-    ! S8.7.2_A1_T2.js
-    ! 8.7.2-3-a-1gs.js
-
-built-ins/Object/defineProperties/15.2.3.7-6-a-26.js
-built-ins/Object/defineProperties/15.2.3.7-6-a-27.js
-built-ins/Object/defineProperties/15.2.3.7-6-a-32.js
-built-ins/Object/getOwnPropertyDescriptor/15.2.3.3-4-230.js
-
-language/expressions/delete/11.4.1-4-a-1-s.js
-language/expressions/delete/11.4.1-4-a-2-s.js
-language/expressions/delete/11.4.1-4-a-4-s.js
-language/expressions/delete/11.4.1-4.a-2.js
-language/expressions/delete/11.4.1-4.a-3-s.js
-language/expressions/delete/11.4.1-4.a-3.js
-language/expressions/delete/11.4.1-4.a-4.js
-language/expressions/delete/11.4.1-4.a-8-s.js
-language/expressions/delete/11.4.1-4.a-9-s.js
-language/expressions/delete/11.4.1-4.a-9.js
-language/expressions/delete/11.4.4-4.a-3-s.js
-
-language/keywords
-# expected:<ReferenceError> but was:<SyntaxError>
-    ! S7.6.1.1_A1.18.js
-
-language/future-reserved-words
-
-expressions/postfix-decrement
-expressions/postfix-increment
-expressions/prefix-decrement
-expressions/prefix-increment
-
-language/literals/numeric
-
-built-ins/Date
-  ! 15.9.1.15-1.js
-  ! construct_with_date.js
-  ! prototype/setFullYear/15.9.5.40_1.js
-
-built-ins/Object
-  ! assign
-  ! create
-  ! defineProperties
-  ! defineProperty
-  ! freeze
-  ! getOwnPropertyDescriptor
-  ! getOwnPropertySymbols
-  ! getPrototypeOf
-  ! prototype/hasOwnProperty
-  ! prototype/propertyIsEnumerable
-  ! prototype/toLocaleString
-  ! prototype/toString
-  ! prototype/valueOf
-  ! is
-  ! isExtensible
-  ! preventExtensions
-  ! setPrototypeOf
-  ! seal
-  ! symbol_object-returns-fresh-symbol.js
diff --git a/testsrc/tests/js1_5/Regress/regress-416628.js b/testsrc/tests/js1_5/Regress/regress-416628.js
index 871af42..166b70e 100755
--- a/testsrc/tests/js1_5/Regress/regress-416628.js
+++ b/testsrc/tests/js1_5/Regress/regress-416628.js
@@ -66,7 +66,7 @@ function test()
   printStatus(msg);
   printStatus('Order: ' + order);
 
-  reportCompare(true, order < 4, 'BigO ' + order + ' < 4');
+  reportCompare(true, order < 2, 'BigO ' + order + ' < 2');
 
   exitFunc ('test');
 }
diff --git a/testsrc/tests/lc2/Methods/method-006.js b/testsrc/tests/lc2/Methods/method-006.js
new file mode 100644
index 0000000..4318f3f
--- /dev/null
+++ b/testsrc/tests/lc2/Methods/method-006.js
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+gTestfile = 'method-006.js';
+
+/**
+   File Name:      method-006.js
+   Description:
+
+   Assigning a Java method to a JavaScript object should not change the
+   context associated with the Java method -- its this object should
+   be the Java object, not the JavaScript object.
+
+   That is from Flanagan.  In practice, this fails all implementations.
+
+   @author     christine@netscape.com
+   @version    1.00
+*/
+var SECTION = "LiveConnect Objects";
+var VERSION = "1_3";
+var TITLE   = "Assigning a Non-Static Java Method to a JavaScript Object";
+
+startTest();
+writeHeaderToLog( SECTION + " "+ TITLE);
+
+var java_string = new java.lang.String("LiveConnect");
+var js_string   = "JavaScript";
+
+DESCRIPTION = "var java_string = new java.lang.String(\"LiveConnect\");" +
+  "var js_string = \"JavaScript\"" +
+  "js_string.startsWith = java_string.startsWith"+
+  "js_string.startsWith(\"J\")";
+
+EXPECTED = "error";
+
+js_string.startsWith = java_string.startsWith;
+
+new TestCase(
+  SECTION,
+  "var java_string = new java.lang.String(\"LiveConnect\");" +
+  "var js_string = \"JavaScript\"" +
+  "js_string.startsWith = java_string.startsWith"+
+  "js_string.startsWith(\"J\")",
+  true,
+  js_string.startsWith("J") );
+
+test();
+
+function MyObject() {
+  this.println = java.lang.System.out.println;
+  this.classForName = java.lang.Class.forName;
+  return this;
+}
+
diff --git a/toolsrc/org/mozilla/javascript/tools/SourceReader.java b/toolsrc/org/mozilla/javascript/tools/SourceReader.java
index 762d26f..1db218f 100644
--- a/toolsrc/org/mozilla/javascript/tools/SourceReader.java
+++ b/toolsrc/org/mozilla/javascript/tools/SourceReader.java
@@ -2,132 +2,132 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-package org.mozilla.javascript.tools;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.URLConnection;
-
-import org.mozilla.javascript.Kit;
-import org.mozilla.javascript.commonjs.module.provider.ParsedContentType;
-
-/**
- * @author Attila Szegedi
- * @version $Id: SourceReader.java,v 1.2 2010/02/15 19:31:17 szegedia%freemail.hu Exp $
- */
-public class SourceReader
-{
+package org.mozilla.javascript.tools;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+
+import org.mozilla.javascript.Kit;
+import org.mozilla.javascript.commonjs.module.provider.ParsedContentType;
+
+/**
+ * @author Attila Szegedi
+ * @version $Id: SourceReader.java,v 1.2 2010/02/15 19:31:17 szegedia%freemail.hu Exp $
+ */
+public class SourceReader
+{
     public static URL toUrl(String path) {
         // Assume path is URL if it contains a colon and there are at least
-        // 2 characters in the protocol part. The later allows under Windows
-        // to interpret paths with driver letter as file, not URL.
-        if (path.indexOf(':') >= 2) {
-            try {
+        // 2 characters in the protocol part. The later allows under Windows
+        // to interpret paths with driver letter as file, not URL.
+        if (path.indexOf(':') >= 2) {
+            try {
                 return new URL(path);
-            } catch (MalformedURLException ex) {
+            } catch (MalformedURLException ex) {
                 // not a URL
-            }
-        }
+            }
+        }
         return null;
     }
-
+
     public static Object readFileOrUrl(String path, boolean convertToString,
             String defaultEncoding) throws IOException
     {
         URL url = toUrl(path);
-        InputStream is = null;
-        int capacityHint = 0;
-        String encoding;
-        final String contentType;
-        byte[] data;
-        try {
-            if (url == null) {
-                File file = new File(path);
-                contentType = encoding = null;
-                capacityHint = (int)file.length();
-                is = new FileInputStream(file);
-            } else {
-                URLConnection uc = url.openConnection();
-                is = uc.getInputStream();
-                if(convertToString) {
-                    ParsedContentType pct = new ParsedContentType(uc.getContentType());
-                    contentType = pct.getContentType();
-                    encoding = pct.getEncoding();
-                }
-                else {
-                    contentType = encoding = null;
-                }
-                capacityHint = uc.getContentLength();
-                // Ignore insane values for Content-Length
-                if (capacityHint > (1 << 20)) {
-                    capacityHint = -1;
-                }
-            }
-            if (capacityHint <= 0) {
-                capacityHint = 4096;
-            }
-
-            data = Kit.readStream(is, capacityHint);
-        } finally {
-            if(is != null) {
-                is.close();
-            }
-        }
-
-        Object result;
-        if (!convertToString) {
-            result = data;
-        } else {
-            if(encoding == null) {
-                // None explicitly specified in Content-type header. Use RFC-4329
-                // 4.2.2 section to autodetect
-                if(data.length > 3 && data[0] == -1 && data[1] == -2 && data[2] == 0 && data[3] == 0) {
-                    encoding = "UTF-32LE";
-                }
-                else if(data.length > 3 && data[0] == 0 && data[1] == 0 && data[2] == -2 && data[3] == -1) {
-                    encoding = "UTF-32BE";
-                }
-                else if(data.length > 2 && data[0] == -17 && data[1] == -69 && data[2] == -65) {
-                    encoding = "UTF-8";
-                }
-                else if(data.length > 1 && data[0] == -1 && data[1] == -2) {
-                    encoding = "UTF-16LE";
-                }
-                else if(data.length > 1 && data[0] == -2 && data[1] == -1) {
-                    encoding = "UTF-16BE";
-                }
-                else {
-                    // No autodetect. See if we have explicit value on command line
-                    encoding = defaultEncoding;
-                    if(encoding == null) {
-                        // No explicit encoding specification
-                        if(url == null) {
-                            // Local files default to system encoding
-                            encoding = System.getProperty("file.encoding");
-                        }
-                        else if(contentType != null && contentType.startsWith("application/")) {
-                            // application/* types default to UTF-8
-                            encoding = "UTF-8";
-                        }
-                        else {
-                            // text/* MIME types default to US-ASCII
-                            encoding = "US-ASCII";
-                        }
-                    }
-                }
-            }
-            String strResult = new String(data, encoding);
-            // Skip BOM
-            if(strResult.length() > 0 && strResult.charAt(0) == '\uFEFF')
-            {
-                strResult = strResult.substring(1);
-            }
-            result = strResult;
-        }
-        return result;
-    }
-}
+        InputStream is = null;
+        int capacityHint = 0;
+        String encoding;
+        final String contentType;
+        byte[] data;
+        try {
+            if (url == null) {
+                File file = new File(path);
+                contentType = encoding = null;
+                capacityHint = (int)file.length();
+                is = new FileInputStream(file);
+            } else {
+                URLConnection uc = url.openConnection();
+                is = uc.getInputStream();
+                if(convertToString) {
+                    ParsedContentType pct = new ParsedContentType(uc.getContentType());
+                    contentType = pct.getContentType();
+                    encoding = pct.getEncoding();
+                }
+                else {
+                    contentType = encoding = null;
+                }
+                capacityHint = uc.getContentLength();
+                // Ignore insane values for Content-Length
+                if (capacityHint > (1 << 20)) {
+                    capacityHint = -1;
+                }
+            }
+            if (capacityHint <= 0) {
+                capacityHint = 4096;
+            }
+
+            data = Kit.readStream(is, capacityHint);
+        } finally {
+            if(is != null) {
+                is.close();
+            }
+        }
+
+        Object result;
+        if (!convertToString) {
+            result = data;
+        } else {
+            if(encoding == null) {
+                // None explicitly specified in Content-type header. Use RFC-4329
+                // 4.2.2 section to autodetect
+                if(data.length > 3 && data[0] == -1 && data[1] == -2 && data[2] == 0 && data[3] == 0) {
+                    encoding = "UTF-32LE";
+                }
+                else if(data.length > 3 && data[0] == 0 && data[1] == 0 && data[2] == -2 && data[3] == -1) {
+                    encoding = "UTF-32BE";
+                }
+                else if(data.length > 2 && data[0] == -17 && data[1] == -69 && data[2] == -65) {
+                    encoding = "UTF-8";
+                }
+                else if(data.length > 1 && data[0] == -1 && data[1] == -2) {
+                    encoding = "UTF-16LE";
+                }
+                else if(data.length > 1 && data[0] == -2 && data[1] == -1) {
+                    encoding = "UTF-16BE";
+                }
+                else {
+                    // No autodetect. See if we have explicit value on command line
+                    encoding = defaultEncoding;
+                    if(encoding == null) {
+                        // No explicit encoding specification
+                        if(url == null) {
+                            // Local files default to system encoding
+                            encoding = System.getProperty("file.encoding");
+                        }
+                        else if(contentType != null && contentType.startsWith("application/")) {
+                            // application/* types default to UTF-8
+                            encoding = "UTF-8";
+                        }
+                        else {
+                            // text/* MIME types default to US-ASCII
+                            encoding = "US-ASCII";
+                        }
+                    }
+                }
+            }
+            String strResult = new String(data, encoding);
+            // Skip BOM
+            if(strResult.length() > 0 && strResult.charAt(0) == '\uFEFF')
+            {
+                strResult = strResult.substring(1);
+            }
+            result = strResult;
+        }
+        return result;
+    }
+}
diff --git a/toolsrc/org/mozilla/javascript/tools/debugger/SwingGui.java b/toolsrc/org/mozilla/javascript/tools/debugger/SwingGui.java
index a0328d1..9fcc1bd 100644
--- a/toolsrc/org/mozilla/javascript/tools/debugger/SwingGui.java
+++ b/toolsrc/org/mozilla/javascript/tools/debugger/SwingGui.java
@@ -41,6 +41,7 @@ import java.util.EventObject;
 import java.util.Map;
 import java.util.HashMap;
 import java.util.Properties;
+import java.util.TreeMap;
 import java.io.*;
 import javax.swing.tree.DefaultTreeCellRenderer;
 import javax.swing.tree.TreePath;
@@ -122,7 +123,7 @@ public class SwingGui extends JFrame implements GuiCallback {
      * Hash table of script URLs to their internal frames.
      */
     private final Map<String,FileWindow> fileWindows =
-        Collections.synchronizedMap(new HashMap<String,FileWindow>());
+        Collections.synchronizedMap(new TreeMap<String,FileWindow>());
 
 
     /**
@@ -449,7 +450,19 @@ public class SwingGui extends JFrame implements GuiCallback {
      * @param lineNumber the line number to select, or -1
      */
     protected void showFileWindow(String sourceUrl, int lineNumber) {
-        FileWindow w = getFileWindow(sourceUrl);
+        FileWindow w;
+        if (sourceUrl != null) {
+        	w = getFileWindow(sourceUrl);
+        }
+        else {
+            JInternalFrame f = getSelectedFrame();
+            if (f != null && f instanceof FileWindow) {
+            	w = (FileWindow) f;
+            }
+            else {
+            	w = currentWindow;
+            }
+        }
         if (w == null) {
             Dim.SourceInfo si = dim.sourceInfo(sourceUrl);
             createFileWindow(si, -1);
@@ -458,6 +471,9 @@ public class SwingGui extends JFrame implements GuiCallback {
         if (lineNumber > -1) {
             int start = w.getPosition(lineNumber-1);
             int end = w.getPosition(lineNumber)-1;
+            if (start <= 0) {
+            	return;
+            }
             w.textArea.select(start);
             w.textArea.setCaretPosition(start);
             w.textArea.moveCaretPosition(end);
@@ -860,6 +876,26 @@ public class SwingGui extends JFrame implements GuiCallback {
             FindFunction dlg = new FindFunction(this, "Go to function",
                                                 "Function");
             dlg.showDialog(this);
+        } else if (cmd.equals("Go to line...")) {
+        	final String s = (String) JOptionPane.showInputDialog(
+                    this,
+                    "Line number",
+                    "Go to line...",
+                    JOptionPane.QUESTION_MESSAGE,
+                    null,
+                    null,
+                    null);
+        	if (s == null) {
+        		return;
+        	}
+        	try {
+        		final int line = Integer.parseInt(s);
+                showFileWindow(null, line);
+        	}
+        	catch (final NumberFormatException nfe) {
+        		// ignore
+        	}
+        	
         } else if (cmd.equals("Tile")) {
             JInternalFrame[] frames = desk.getAllFrames();
             int count = frames.length;
@@ -3219,8 +3255,9 @@ class Menubar extends JMenuBar implements ActionListener {
                                   KeyEvent.VK_N,
                                   0,
                                   KeyEvent.VK_Q};
-        String[] editItems = {"Cut", "Copy", "Paste", "Go to function..."};
-        char[] editShortCuts = {'T', 'C', 'P', 'F'};
+        String[] editItems = {"Cut", "Copy", "Paste", "Go to function...", "Go to line..."};
+        char[] editShortCuts = {'T', 'C', 'P', 'F', 'L'};
+        int[] editAccelerators = {0, 0, 0, 0, KeyEvent.VK_L };
         String[] debugItems = {"Break", "Go", "Step Into", "Step Over", "Step Out"};
         char[] debugShortCuts = {'B', 'G', 'I', 'O', 'T'};
         String[] plafItems = {"Metal", "Windows", "Motif"};
@@ -3262,6 +3299,10 @@ class Menubar extends JMenuBar implements ActionListener {
                                            editShortCuts[i]);
             item.addActionListener(this);
             editMenu.add(item);
+            if (editAccelerators[i] != 0) {
+                KeyStroke k = KeyStroke.getKeyStroke(editAccelerators[i], Event.CTRL_MASK);
+                item.setAccelerator(k);
+            }
         }
         for (int i = 0; i < plafItems.length; ++i) {
             JMenuItem item = new JMenuItem(plafItems[i],
warning: LF will be replaced by CRLF in testsrc/org/mozilla/javascript/tests/harmony/StringStartsWithTest.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/tests/js1_5/Regress/regress-416628.js.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in testsrc/tests/lc2/Methods/method-006.js.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in toolsrc/org/mozilla/javascript/tools/debugger/SwingGui.java.
The file will have its original line endings in your working directory.
warning: LF will be replaced by CRLF in toolsrc/org/mozilla/javascript/tools/resources/Messages.properties.
The file will have its original line endings in your working directory.
diff --git a/toolsrc/org/mozilla/javascript/tools/resources/Messages.properties b/toolsrc/org/mozilla/javascript/tools/resources/Messages.properties
index 0c53545..47b8abc 100644
--- a/toolsrc/org/mozilla/javascript/tools/resources/Messages.properties
+++ b/toolsrc/org/mozilla/javascript/tools/resources/Messages.properties
@@ -32,7 +32,7 @@ msg.shell.usage =\
     Valid options are:\n\
     \    -?, -help          Displays help messages.\n\
     \    -w                 Enable warnings.\n\
-    \    -version 100|110|120|130|140|150|160|170|180|200\n\
+    \    -version 100|110|120|130|140|150|160|170|180\n\
     \                       Set a specific language version.\n\
     \    -opt [-1|0-9]      Set optimization level.\n\
     \    -f script-filename Execute script file, or "-" for interactive.\n\
@@ -60,7 +60,6 @@ msg.help =\
     \                       The class must be a script compiled to a \n\
     \                       class file. \n\
     print([expr ...])      Evaluate and print expressions. \n\
-    write([expr ...])      Evaluate and print just like "print" but without a trailing newline. \n\
     quit()                 Quit the shell. \n\
     version([number])      Get or set the JavaScript version number. \n\
     gc()                   Runs the garbage collector.\n\
@@ -68,10 +67,6 @@ msg.help =\
     sync(function [, obj]) Creates a synchronized version of the function, \n\
     \                       where the synchronization object is the obj \n\
     \                       argument or "this" if obj is undefined\n\
-    readline([prompt])\n\
-    \                       Reads a line of input from the console terminal. \n\
-    \                       "prompt" is optional, and if included, will be printed \n\
-    \                       before taking the input. \n\
     readFile(fileName [, encoding])\n\
     \                       Returns the content of the file as a string. \n\
     \                       Encoding of the string can be optionally specified. \n\
diff --git a/toolsrc/org/mozilla/javascript/tools/shell/Global.java b/toolsrc/org/mozilla/javascript/tools/shell/Global.java
index 3d732bd..01626d6 100644
--- a/toolsrc/org/mozilla/javascript/tools/shell/Global.java
+++ b/toolsrc/org/mozilla/javascript/tools/shell/Global.java
@@ -98,7 +98,6 @@ public class Global extends ImporterTopLevel
             "loadClass",
             "print",
             "quit",
-            "readline",
             "readFile",
             "readUrl",
             "runCommand",
@@ -108,7 +107,6 @@ public class Global extends ImporterTopLevel
             "sync",
             "toint32",
             "version",
-            "write"
         };
         defineFunctionProperties(names, Global.class,
                                  ScriptableObject.DONTENUM);
@@ -189,20 +187,6 @@ public class Global extends ImporterTopLevel
     public static Object print(Context cx, Scriptable thisObj,
                                Object[] args, Function funObj)
     {
-        return doPrint(args, funObj, true);
-    }
-
-    /**
-     * Print just as in "print," but without the trailing newline.
-     */
-    public static Object write(Context cx, Scriptable thisObj,
-                               Object[] args, Function funObj)
-    {
-        return doPrint(args, funObj, false);
-    }
-
-    private static Object doPrint(Object[] args, Function funObj, boolean newline)
-    {
         PrintStream out = getInstance(funObj).getOut();
         for (int i=0; i < args.length; i++) {
             if (i > 0)
@@ -213,9 +197,7 @@ public class Global extends ImporterTopLevel
 
             out.print(s);
         }
-        if (newline) {
-            out.println();
-        }
+        out.println();
         return Context.getUndefinedValue();
     }
 
@@ -1130,25 +1112,6 @@ public class Global extends ImporterTopLevel
         }
     }
 
-    /**
-     * The readline reads one line from the standard input. "Prompt" is optional.
-     * <p>
-     * Usage:
-     * <pre>
-     * readline(prompt)
-     * </pre>
-     */
-     public static Object readline(Context cx, Scriptable thisObj, Object[] args, Function funObj)
-         throws IOException
-     {
-         Global self = getInstance(funObj);
-
-         if (args.length > 0) {
-             return self.console.readLine(Context.toString(args[0]));
-         }
-         return self.console.readLine();
-     }
-
     private static String getCharCodingFromType(String type)
     {
         int i = type.indexOf(';');
warning: LF will be replaced by CRLF in toolsrc/org/mozilla/javascript/tools/shell/Global.java.
The file will have its original line endings in your working directory.
